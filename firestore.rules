rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is admin
    function isAdmin() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Admins collection - read own profile only
    match /admins/{adminId} {
      allow read: if isOwner(adminId);
      allow write: if false;
    }

    // Users collection (for role management)
    match /users/{userId} {
      allow read: if isAdmin() || isOwner(userId);
      // Allow create from authenticated user OR for bypass grants (REST API with key protection)
      allow create: if (isAuthenticated() && request.auth.uid == userId) ||
                      request.resource.data.keys().hasOnly(['go-liveBypassed', 'bypassedAt', 'bypassedBy', 'quickAccessCode']);
      allow update: if isAdmin() || isOwner(userId) ||
                      // Allow bypass field updates from REST API (API has its own key protection)
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['go-liveBypassed', 'bypassedAt', 'bypassedBy', 'quickAccessCode', 'bypassRevokedAt']) ||
                      // Allow role/pending updates from REST API (affectedKeys returns top-level keys only)
                      // API has its own admin key protection
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['roles', 'pendingRoles', 'displayName', 'approved', 'updatedAt']);
      allow delete: if isAdmin();
    }

    // System collection (master lists, settings)
    match /system/{docId} {
      allow read: if true;
      // Allow updating quickAccessKey usedBy array (for access code redemption)
      allow update: if isAdmin() ||
                      (docId == 'quickAccessKey' &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['usedBy']));
      allow create, delete: if isAdmin();
    }

    // Artists collection
    match /artists/{artistId} {
      allow read: if true;
      allow create: if isAuthenticated() || request.resource.data.approved == true;
      allow update: if isAdmin() || isOwner(artistId) ||
                      // Allow admin API updates (for approved artists)
                      (request.resource.data.approved == true && request.resource.data.userId == artistId) ||
                      // Allow role revocation from REST API (API has admin key protection)
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['isArtist', 'isMerchSupplier', 'revokedAt', 'revokedBy', 'updatedAt',
                                  'artistName', 'name', 'displayName', 'email', 'phone', 'approved', 'suspended', 'adminNotes']);
      allow delete: if isAdmin();
    }

    // Customers collection
    match /customers/{customerId} {
      allow read: if isAdmin() || isOwner(customerId);
      allow create: if isAuthenticated() && request.auth.uid == customerId;
      allow update: if isAdmin() || isOwner(customerId) ||
                      // Allow role updates from REST API (API has admin key protection)
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['roles', 'isArtist', 'isMerchSupplier', 'approved', 'updatedAt']);
      allow delete: if isAdmin();
    }

    // Orders collection
    match /orders/{orderId} {
      allow read: if isAdmin() ||
                    (isAuthenticated() && resource.data.customerId == request.auth.uid) ||
                    (isAuthenticated() && resource.data.artistId == request.auth.uid);
      allow create: if isAuthenticated();
      allow update, delete: if isAdmin();
    }

    // Products collection - public read
    match /products/{productId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Merch products collection - public read
    match /merch_products/{productId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Merch collection - public read
    match /merch/{productId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Merch stock movements - admin only
    match /merch-stock-movements/{movementId} {
      allow read, write: if isAdmin();
    }

    // Merch suppliers - public read, admin write
    match /merch-suppliers/{supplierId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Tracks collection - linked to releases
    match /tracks/{trackId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Releases collection - public read, admin write
    // Server-side processing allowed for new submissions (has submissionId + pending status)
    match /releases/{releaseId} {
      allow read: if true;
      allow create: if isAdmin() || isAuthenticated() ||
                      // Allow server-side release processing (from process-release API)
                      (request.resource.data.submissionId != null && request.resource.data.status == 'pending');
      allow update: if isAdmin() ||
                      // Allow stat updates from REST API
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['plays', 'downloads', 'views', 'likes', 'ratings', 'updatedAt',
                                  'status', 'published', 'approved', 'adminNotes']);
      allow delete: if isAdmin();
    }

    // DJ Mixes collection (hyphenated) - public read
    // Note: create/stat updates allow server-side API (REST API doesn't have auth token)
    match /dj-mixes/{mixId} {
      allow read: if true;
      allow create: if request.resource.data.userId != null;
      allow update: if isAdmin() ||
                      (isAuthenticated() && resource.data.userId == request.auth.uid) ||
                      // Allow stat updates and admin metadata updates from anyone (needed for REST API)
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['plays', 'likes', 'downloads', 'playCount', 'likeCount', 'downloadCount',
                                  'last_played_date', 'last_liked_date', 'last_unliked_date',
                                  'last_download_date', 'last_downloaded_date', 'commentCount', 'comments', 'ratings', 'updatedAt',
                                  'title', 'name', 'djName', 'dj_name', 'displayName', 'genre',
                                  'description', 'shoutOuts', 'artworkUrl', 'imageUrl', 'artwork_url',
                                  'tracklist', 'tracklistArray', 'trackCount', 'published', 'allowDownload', 'featured', 'userId']);
      // Only admin can delete mixes
      allow delete: if isAdmin();
    }

    // DJ Mixes collection (underscore) - public read
    // Note: create/stat updates allow server-side API (REST API doesn't have auth token)
    match /dj_mixes/{mixId} {
      allow read: if true;
      allow create: if request.resource.data.userId != null;
      allow update: if isAdmin() ||
                      (isAuthenticated() && resource.data.userId == request.auth.uid) ||
                      // Allow stat updates and admin metadata updates from anyone (needed for REST API)
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['plays', 'likes', 'downloads', 'playCount', 'likeCount', 'downloadCount',
                                  'last_played_date', 'last_liked_date', 'last_unliked_date',
                                  'last_download_date', 'last_downloaded_date', 'commentCount', 'comments', 'ratings', 'updatedAt',
                                  'title', 'name', 'djName', 'dj_name', 'displayName', 'genre',
                                  'description', 'shoutOuts', 'artworkUrl', 'imageUrl', 'artwork_url',
                                  'tracklist', 'tracklistArray', 'trackCount', 'published', 'allowDownload', 'featured', 'userId']);
      // Only admin can delete mixes
      allow delete: if isAdmin();
    }

    // DJ Mixes Pending - authenticated create, admin manage
    match /dj_mixes_pending/{mixId} {
      allow read: if isAdmin() || (isAuthenticated() && resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated();
      allow update, delete: if isAdmin();
    }

    // Sales collection - admin and artist read
    match /sales/{saleId} {
      allow read: if isAdmin() || (isAuthenticated() && resource.data.artistId == request.auth.uid);
      allow write: if isAdmin();
    }

    // Carts collection - user owns their cart
    match /carts/{userId} {
      allow read, write: if isOwner(userId);
      allow read: if isAdmin();
    }

    // Analytics collection - admin only
    match /analytics/{docId} {
      allow read, write: if isAdmin();
    }

    // Reviews collection - public read, authenticated write
    match /reviews/{reviewId} {
      allow read: if true;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAdmin() || (isAuthenticated() && resource.data.userId == request.auth.uid);
    }

    // Notifications collection - user owns their notifications
    match /notifications/{notificationId} {
      allow read: if isAdmin() || (isAuthenticated() && resource.data.userId == request.auth.uid);
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);
      allow create, delete: if isAdmin();
    }

    // Activity collection - authenticated read/create
    match /activity/{activityId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update, delete: if isAdmin();
    }

    // Settings collection - public read, admin write
    match /settings/{settingId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Reports collection - authenticated create, admin manage
    match /reports/{reportId} {
      allow read: if isAdmin() || (isAuthenticated() && resource.data.reportedBy == request.auth.uid);
      allow create: if isAuthenticated();
      allow update, delete: if isAdmin();
    }

    // Playlists collection - public read, owner write
    match /playlists/{playlistId} {
      allow read: if true;
      allow create: if isAuthenticated();
      allow update, delete: if isAdmin() || (isAuthenticated() && resource.data.userId == request.auth.uid);
    }

    // Newsletter subscriptions (legacy) - public create for signup
    match /newsletter/{emailId} {
      allow create: if true;
      allow read, update, delete: if isAdmin();
    }

    // Newsletter subscribers - public create for signup
    match /subscribers/{subscriberId} {
      allow create: if true;
      allow read, update, delete: if isAdmin();
    }

    // Contact forms - public create
    match /contact_submissions/{submissionId} {
      allow create: if true;
      allow read, update, delete: if isAdmin();
    }

    // ============================================
    // LIVESTREAM RULES
    // ============================================

    // Livestream chat - public read, create with userId
    match /livestream-chat/{messageId} {
      allow read: if true;
      // Allow creating chat messages if userId is provided (for REST API)
      allow create: if isAuthenticated() || request.resource.data.userId != null;
      allow update, delete: if isAdmin() || (isAuthenticated() && resource.data.userId == request.auth.uid);
    }

    // Livestream slots (schedule) - public read, authenticated write
    match /livestreamSlots/{slotId} {
      allow read: if true;
      // Allow test slot creation for development (slotId starts with 'test_')
      allow create: if isAuthenticated() || slotId.matches('test_.*');
      allow update: if isAdmin() ||
                      (isAuthenticated() && resource.data.djId == request.auth.uid) ||
                      // Allow test slot updates
                      slotId.matches('test_.*') ||
                      // Allow viewer stat updates and status changes (for cleanup)
                      (request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['currentViewers', 'totalLikes', 'averageRating', 'ratingCount',
                                  'peakViewers', 'totalViews', 'status', 'endedAt', 'updatedAt', 'cleanupReason']));
      allow delete: if isAdmin();
    }

    // Active streams - public read, authenticated write
    match /activeStreams/{streamId} {
      allow read: if true;
      allow write: if isAuthenticated();
    }

    // Livestreams collection (stream data) - public read
    match /livestreams/{streamId} {
      allow read: if true;
      // Allow writes for active stream document (REST API needs this for test/webhook)
      allow write: if isAuthenticated() || streamId == 'active';
    }

    // Livestream reactions (likes, ratings) - authenticated create
    match /livestream-reactions/{reactionId} {
      allow read: if true;
      allow create: if isAuthenticated();
      allow update, delete: if isAdmin() || (isAuthenticated() && resource.data.userId == request.auth.uid);
    }

    // Livestream viewers - authenticated write
    match /livestream-viewers/{viewerId} {
      allow read: if true;
      allow write: if isAuthenticated();
    }

    // Stream listeners - for view counting (public for anonymous viewers)
    match /stream-listeners/{listenerId} {
      allow read: if true;
      allow create, update: if true;  // Allow anonymous view tracking
      allow delete: if isAdmin();
    }

    // Live Settings (global playlist, etc) - public read, playlist updates allowed
    // Note: API validates user authentication via request body (userId)
    match /liveSettings/{docId} {
      allow read: if true;
      // Allow authenticated users OR REST API updates with lastUpdated field
      allow create, update: if isAuthenticated() ||
                              request.resource.data.lastUpdated != null;
      allow delete: if isAdmin();
    }

    // DJ Takeover Requests - authenticated only
    match /djTakeoverRequests/{docId} {
      allow read, write: if isAuthenticated();
    }

    // DJ Lobby presence - authenticated only
    match /djLobby/{docId} {
      allow read, write: if isAuthenticated();
    }

    // DJ Lobby Bypass tracking - admin manage
    // Note: REST API bypass grants are protected by adminKey check in the API
    match /djLobbyBypass/{userId} {
      // Allow public read for eligibility checks
      allow read: if true;
      // Allow writes from admin or bypass field updates only
      allow create, update: if isAdmin() ||
                              request.resource.data.keys().hasOnly(['email', 'name', 'reason', 'grantedAt', 'grantedBy', 'stationName', 'relayUrl', 'relayApproved']);
      allow delete: if isAdmin();
    }

    // DJ Lobby Presence - authenticated only
    match /djLobbyPresence/{odamiMa} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated();
    }

    // DJ Bypass Requests - user can create their own, admin manages
    match /bypassRequests/{requestId} {
      allow read: if isAdmin() || (isAuthenticated() && resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAdmin();
    }

    // DJ Lobby chat - authenticated only
    match /djLobbyChat/{messageId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update, delete: if isAdmin() || (isAuthenticated() && resource.data.userId == request.auth.uid);
    }

    // Gift cards - admin only
    match /giftcards/{cardId} {
      allow read: if isAdmin();
      allow write: if isAdmin();
    }

    // Quick access keys - admin only
    match /quickAccessKeys/{keyId} {
      allow read, write: if isAdmin();
    }

    // Pending Role Requests - for admin API access to pending approvals
    // This collection mirrors pendingRoles from users for REST API access
    match /pendingRoleRequests/{requestId} {
      allow read: if true;  // Admin APIs need to read pending requests
      // Allow create from authenticated users OR REST API (for migration/registration)
      allow create: if isAuthenticated() || request.resource.data.status == 'pending';
      allow update, delete: if isAdmin() || request.resource.data.status != 'pending';
    }

    // Default deny
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
