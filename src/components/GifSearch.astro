---
// GifSearch.astro
// Enhanced Multi-source GIF search: Giphy + Tenor + Gfycat + ImgFlip + Reddit
// Mobile-optimized with source indicators and improved variety

interface Props {
  giphyKey?: string;
  tenorKey?: string;
}

const {
  giphyKey = import.meta.env.PUBLIC_GIPHY_API_KEY || '',
  tenorKey = import.meta.env.PUBLIC_TENOR_API_KEY || 'AIzaSyBDE4U5jO6q9ylzafVqWNBvkS8CREqe69U'
} = Astro.props;
---

<div id="gif-modal" class="gif-modal" style="display:none">
  <div class="gif-modal-backdrop"></div>
  <div class="gif-modal-box">
    <div class="gif-modal-header">
      <span class="gif-modal-title">üé¨ GIF SEARCH</span>
      <div class="gif-source-count" id="gif-source-count">5 sources</div>
      <button class="gif-modal-close" id="gif-close" aria-label="Close">‚úï</button>
    </div>
    <div class="gif-search-wrap">
      <input 
        type="text" 
        id="gif-input" 
        class="gif-search-input" 
        placeholder="Search millions of GIFs..." 
        autocomplete="off"
        enterkeyhint="search"
      />
      <div class="gif-search-icon">üîç</div>
    </div>
    <div class="gif-filters">
      <button class="gif-filter-btn active" data-filter="all">All</button>
      <button class="gif-filter-btn" data-filter="giphy">Giphy</button>
      <button class="gif-filter-btn" data-filter="tenor">Tenor</button>
      <button class="gif-filter-btn" data-filter="gfycat">Gfycat</button>
      <button class="gif-filter-btn" data-filter="reddit">Reddit</button>
    </div>
    <div id="gif-grid" class="gif-grid"></div>
  </div>
</div>

<style>
  .gif-modal {
    position: fixed;
    inset: 0;
    z-index: 99999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.75rem;
  }

  .gif-modal-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .gif-modal-box {
    position: relative;
    width: 100%;
    max-width: 560px;
    max-height: 90vh;
    max-height: 90dvh;
    background: linear-gradient(180deg, #1a1a2e 0%, #16162a 100%);
    border: 2px solid #3b82f6;
    border-radius: 1.25rem;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 25px 50px rgba(59, 130, 246, 0.25);
  }

  .gif-modal-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.875rem 1rem;
    background: linear-gradient(135deg, #3b82f6, #6366f1);
  }

  .gif-modal-title {
    font-weight: 800;
    font-size: 1.1rem;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    text-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  .gif-source-count {
    margin-left: auto;
    font-size: 0.7rem;
    font-weight: 600;
    color: rgba(255,255,255,0.8);
    background: rgba(0,0,0,0.2);
    padding: 0.25rem 0.5rem;
    border-radius: 1rem;
  }

  .gif-modal-close {
    width: 36px;
    height: 36px;
    background: rgba(0, 0, 0, 0.25);
    border: none;
    border-radius: 0.625rem;
    color: #fff;
    font-size: 1.25rem;
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .gif-modal-close:hover {
    background: rgba(0, 0, 0, 0.4);
    transform: scale(1.05);
  }

  .gif-modal-close:active {
    transform: scale(0.95);
  }

  .gif-search-wrap {
    position: relative;
    padding: 1rem;
  }

  .gif-search-input {
    width: 100%;
    padding: 0.9rem 1rem 0.9rem 2.75rem;
    background: #0d0d1a;
    border: 2px solid #6366f1;
    border-radius: 0.75rem;
    color: #fff;
    font-size: 1rem;
    outline: none;
    transition: all 0.2s;
  }

  .gif-search-input:focus {
    border-color: #a78bfa;
    box-shadow: 0 0 0 4px rgba(167, 139, 250, 0.2);
  }

  .gif-search-input::placeholder {
    color: rgba(255, 255, 255, 0.35);
  }

  .gif-search-icon {
    position: absolute;
    left: 1.75rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1rem;
    pointer-events: none;
    opacity: 0.6;
  }

  .gif-filters {
    display: flex;
    gap: 0.5rem;
    padding: 0 1rem 0.75rem;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .gif-filters::-webkit-scrollbar {
    display: none;
  }

  .gif-filter-btn {
    padding: 0.375rem 0.75rem;
    font-size: 0.75rem;
    font-weight: 600;
    color: rgba(255,255,255,0.6);
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 2rem;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.15s;
  }

  .gif-filter-btn:hover {
    color: #fff;
    background: rgba(255,255,255,0.15);
  }

  .gif-filter-btn.active {
    color: #fff;
    background: linear-gradient(135deg, #3b82f6, #6366f1);
    border-color: transparent;
  }

  .gif-grid {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 0 0.75rem 0.75rem;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.5rem;
    min-height: 200px;
    max-height: 400px;
    -webkit-overflow-scrolling: touch;
  }

  .gif-grid::-webkit-scrollbar {
    width: 6px;
  }

  .gif-grid::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
  }

  .gif-grid::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.25);
    border-radius: 3px;
  }

  .gif-item {
    position: relative;
    aspect-ratio: 1;
    overflow: hidden;
    border-radius: 0.625rem;
    cursor: pointer;
    background: rgba(0, 0, 0, 0.4);
    transition: transform 0.15s, box-shadow 0.15s;
  }

  .gif-item:hover {
    transform: scale(1.04);
    z-index: 1;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
  }

  .gif-item:active {
    transform: scale(0.98);
  }

  .gif-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: opacity 0.2s;
  }

  .gif-item img.loading {
    opacity: 0.4;
  }

  .gif-source-badge {
    position: absolute;
    bottom: 4px;
    left: 4px;
    font-size: 0.55rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    padding: 2px 5px;
    border-radius: 3px;
    color: #fff;
    opacity: 0;
    transition: opacity 0.15s;
    pointer-events: none;
  }

  .gif-item:hover .gif-source-badge {
    opacity: 1;
  }

  .gif-source-badge.giphy { background: #00ff99; color: #000; }
  .gif-source-badge.tenor { background: #3b82f6; }
  .gif-source-badge.gfycat { background: #6366f1; }
  .gif-source-badge.reddit { background: #ff4500; }
  .gif-source-badge.imgflip { background: #1a73e8; }

  .gif-empty {
    grid-column: 1 / -1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 3rem 1rem;
    color: rgba(255, 255, 255, 0.4);
    text-align: center;
  }

  .gif-empty span {
    font-size: 3rem;
    margin-bottom: 0.75rem;
  }

  .gif-empty p {
    font-size: 0.9rem;
    line-height: 1.4;
  }

  .gif-loading {
    grid-column: 1 / -1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2.5rem;
    gap: 0.75rem;
  }

  .gif-spinner {
    width: 36px;
    height: 36px;
    border: 3px solid rgba(255, 255, 255, 0.1);
    border-top-color: #3b82f6;
    border-radius: 50%;
    animation: gif-spin 0.6s linear infinite;
  }

  .gif-loading-text {
    font-size: 0.75rem;
    color: rgba(255,255,255,0.5);
  }

  @keyframes gif-spin {
    to { transform: rotate(360deg); }
  }

  /* Mobile optimizations */
  @media (max-width: 500px) {
    .gif-modal {
      padding: 0;
      align-items: flex-end;
    }

    .gif-modal-box {
      max-width: 100%;
      max-height: 85vh;
      max-height: 85dvh;
      border-radius: 1.25rem 1.25rem 0 0;
      border-bottom: none;
    }

    .gif-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 0.375rem;
      padding: 0 0.5rem 0.5rem;
      max-height: 50vh;
      max-height: 50dvh;
    }

    .gif-search-wrap {
      padding: 0.75rem;
    }

    .gif-filters {
      padding: 0 0.75rem 0.5rem;
    }

    .gif-item {
      border-radius: 0.5rem;
    }

    .gif-source-badge {
      opacity: 1;
      font-size: 0.5rem;
    }
  }

  /* Landscape mobile */
  @media (max-height: 500px) and (orientation: landscape) {
    .gif-modal-box {
      max-height: 95vh;
    }
    
    .gif-grid {
      grid-template-columns: repeat(4, 1fr);
      max-height: 40vh;
    }
  }

  /* Touch devices */
  @media (hover: none) {
    .gif-source-badge {
      opacity: 0.85;
    }
    
    .gif-item:hover {
      transform: none;
    }
    
    .gif-item:active {
      transform: scale(0.95);
    }
  }
</style>

<script define:vars={{ giphyKey, tenorKey }}>
(function() {
  const config = { 
    giphyKey, 
    tenorKey, 
    limit: 15, // Per source
    debounceMs: 180 
  };
  
  let searchCache = new Map();
  let trendingCache = null;
  let currentQuery = '';
  let currentFilter = 'all';
  let searchTimeout = null;
  let onInsertCallback = null;
  let allResults = [];

  function init() {
    const modal = document.getElementById('gif-modal');
    if (!modal) return;
    
    const backdrop = modal.querySelector('.gif-modal-backdrop');
    const closeBtn = document.getElementById('gif-close');
    const input = document.getElementById('gif-input');
    const filterBtns = modal.querySelectorAll('.gif-filter-btn');

    backdrop?.addEventListener('click', closeModal);
    closeBtn?.addEventListener('click', closeModal);
    
    input?.addEventListener('input', () => {
      const q = input.value.trim();
      if (q.length < 2) { 
        if (q.length === 0) showTrending(); 
        return; 
      }
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => search(q), config.debounceMs);
    });

    input?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { 
        e.preventDefault();
        clearTimeout(searchTimeout); 
        const q = input.value.trim();
        if (q.length >= 2) search(q); 
      }
      if (e.key === 'Escape') closeModal();
    });

    filterBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        filterBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentFilter = btn.dataset.filter || 'all';
        renderGifs(filterResults(allResults));
      });
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && modal.style.display !== 'none') closeModal();
    });

    // Preload trending
    fetchTrending().then(gifs => { trendingCache = gifs; });
  }

  function openModal(callback) {
    onInsertCallback = callback;
    const modal = document.getElementById('gif-modal');
    const input = document.getElementById('gif-input');
    if (!modal) return;
    
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    
    if (input) {
      input.value = '';
      setTimeout(() => input.focus(), 100);
    }
    
    // Reset filter
    currentFilter = 'all';
    document.querySelectorAll('.gif-filter-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.filter === 'all');
    });
    
    showTrending();
  }

  function closeModal() {
    const modal = document.getElementById('gif-modal');
    if (modal) modal.style.display = 'none';
    document.body.style.overflow = '';
  }

  async function showTrending() {
    const grid = document.getElementById('gif-grid');
    if (!grid) return;
    
    if (trendingCache) { 
      allResults = trendingCache;
      renderGifs(filterResults(trendingCache)); 
      return; 
    }
    
    grid.innerHTML = '<div class="gif-loading"><div class="gif-spinner"></div><span class="gif-loading-text">Loading trending GIFs...</span></div>';
    
    try {
      const gifs = await fetchTrending();
      trendingCache = gifs;
      allResults = gifs;
      renderGifs(filterResults(gifs));
    } catch { 
      grid.innerHTML = '<div class="gif-empty"><span>üî•</span><p>Type to search millions of GIFs</p></div>'; 
    }
  }

  async function fetchTrending() {
    const results = await Promise.allSettled([
      fetchGiphyTrending(),
      fetchTenorTrending(),
      fetchGfycatTrending(),
      fetchRedditGifs('gifs', 'hot'),
      fetchImgFlipMemes()
    ]);
    updateSourceCount(results);
    return shuffle(results);
  }

  async function search(query) {
    if (!query || query.length < 2) return;
    currentQuery = query;
    const grid = document.getElementById('gif-grid');
    if (!grid) return;
    
    const cacheKey = query.toLowerCase();
    if (searchCache.has(cacheKey)) { 
      allResults = searchCache.get(cacheKey);
      renderGifs(filterResults(allResults)); 
      return; 
    }
    
    grid.innerHTML = '<div class="gif-loading"><div class="gif-spinner"></div><span class="gif-loading-text">Searching 5 sources...</span></div>';
    
    try {
      const results = await Promise.allSettled([
        searchGiphy(query),
        searchTenor(query),
        searchGfycat(query),
        searchReddit(query),
        searchImgFlip(query)
      ]);
      
      if (query !== currentQuery) return; // Cancelled
      
      const gifs = shuffle(results);
      searchCache.set(cacheKey, gifs);
      
      // Limit cache size
      if (searchCache.size > 30) {
        const firstKey = searchCache.keys().next().value;
        searchCache.delete(firstKey);
      }
      
      allResults = gifs;
      updateSourceCount(results);
      renderGifs(filterResults(gifs));
    } catch { 
      grid.innerHTML = '<div class="gif-empty"><span>üòï</span><p>Search failed. Try again!</p></div>'; 
    }
  }

  function updateSourceCount(results) {
    const successCount = results.filter(r => r.status === 'fulfilled' && r.value?.length > 0).length;
    const countEl = document.getElementById('gif-source-count');
    if (countEl) countEl.textContent = `${successCount} sources`;
  }

  function filterResults(gifs) {
    if (currentFilter === 'all') return gifs;
    return gifs.filter(g => g.source === currentFilter);
  }

  function shuffle(results) {
    const all = [];
    results.forEach(r => { 
      if (r.status === 'fulfilled' && r.value) all.push(...r.value); 
    });
    
    // Fisher-Yates shuffle for true randomness
    for (let i = all.length - 1; i > 0; i--) { 
      const j = Math.floor(Math.random() * (i + 1)); 
      [all[i], all[j]] = [all[j], all[i]]; 
    }
    return all;
  }

  function renderGifs(gifs) {
    const grid = document.getElementById('gif-grid');
    if (!grid) return;
    
    if (!gifs?.length) { 
      grid.innerHTML = '<div class="gif-empty"><span>üòï</span><p>No GIFs found. Try different keywords!</p></div>'; 
      return; 
    }
    
    grid.innerHTML = '';
    
    gifs.forEach(gif => {
      if (!gif.url) return;
      
      const item = document.createElement('div');
      item.className = 'gif-item';
      
      const img = document.createElement('img');
      img.className = 'loading';
      img.loading = 'lazy';
      img.alt = 'GIF';
      img.src = gif.preview || gif.url;
      img.onload = () => img.classList.remove('loading');
      img.onerror = () => item.remove();
      
      // Source badge
      const badge = document.createElement('span');
      badge.className = `gif-source-badge ${gif.source}`;
      badge.textContent = gif.source;
      
      item.appendChild(img);
      item.appendChild(badge);
      
      item.addEventListener('click', () => { 
        if (onInsertCallback) onInsertCallback(gif); 
        closeModal(); 
      });
      
      grid.appendChild(item);
    });
  }

  // ==================== GIPHY ====================
  async function searchGiphy(q) {
    if (!config.giphyKey) return [];
    try {
      const r = await fetch(`https://api.giphy.com/v1/gifs/search?api_key=${config.giphyKey}&q=${encodeURIComponent(q)}&limit=${config.limit}&rating=pg-13`);
      if (!r.ok) return [];
      const d = await r.json();
      return (d.data||[]).map(g=>({
        id: g.id,
        url: g.images.fixed_height.url,
        preview: g.images.fixed_height_small?.url || g.images.fixed_height_downsampled?.url,
        source: 'giphy'
      }));
    } catch { return []; }
  }

  async function fetchGiphyTrending() {
    if (!config.giphyKey) return [];
    try {
      const r = await fetch(`https://api.giphy.com/v1/gifs/trending?api_key=${config.giphyKey}&limit=${config.limit}&rating=pg-13`);
      if (!r.ok) return [];
      const d = await r.json();
      return (d.data||[]).map(g=>({
        id: g.id,
        url: g.images.fixed_height.url,
        preview: g.images.fixed_height_small?.url || g.images.fixed_height_downsampled?.url,
        source: 'giphy'
      }));
    } catch { return []; }
  }

  // ==================== TENOR ====================
  async function searchTenor(q) {
    if (!config.tenorKey) return [];
    try {
      const r = await fetch(`https://tenor.googleapis.com/v2/search?key=${config.tenorKey}&q=${encodeURIComponent(q)}&limit=${config.limit}&contentfilter=medium&media_filter=tinygif,gif`);
      if (!r.ok) return [];
      const d = await r.json();
      return (d.results||[]).map(g=>({
        id: g.id,
        url: g.media_formats?.gif?.url,
        preview: g.media_formats?.tinygif?.url || g.media_formats?.nanogif?.url,
        source: 'tenor'
      })).filter(g => g.url);
    } catch { return []; }
  }

  async function fetchTenorTrending() {
    if (!config.tenorKey) return [];
    try {
      const r = await fetch(`https://tenor.googleapis.com/v2/featured?key=${config.tenorKey}&limit=${config.limit}&contentfilter=medium&media_filter=tinygif,gif`);
      if (!r.ok) return [];
      const d = await r.json();
      return (d.results||[]).map(g=>({
        id: g.id,
        url: g.media_formats?.gif?.url,
        preview: g.media_formats?.tinygif?.url || g.media_formats?.nanogif?.url,
        source: 'tenor'
      })).filter(g => g.url);
    } catch { return []; }
  }

  // ==================== GFYCAT ====================
  async function searchGfycat(q) {
    try {
      const r = await fetch(`https://api.gfycat.com/v1/gfycats/search?search_text=${encodeURIComponent(q)}&count=${config.limit}`);
      if (!r.ok) return [];
      const d = await r.json();
      return (d.gfycats||[]).map(g=>({
        id: g.gfyId,
        url: g.gifUrl || g.max5mbGif || g.gif100pxUrl,
        preview: g.gif100pxUrl || g.miniUrl,
        source: 'gfycat'
      })).filter(g => g.url);
    } catch { return []; }
  }

  async function fetchGfycatTrending() {
    try {
      const r = await fetch(`https://api.gfycat.com/v1/gfycats/trending?count=${config.limit}`);
      if (!r.ok) return [];
      const d = await r.json();
      return (d.gfycats||[]).map(g=>({
        id: g.gfyId,
        url: g.gifUrl || g.max5mbGif || g.gif100pxUrl,
        preview: g.gif100pxUrl || g.miniUrl,
        source: 'gfycat'
      })).filter(g => g.url);
    } catch { return []; }
  }

  // ==================== REDDIT ====================
  async function fetchRedditGifs(subreddit = 'gifs', sort = 'hot') {
    try {
      const r = await fetch(`https://www.reddit.com/r/${subreddit}/${sort}.json?limit=${config.limit}`);
      if (!r.ok) return [];
      const d = await r.json();
      return (d.data?.children || [])
        .filter(p => {
          const url = p.data?.url || '';
          return url.includes('.gif') || url.includes('i.redd.it') || url.includes('imgur');
        })
        .map(p => ({
          id: p.data.id,
          url: p.data.url,
          preview: p.data.thumbnail !== 'default' ? p.data.thumbnail : p.data.url,
          source: 'reddit'
        }))
        .filter(g => g.url && !g.url.includes('.gifv'));
    } catch { return []; }
  }

  async function searchReddit(q) {
    try {
      const r = await fetch(`https://www.reddit.com/r/gifs/search.json?q=${encodeURIComponent(q)}&restrict_sr=1&sort=relevance&limit=${config.limit}`);
      if (!r.ok) return [];
      const d = await r.json();
      return (d.data?.children || [])
        .filter(p => {
          const url = p.data?.url || '';
          return url.includes('.gif') || url.includes('i.redd.it');
        })
        .map(p => ({
          id: p.data.id,
          url: p.data.url,
          preview: p.data.thumbnail !== 'default' ? p.data.thumbnail : p.data.url,
          source: 'reddit'
        }))
        .filter(g => g.url && !g.url.includes('.gifv'));
    } catch { return []; }
  }

  // ==================== IMGFLIP (Meme GIFs) ====================
  async function fetchImgFlipMemes() {
    try {
      const r = await fetch('https://api.imgflip.com/get_memes');
      if (!r.ok) return [];
      const d = await r.json();
      // Get random selection of meme templates (they work as static images)
      const memes = (d.data?.memes || []).slice(0, config.limit);
      return memes.map(m => ({
        id: m.id,
        url: m.url,
        preview: m.url,
        source: 'imgflip'
      }));
    } catch { return []; }
  }

  async function searchImgFlip(q) {
    try {
      const r = await fetch('https://api.imgflip.com/get_memes');
      if (!r.ok) return [];
      const d = await r.json();
      const qLower = q.toLowerCase();
      const matches = (d.data?.memes || [])
        .filter(m => m.name.toLowerCase().includes(qLower))
        .slice(0, config.limit);
      return matches.map(m => ({
        id: m.id,
        url: m.url,
        preview: m.url,
        source: 'imgflip'
      }));
    } catch { return []; }
  }

  // ==================== GLOBAL API ====================
  window.openGifSearch = openModal;
  window.closeGifSearch = closeModal;

  window.insertGifToChat = function(gif, opts = {}) {
    const container = opts.container || document.getElementById('chat-messages');
    if (!container || !gif?.url) return;
    
    const msg = document.createElement('div');
    msg.className = 'chat-message chat-message-gif';
    msg.innerHTML = `
      <div class="chat-sender">${opts.sender || 'You'}</div>
      <div class="chat-gif-wrap">
        <img src="${gif.url}" class="chat-gif" alt="GIF" loading="lazy" />
      </div>
    `;
    container.appendChild(msg);
    container.scrollTop = container.scrollHeight;
    
    if (opts.sendToServer) {
      opts.sendToServer({ type: 'gif', url: gif.url, source: gif.source });
    }
  };

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
