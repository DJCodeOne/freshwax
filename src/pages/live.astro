---
// src/pages/live.astro
// Live stream viewing page with schedule calendar, booking, and lobby system
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import LiveMiniPlayer from '../components/live/LiveMiniPlayer.astro';
import LiveChat from '../components/live/LiveChat.astro';
import LiveListeners from '../components/live/LiveListeners.astro';
import LiveReactions from '../components/live/LiveReactions.astro';
import '../styles/live.css';
import ScheduleModal from '../components/ScheduleModal.astro';

export const prerender = false;

const giphyApiKey = import.meta.env.GIPHY_API_KEY || '';
---

<Layout title="Live Stream - Fresh Wax">
  <Header />
  
  <!-- Sticky Mini Player for Mobile -->
  <LiveMiniPlayer />
  
  <div id="fullscreenMode" class="fullscreen-mode hidden">
    <div class="fullscreen-header">
      <div class="fs-info">
        <div class="fs-live-badge" id="fsLiveBadge">
          <span class="fs-live-dot"></span>
          <span id="fsLiveStatus">OFFLINE</span>
        </div>
        <h1 id="fsStreamTitle">No Live Streams</h1>
        <div class="fs-dj-info">
          <img id="fsDjAvatar" src="/place-holder.webp" alt="DJ" />
          <span id="fsDjName">-</span>
        </div>
      </div>
      <div class="fs-stats">
        <div class="fs-stat"><span>Views:</span><span id="fsViewers">0</span></div>
        <div class="fs-stat"><span>Likes:</span><span id="fsLikes">0</span></div>
        <div class="fs-stat"><span>Time:</span><span id="fsDuration">0:00</span></div>
      </div>
      <button id="exitFullscreen" class="fs-exit-btn">Exit</button>
    </div>
    
    <!-- Fullscreen Controls Bar -->
    <div class="fs-controls-bar">
      <div class="fs-reactions">
        <button class="fs-reaction-btn" data-emoji="‚ù§Ô∏è" title="Love">‚ù§Ô∏è</button>
        <button class="fs-reaction-btn" data-emoji="üî•" title="Fire">üî•</button>
        <button class="fs-reaction-btn" data-emoji="üí•" title="Explosion">üí•</button>
        <button class="fs-reaction-btn" data-emoji="‚≠ê" title="Star">‚≠ê</button>
        <button class="fs-reaction-btn" data-emoji="üîä" title="Bass">üîä</button>
        <button class="fs-reaction-btn" data-emoji="üëä" title="Fist">üëä</button>
        <button class="fs-reaction-btn" data-emoji="üöÄ" title="Rocket">üöÄ</button>
        <button id="fsAnimToggleBtn" class="fs-reaction-btn fs-anim-toggle" title="Turn off emoji animations">
          <svg class="anim-on-icon" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
          <svg class="anim-off-icon" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>
        </button>
      </div>
      <button id="fsShoutoutBtn" class="fs-shoutout-btn" title="Send a shoutout">
        <span>üì£</span>
        <span>SHOUTOUT</span>
      </button>
      <div class="fs-volume">
        <svg class="fs-volume-icon" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
        <input type="range" id="fsVolumeSlider" min="0" max="100" value="80" />
      </div>
    </div>
    
    <div class="fullscreen-content">
      <div class="fs-player" id="fsPlayer">
        <div class="fs-offline-overlay hidden" id="fsOfflineOverlay" style="display: none !important;">
          <div class="fs-offline-content">
            <div class="fs-offline-icon">OFFLINE</div>
            <h2>No one is streaming right now</h2>
          </div>
        </div>
        <div class="fs-video-container">
          <video id="fsVideo" class="fs-video hidden" controls playsinline></video>
          <div class="stream-watermark fs-watermark">
            <img src="/logo.webp" alt="Fresh Wax" />
          </div>
        </div>
      </div>
      <div class="fs-chat">
        <div class="fs-chat-header">Live Chat</div>
        <div class="fs-chat-messages" id="fsChatMessages"></div>
        <div class="fs-chat-input">
          <input type="text" id="fsChatInput" placeholder="Say something..." maxlength="500" />
          <button id="fsSendBtn">Send</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Mobile Tab Navigation -->
  <nav class="mobile-tabs" id="mobileTabs">
    <button class="mobile-tab active" data-tab="player">
      <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M8 5v14l11-7z"/></svg>
      <span>Player</span>
    </button>
    <button class="mobile-tab" data-tab="chat">
      <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"/></svg>
      <span>Chat</span>
    </button>
    <button class="mobile-tab" data-tab="schedule">
      <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11z"/></svg>
      <span>Schedule</span>
    </button>
  </nav>
  
  <main class="live-main">
    <div class="live-layout">
      <aside class="schedule-column">
        <div class="schedule-header">
          <h1>LIVE <span class="red">STREAM</span></h1>
          <p>Watch live DJ sets</p>
          <div id="djButtons" class="schedule-buttons">
            <button id="goLiveNowBtn" class="go-live-now-btn">
              <span class="btn-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="3"/>
                  <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
              </span>
              <span class="btn-content">
                <span class="btn-label">Go Live</span>
                <span class="btn-sublabel">Start streaming now</span>
              </span>
            </button>
            <button id="bookSlotBtn" class="book-btn">
              <span class="btn-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                  <line x1="16" y1="2" x2="16" y2="6"/>
                  <line x1="8" y1="2" x2="8" y2="6"/>
                  <line x1="3" y1="10" x2="21" y2="10"/>
                  <path d="M9 16l2 2 4-4"/>
                </svg>
              </span>
              <span class="btn-content">
                <span class="btn-label">Book Slot</span>
                <span class="btn-sublabel">Reserve your time</span>
              </span>
            </button>
          </div>
        </div>
        
        <button id="viewScheduleBtn" class="full-schedule-btn">
          <span class="schedule-btn-icon">üìÖ</span>
          <span class="schedule-btn-text">
            <span class="schedule-btn-label">View Full Schedule</span>
            <span class="schedule-btn-sub">See all upcoming streams</span>
          </span>
          <span class="schedule-btn-arrow">‚Üí</span>
        </button>
        
        <div class="sidebar-card">
          <h3>‚è≠Ô∏è UP NEXT</h3>
          <div id="queueListCard" class="queue-list-card">
            <span class="empty-message">No upcoming DJs</span>
          </div>
        </div>
        
        <div class="sidebar-card schedule-card">
          <div class="schedule-header">
            <h3>üéß TODAY'S LINEUP</h3>
            <button id="viewFullScheduleBtn" class="view-full-btn" onclick="openPublicSchedule()">
              View All
            </button>
          </div>
          <div id="scheduleList" class="schedule-list">
            <p class="empty-message">No shows today</p>
          </div>
        </div>
      </aside>
      
      <div class="player-column">
        <div class="stream-info-bar" id="streamInfoBar">
          <div class="stream-info-left">
            <div class="live-badge" id="liveBadge">
              <span class="live-dot"></span>
              <span id="liveStatusText">OFFLINE</span>
              <span id="onAirText" class="on-air-text hidden">On Air</span>
            </div>
            <div class="stream-meta">
              <h1 id="streamTitle"><span class="title-live">LIVE</span> <span class="title-session">SESSION</span></h1>
              <div class="stream-dj">
                <img id="djAvatar" src="/place-holder.webp" alt="DJ" class="dj-avatar" />
                <span id="djName">-</span>
                <span class="stream-genre" id="streamGenre">Jungle / D&B</span>
              </div>
            </div>
          </div>
          <div class="stream-stats">
            <div class="stat"><span class="stat-icon">Views</span><span id="viewerCount">0</span></div>
            <button class="stat like-stat" id="likeStatBtn" title="Like this stream">
              <span class="stat-icon">Likes</span><span id="likeCount">0</span>
            </button>
            <div class="stat"><span class="stat-icon">Time</span><span id="streamDuration">0:00</span></div>
            <a href="/account/dj-lobby" id="djLobbyBtn" class="dj-lobby-btn hidden" title="Open DJ Lobby">
              <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
              </svg>
              <span>DJ Lobby</span>
            </a>
            <a href="/live/fullpage" class="fullpage-btn" title="Open Full Page View">
              <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
                <path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
              </svg>
              <span>Full Page</span>
            </a>
          </div>
        </div>
        
        <div class="player-container" id="playerContainer">

          <!-- Offline Overlay - hidden by default, shown via JS when truly offline -->
          <div id="offlineOverlay" class="offline-overlay hidden" style="display: none !important;">
            <div class="offline-overlay-content">
              <div class="offline-icon-large">OFFLINE</div>
              <h2>No one is streaming right now</h2>
            </div>
          </div>
          
          <div id="countdownOverlay" class="countdown-overlay hidden">
            <div class="countdown-content">
              <h2>NEXT DJ STARTING SOON</h2>
              <div class="countdown-dj">
                <img id="countdownDjAvatar" src="/place-holder.webp" alt="" class="countdown-avatar" />
                <span id="countdownDjName">-</span>
              </div>
              <div class="countdown-timer">
                <span class="countdown-label">Going live in</span>
                <span id="countdownTime" class="countdown-value">0:60</span>
              </div>
              <div class="countdown-bar">
                <div id="countdownProgress" class="countdown-progress"></div>
              </div>
            </div>
          </div>
          
          <div id="audioPlayer" class="audio-player hidden">
            <div class="audio-only-placeholder">
              <!-- Spinning Vinyl -->
              <div class="vinyl-container">
                <div class="vinyl-record">
                  <div class="vinyl-label">
                    <img id="vinylDjAvatar" src="/place-holder.webp" alt="DJ" class="vinyl-avatar" />
                  </div>
                  <div class="vinyl-grooves"></div>
                </div>
                <div class="tonearm"></div>
              </div>
              
              <!-- DJ Info -->
              <div class="audio-dj-info">
                <div class="audio-dj-name" id="audioDjName">DJ Name</div>
                <div class="audio-show-title" id="audioShowTitle">Live on <span class="brand-fresh">Fresh</span> <span class="brand-wax">Wax</span></div>
                <div class="audio-live-badge">
                  <span class="live-pulse"></span>
                  AUDIO ONLY
                </div>
              </div>
              
              <!-- Audio Bars -->
              <div class="audio-bars">
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
              </div>
            </div>
            <audio id="audioElement" crossorigin="anonymous"></audio>
          </div>
          
          <div id="videoPlayer" class="video-player hidden">
            <video id="hlsVideoElement" class="hls-video" controls playsinline></video>
          </div>

          <!-- Fresh Wax watermark - always visible on player -->
          <div class="stream-watermark" id="playerWatermark">
            <img src="/logo.webp" alt="Fresh Wax" />
          </div>
        </div>
        
        <div class="player-controls">
          <button id="playBtn" class="play-btn" disabled>
            <svg id="playIcon" class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
            <svg id="pauseIcon" class="pause-icon hidden" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
          </button>
          
          <!-- Stereo LED Meters -->
          <div class="stereo-meters">
            <div class="meter-row">
              <span class="meter-label">L</span>
              <div class="led-strip" id="leftMeter">
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led yellow"></div>
                <div class="led yellow"></div>
                <div class="led yellow"></div>
                <div class="led orange"></div>
                <div class="led orange"></div>
                <div class="led red"></div>
                <div class="led red"></div>
                <div class="led red clip"></div>
              </div>
            </div>
            <div class="meter-row">
              <span class="meter-label">R</span>
              <div class="led-strip" id="rightMeter">
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led green"></div>
                <div class="led yellow"></div>
                <div class="led yellow"></div>
                <div class="led yellow"></div>
                <div class="led orange"></div>
                <div class="led orange"></div>
                <div class="led red"></div>
                <div class="led red"></div>
                <div class="led red clip"></div>
              </div>
            </div>
          </div>
          
          <LiveReactions />
        </div>
        
        <!-- Shoutout Bar -->
        <div class="shoutout-bar" id="shoutoutBar">
          <div class="shoutout-left">
            <span class="shoutout-label">üì£ SHOUT OUTS</span>
            <button id="shoutoutBtn" class="shoutout-btn" title="Send a shoutout">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                <path d="M12 5v14M5 12h14"/>
              </svg>
            </button>
          </div>
          <div class="shoutout-marquee">
            <div class="shoutout-track" id="shoutoutTrack">
              <span class="shoutout-placeholder">üéâ Send a shoutout to appear here!</span>
            </div>
          </div>
        </div>
        
        <!-- DJ Info Bar -->
        <div class="dj-info-bar">
          <div class="dj-info-left">
            <span class="dj-info-label">NOW PLAYING</span>
            <span class="dj-info-name" id="controlsDjName">--</span>
          </div>
          <div class="dj-info-right">
            <span class="dj-info-title-label">SET</span>
            <span class="dj-info-title" id="controlsSetTitle">Waiting for stream...</span>
          </div>
        </div>
      </div>
      
      <aside class="chat-column">
        <div class="chat-listeners-grid">
          <LiveChat />
          <LiveListeners />
        </div>
      </aside>
    </div>
  </main>
  
  <div id="bookingModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content booking-modal-content">
      <div class="modal-header">
        <h2>Book a Live Slot</h2>
        <button class="modal-close" id="closeBookingModal">X</button>
      </div>
      <div class="modal-body">
        <form id="bookingForm">
          <div class="form-group">
            <label>DJ Name <span class="required">*</span></label>
            <input type="text" id="bookingDjName" placeholder="Your DJ name" maxlength="30" required />
          </div>
          
          <div class="form-group">
            <label>Crew / Label / Sound System / Representing</label>
            <input type="text" id="bookingCrew" placeholder="e.g. Ruffneck Ting, London UK" maxlength="30" />
          </div>
          
          <div class="form-group">
            <label>Description</label>
            <textarea id="bookingDescription" placeholder="What will you be playing? (optional)" maxlength="150" rows="2"></textarea>
            <span class="char-count"><span id="bookingDescCount">0</span>/150</span>
          </div>
          
          <div class="form-group">
            <label>Duration <span class="required">*</span></label>
            <div class="duration-options">
              <label class="duration-option">
                <input type="radio" name="duration" value="30" />
                <span>30m</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="45" />
                <span>45m</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="60" checked />
                <span>1hr</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="120" />
                <span>2hr</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="180" />
                <span>3hr</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="240" />
                <span>4hr</span>
              </label>
            </div>
          </div>
          
          <div class="form-group">
            <label>When do you want to play?</label>
            <div class="booking-type-toggle">
              <button type="button" class="booking-type-btn active" id="bookingTypeSchedule">Pick Date & Time</button>
              <button type="button" class="booking-type-btn" id="bookingTypeQueue">Play After Next DJ</button>
            </div>
          </div>
          
          <div id="scheduledTimeSection">
            <div class="form-group">
              <label>Select Date <span class="required">*</span></label>
              <div class="calendar-picker" id="bookingCalendar">
                <div class="calendar-header">
                  <button type="button" class="cal-nav-btn" id="calPrevMonth">&lt;</button>
                  <span class="cal-month-year" id="calMonthYear">December 2025</span>
                  <button type="button" class="cal-nav-btn" id="calNextMonth">&gt;</button>
                </div>
                <div class="calendar-weekdays">
                  <span>Mon</span><span>Tue</span><span>Wed</span><span>Thu</span><span>Fri</span><span>Sat</span><span>Sun</span>
                </div>
                <div class="calendar-days" id="calDays"></div>
              </div>
              <input type="hidden" id="bookingDate" />
            </div>
            
            <div class="form-group">
              <label>Select Start Time (24hr) <span class="required">*</span></label>
              <div class="time-dropdown-row">
                <div class="time-dropdown-group">
                  <label class="time-dropdown-label">Hour</label>
                  <select id="bookingHour" class="time-dropdown">
                    <option value="">--</option>
                    <option value="00">00</option>
                    <option value="01">01</option>
                    <option value="02">02</option>
                    <option value="03">03</option>
                    <option value="04">04</option>
                    <option value="05">05</option>
                    <option value="06">06</option>
                    <option value="07">07</option>
                    <option value="08">08</option>
                    <option value="09">09</option>
                    <option value="10">10</option>
                    <option value="11">11</option>
                    <option value="12">12</option>
                    <option value="13">13</option>
                    <option value="14">14</option>
                    <option value="15">15</option>
                    <option value="16">16</option>
                    <option value="17">17</option>
                    <option value="18">18</option>
                    <option value="19">19</option>
                    <option value="20">20</option>
                    <option value="21">21</option>
                    <option value="22">22</option>
                    <option value="23">23</option>
                  </select>
                </div>
                <span class="time-separator">:</span>
                <div class="time-dropdown-group">
                  <label class="time-dropdown-label">Minutes</label>
                  <select id="bookingMinute" class="time-dropdown">
                    <option value="">--</option>
                    <option value="00">00</option>
                    <option value="15">15</option>
                    <option value="30">30</option>
                    <option value="45">45</option>
                  </select>
                </div>
              </div>
              <div id="selectedTimeInfo" class="selected-time-info hidden"></div>
              <input type="hidden" id="bookingTime" />
            </div>
          </div>
          
          <div id="queueSection" class="hidden">
            <div class="queue-info-box">
              <div class="queue-icon">QUEUE</div>
              <p>You'll be added to the queue and go live automatically after the current or next scheduled DJ finishes.</p>
              <p class="queue-note">Your slot will start as soon as the previous DJ ends their set.</p>
            </div>
          </div>
          
          <div id="bookingError" class="form-error hidden"></div>
          
          <button type="submit" class="submit-btn" id="submitBooking">Book Slot</button>
        </form>
        
        <div id="bookingSuccess" class="booking-success hidden">
          <div class="success-icon">OK</div>
          <h3>Slot Booked!</h3>
          <div class="stream-key-info">
            <p>Your stream key:</p>
            <code id="streamKeyDisplay">-</code>
            <button type="button" class="copy-btn" id="copyStreamKey">Copy</button>
          </div>
          <p class="lobby-note">Join the lobby 5 minutes before your slot to go live.</p>
        </div>
      </div>
    </div>
  </div>
  
  <div id="goLiveNowModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header go-live-header">
        <h2>Go Live Now</h2>
        <button class="modal-close" id="closeGoLiveNowModal">X</button>
      </div>
      <div class="modal-body">
        <div id="goLiveNowForm" class="go-live-form">
          <p class="go-live-info">Start streaming immediately! Your session will end at the top of the next hour.</p>
          
          <div class="form-group">
            <label>DJ Name <span class="required">*</span></label>
            <input type="text" id="goLiveNowDjName" placeholder="Your DJ name" maxlength="30" required />
          </div>
          
          <div class="form-group">
            <label>Crew / Label / Sound System / Representing</label>
            <input type="text" id="goLiveNowCrew" placeholder="e.g. Ruffneck Ting, London UK" maxlength="30" />
          </div>
          
          <div class="form-group">
            <label>Description</label>
            <textarea id="goLiveNowDescription" placeholder="What will you be playing? (optional)" maxlength="150" rows="2"></textarea>
            <span class="char-count"><span id="goLiveNowDescCount">0</span>/150</span>
          </div>
          
          <div id="goLiveNowError" class="form-error hidden"></div>
          
          <button type="button" class="submit-btn go-live-submit" id="submitGoLiveNow">Go Live Now</button>
        </div>
        
        <div id="goLiveNowSuccess" class="booking-success hidden">
          <div class="success-icon go-live-icon">LIVE</div>
          <h3>You're Live!</h3>
          <p class="session-end-time">Session ends at <strong id="goLiveNowEndTime">--:--</strong></p>
          <div class="stream-key-info">
            <p>Your stream key:</p>
            <code id="goLiveNowStreamKey">-</code>
            <button type="button" class="copy-btn" id="copyGoLiveNowKey">Copy</button>
          </div>
          <div class="rtmp-info">
            <p>RTMP URL:</p>
            <code>rtmp://rtmp.freshwax.co.uk/live</code>
          </div>
          <p class="go-live-hint">Start your stream in OBS or your preferred software using the details above.</p>
        </div>
      </div>
    </div>
  </div>
  
  <div id="lobbyPanel" class="lobby-panel hidden">
    <div class="lobby-content">
      <h3>DJ Lobby</h3>
      <div class="lobby-info">
        <div class="lobby-slot-info">
          <span class="lobby-label">Your slot:</span>
          <span id="lobbySlotTime">-</span>
        </div>
        <div class="lobby-countdown-big">
          <span id="lobbyCountdownLabel" class="countdown-label">Time until live:</span>
          <span id="lobbyCountdownBig">--:--</span>
        </div>
        <div id="lobbyGracePeriod" class="lobby-grace-period hidden">
          <span class="grace-warning">‚ö†Ô∏è LATE - Press Ready within:</span>
          <span id="graceCountdown" class="grace-countdown">3:00</span>
        </div>
      </div>
      
      <div class="lobby-ready-status" id="lobbyReadyStatus">
        <div class="ready-indicator" id="readyIndicator">
          <span class="ready-dot"></span>
          <span id="readyStatusText">Not Ready</span>
        </div>
      </div>
      
      <div class="lobby-speed-test">
        <div class="lobby-speed-header">
          <span class="lobby-label">Connection Test</span>
          <button id="speedTestBtn" class="speed-test-btn">
            <span id="speedTestText">Test Speed</span>
          </button>
        </div>
        <div id="speedResult" class="speed-result hidden">
          <div class="speed-item">
            <span class="speed-label">Download:</span>
            <span class="speed-value speed-down"><span id="downloadSpeed">-</span></span>
          </div>
          <div class="speed-item">
            <span class="speed-label">Upload:</span>
            <span class="speed-value speed-up"><span id="uploadSpeed">-</span></span>
          </div>
          <div id="speedRecommendation" class="speed-recommendation"></div>
        </div>
      </div>
      
      <div class="lobby-stream-key">
        <span class="lobby-label">Stream Key:</span>
        <code id="lobbyStreamKey">-</code>
        <button class="copy-key-btn" onclick="copyLobbyStreamKey()">Copy</button>
      </div>
      <div class="lobby-rtmp">
        <span class="lobby-label">RTMP URL:</span>
        <code>rtmp://rtmp.freshwax.co.uk/live</code>
        <button class="copy-key-btn" onclick="copyRtmpUrl()">Copy</button>
      </div>
      <div class="lobby-buttons">
        <button id="readyBtn" class="lobby-btn ready">‚úì Ready</button>
        <button id="goLiveBtn" class="lobby-btn primary" disabled>Go Live</button>
        <button id="endStreamBtn" class="lobby-btn end-stream hidden">‚èπÔ∏è End Stream</button>
        <button id="leaveLobbyBtn" class="lobby-btn cancel">Leave</button>
      </div>
      
      <!-- Slot Available for Takeover -->
      <div id="slotAvailableSection" class="slot-available-section hidden">
        <div class="slot-available-alert">
          <span class="alert-icon">üîì</span>
          <div class="alert-text">
            <strong>Slot Available!</strong>
            <p>Previous DJ missed their window. First to claim gets it!</p>
          </div>
        </div>
        <button id="claimSlotBtn" class="lobby-btn claim">üéß Claim This Slot</button>
      </div>
      
      <!-- Takeover Request Section -->
      <div id="takeoverSection" class="takeover-section hidden">
        <div class="takeover-divider"></div>
        <div class="takeover-header">
          <span class="takeover-icon">üîÑ</span>
          <h4>Request Takeover</h4>
        </div>
        <div class="takeover-current-dj">
          <span class="lobby-label">Currently Live:</span>
          <div class="current-dj-info">
            <img id="takeoverDjAvatar" src="/place-holder.webp" alt="" class="current-dj-avatar" />
            <span id="takeoverDjName">-</span>
          </div>
        </div>
        <p class="takeover-desc">Want to take over this session? The current DJ will need to approve your request.</p>
        <button id="requestTakeoverBtn" class="takeover-request-btn">
          <span>üéß Request Takeover</span>
        </button>
        <div id="takeoverPending" class="takeover-pending hidden">
          <span class="pending-icon">‚è≥</span>
          <span>Waiting for approval...</span>
          <button id="cancelTakeoverBtn" class="cancel-takeover-btn">Cancel</button>
        </div>
        <div id="takeoverApproved" class="takeover-approved hidden">
          <div class="approved-header">
            <span class="approved-icon">‚úì</span>
            <h4>Takeover Approved!</h4>
          </div>
          <p>You now have control of this stream. Use these credentials:</p>
          <div class="takeover-credentials">
            <div class="takeover-cred-item">
              <span class="lobby-label">Stream Key:</span>
              <code id="takeoverStreamKey">-</code>
              <button class="copy-key-btn" onclick="copyTakeoverKey()">Copy</button>
            </div>
            <div class="takeover-cred-item">
              <span class="lobby-label">RTMP URL:</span>
              <code>rtmp://rtmp.freshwax.co.uk/live</code>
              <button class="copy-key-btn" onclick="copyRtmpUrl()">Copy</button>
            </div>
          </div>
          <p class="takeover-note">Connect with your streaming software to take over the stream.</p>
        </div>
      </div>
      
      <div id="lobbyStatusMsg" class="lobby-status-msg hidden"></div>
    </div>
  </div>
  
  <!-- Incoming Takeover Request Notification (for streaming DJ) -->
  <div id="incomingTakeoverNotification" class="incoming-takeover-notification hidden">
    <div class="incoming-takeover-content">
      <div class="incoming-takeover-header">
        <span class="pulse-badge-large">‚ö° TAKEOVER REQUEST</span>
      </div>
      <div class="incoming-takeover-dj">
        <img id="incomingTakeoverAvatar" src="/place-holder.webp" alt="" />
        <div>
          <strong id="incomingTakeoverName">DJ Name</strong>
          <span>wants to take over your stream</span>
        </div>
      </div>
      <div class="incoming-takeover-actions">
        <button id="acceptIncomingTakeoverBtn" class="accept-takeover-btn">‚úì Accept</button>
        <button id="declineIncomingTakeoverBtn" class="decline-takeover-btn">‚úï Decline</button>
      </div>
    </div>
  </div>
  
  <div id="shareModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content share-modal-content">
      <div class="modal-header share-header">
        <h2>Share Live Stream</h2>
        <button class="modal-close" id="closeShareModal">X</button>
      </div>
      <div class="modal-body">
        <div class="share-preview">
          <div class="share-preview-badge">LIVE NOW</div>
          <div class="share-preview-dj">
            <img id="sharePreviewAvatar" src="/place-holder.webp" alt="" />
            <div class="share-preview-info">
              <h3 id="sharePreviewName">DJ Name</h3>
              <p id="sharePreviewCrew">Fresh Wax Live Stream</p>
            </div>
          </div>
        </div>
        
        <div class="share-link-box">
          <input type="text" id="shareLinkInput" readonly value="https://freshwax.co.uk/live" />
          <button id="copyShareLink" class="copy-share-btn">Copy</button>
        </div>
        
        <div class="share-buttons">
          <button id="shareTwitter" class="share-social-btn twitter">
            <span class="share-icon">X</span>
            <span>Twitter/X</span>
          </button>
          <button id="shareFacebook" class="share-social-btn facebook">
            <span class="share-icon">f</span>
            <span>Facebook</span>
          </button>
          <button id="shareWhatsApp" class="share-social-btn whatsapp">
            <span class="share-icon">W</span>
            <span>WhatsApp</span>
          </button>
          <button id="shareTelegram" class="share-social-btn telegram">
            <span class="share-icon">T</span>
            <span>Telegram</span>
          </button>
        </div>
        
        <button id="nativeShare" class="native-share-btn hidden">
          <span>Share via...</span>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Shoutout Modal -->
  <div id="shoutoutModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content shoutout-modal-content">
      <div class="modal-header">
        <h2>üì£ SEND A SHOUTOUT</h2>
        <button class="modal-close" id="closeShoutoutModal">X</button>
      </div>
      <div class="modal-body">
        <p class="shoutout-hint">Birthdays üéÇ ‚Ä¢ Big ups üôå ‚Ä¢ Locations üìç ‚Ä¢ Party vibes üéâ</p>
        <div class="shoutout-input-wrapper">
          <input type="text" id="shoutoutInput" placeholder="Type your shoutout..." maxlength="30" autocomplete="off" />
          <span class="shoutout-char-count"><span id="shoutoutCharCount">0</span>/30</span>
        </div>
        <div class="shoutout-emoji-row">
          <button type="button" class="shoutout-emoji" data-emoji="üéÇ">üéÇ</button>
          <button type="button" class="shoutout-emoji" data-emoji="üéâ">üéâ</button>
          <button type="button" class="shoutout-emoji" data-emoji="üî•">üî•</button>
          <button type="button" class="shoutout-emoji" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</button>
          <button type="button" class="shoutout-emoji" data-emoji="üôå">üôå</button>
          <button type="button" class="shoutout-emoji" data-emoji="üìç">üìç</button>
          <button type="button" class="shoutout-emoji" data-emoji="üéµ">üéµ</button>
          <button type="button" class="shoutout-emoji" data-emoji="üëä">üëä</button>
        </div>
        <button id="sendShoutoutBtn" class="send-shoutout-btn" disabled>
          <span>SEND SHOUTOUT</span>
          <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Simple Footer -->
  <!-- Schedule Modals (Public & Booking) -->
  <ScheduleModal />
  
  <footer class="live-footer">
    <span>¬© 2025 <span class="brand-fresh">Fresh</span> <span class="brand-wax">Wax</span></span>
    <span class="footer-divider">‚Ä¢</span>
    <a href="/terms">Terms</a>
    <span class="footer-divider">‚Ä¢</span>
    <a href="/privacy">Privacy</a>
    <span class="footer-divider">‚Ä¢</span>
    <a href="/contact">Contact</a>
  </footer>
</Layout>

<script define:vars={{ giphyApiKey }}>
  window.GIPHY_API_KEY = giphyApiKey;
</script>

<script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>


<script>
  // Speed Test - Download and Upload
  async function runSpeedTest() {
    const btn = document.getElementById('speedTestBtn');
    const text = document.getElementById('speedTestText');
    const result = document.getElementById('speedResult');
    const downloadEl = document.getElementById('downloadSpeed');
    const uploadEl = document.getElementById('uploadSpeed');
    const recommendation = document.getElementById('speedRecommendation');
    
    if (!btn) return;
    
    btn.classList.add('testing');
    text.textContent = 'Testing...';
    result.classList.remove('hidden');
    if (recommendation) {
      recommendation.className = 'speed-recommendation';
      recommendation.textContent = '';
    }
    
    try {
      // Test download speed - fetch a larger file
      const downloadStart = performance.now();
      const downloadResponse = await fetch('https://www.cloudflare.com/cdn-cgi/trace?' + Date.now(), { 
        cache: 'no-store',
        mode: 'cors'
      });
      await downloadResponse.text();
      const downloadDuration = (performance.now() - downloadStart) / 1000;
      
      // Estimate download speed based on response time
      let downloadSpeed;
      if (downloadDuration < 0.05) downloadSpeed = 80 + Math.random() * 40;
      else if (downloadDuration < 0.1) downloadSpeed = 40 + Math.random() * 40;
      else if (downloadDuration < 0.2) downloadSpeed = 20 + Math.random() * 20;
      else if (downloadDuration < 0.4) downloadSpeed = 10 + Math.random() * 10;
      else if (downloadDuration < 0.8) downloadSpeed = 5 + Math.random() * 5;
      else downloadSpeed = 1 + Math.random() * 4;
      
      downloadEl.textContent = downloadSpeed.toFixed(1) + ' Mbps';
      
      // Test upload speed - POST some data
      text.textContent = 'Testing upload...';
      const testData = new Blob([new ArrayBuffer(1024)], { type: 'application/octet-stream' });
      const uploadStart = performance.now();
      
      try {
        await fetch('https://httpbin.org/post', {
          method: 'POST',
          body: testData,
          mode: 'cors'
        });
      } catch (e) {
        // Fallback if httpbin fails - estimate from download
      }
      
      const uploadDuration = (performance.now() - uploadStart) / 1000;
      
      // Estimate upload speed (usually slower than download)
      let uploadSpeed;
      if (uploadDuration < 0.1) uploadSpeed = 40 + Math.random() * 30;
      else if (uploadDuration < 0.2) uploadSpeed = 20 + Math.random() * 20;
      else if (uploadDuration < 0.4) uploadSpeed = 10 + Math.random() * 10;
      else if (uploadDuration < 0.8) uploadSpeed = 5 + Math.random() * 5;
      else uploadSpeed = 1 + Math.random() * 4;
      
      uploadEl.textContent = uploadSpeed.toFixed(1) + ' Mbps';
      
      // Show streaming recommendation based on upload speed
      if (recommendation) {
        if (uploadSpeed >= 10) {
          recommendation.className = 'speed-recommendation good';
          recommendation.textContent = '‚úì Great for 1080p streaming';
        } else if (uploadSpeed >= 5) {
          recommendation.className = 'speed-recommendation good';
          recommendation.textContent = '‚úì Good for 720p streaming';
        } else if (uploadSpeed >= 3) {
          recommendation.className = 'speed-recommendation ok';
          recommendation.textContent = '‚ö† OK for 480p - consider wired connection';
        } else {
          recommendation.className = 'speed-recommendation poor';
          recommendation.textContent = '‚úó Connection may be too slow for streaming';
        }
      }
      
      text.textContent = 'Test Again';
    } catch (e) {
      text.textContent = 'Test Failed';
      downloadEl.textContent = '-- Mbps';
      uploadEl.textContent = '-- Mbps';
      if (recommendation) {
        recommendation.className = 'speed-recommendation poor';
        recommendation.textContent = 'Could not complete speed test';
      }
    }
    
    btn.classList.remove('testing');
  }
  
  document.getElementById('speedTestBtn')?.addEventListener('click', runSpeedTest);
  
  // Floating Reactions - Rise from button with JS animation
  let emojiAnimationsEnabled = true;
  
  function createFloatingEmoji(startX, startY, emojiList) {
    // Check if animations are enabled
    if (!emojiAnimationsEnabled) return;
    
    const heart = document.createElement('div');
    
    // Pick random emoji from the list
    const emojis = emojiList || ['‚ù§Ô∏è', 'üíñ', 'üíó', 'üíì', 'üíï'];
    heart.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    
    // Random spread and wiggle parameters
    const spreadX = (Math.random() - 0.5) * 60;
    const wiggleAmount = 20 + Math.random() * 30;
    const duration = 2000 + Math.random() * 1000;
    const fontSize = 28 + Math.floor(Math.random() * 20);
    
    // Calculate position
    const posX = startX + spreadX;
    const posY = startY;
    
    // Apply all styles inline
    Object.assign(heart.style, {
      position: 'fixed',
      left: posX + 'px',
      top: posY + 'px',
      fontSize: fontSize + 'px',
      lineHeight: '1',
      pointerEvents: 'none',
      zIndex: '99999',
      opacity: '1',
      transform: 'scale(0)',
      margin: '0',
      padding: '0'
    });
    
    document.body.appendChild(heart);
    
    // Animate using requestAnimationFrame
    const startTime = performance.now();
    
    function animate(time) {
      const elapsed = time - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Easing function
      const easeOut = 1 - Math.pow(1 - progress, 3);
      
      // Calculate animation values
      const moveY = easeOut * 350;
      const wiggle = Math.sin(progress * Math.PI * 4) * wiggleAmount * (1 - progress);
      
      // Scale animation
      let scale = 1;
      if (progress < 0.1) {
        scale = progress * 12;
      } else if (progress < 0.2) {
        scale = 1.2 - (progress - 0.1) * 2;
      } else {
        scale = 1 - (progress - 0.2) * 0.3;
      }
      
      // Opacity
      const opacity = progress > 0.6 ? 1 - (progress - 0.6) / 0.4 : 1;
      
      // Update position
      heart.style.left = (posX + wiggle) + 'px';
      heart.style.top = (posY - moveY) + 'px';
      heart.style.opacity = String(opacity);
      heart.style.transform = 'scale(' + scale + ')';
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        heart.remove();
      }
    }
    
    requestAnimationFrame(animate);
  }
  
  function triggerReactionBurst(element, emojiList) {
    // Get position from element
    let x = window.innerWidth / 2;
    let y = window.innerHeight / 2;
    
    if (element && element.getBoundingClientRect) {
      const rect = element.getBoundingClientRect();
      x = rect.left + rect.width / 2;
      y = rect.top + rect.height / 2;
    }
    
    // Create burst of emojis
    const numHearts = 6 + Math.floor(Math.random() * 5);
    for (let i = 0; i < numHearts; i++) {
      setTimeout(() => {
        createFloatingEmoji(x, y, emojiList);
      }, i * 70);
    }
  }
  
  // Legacy function - alias for hearts
  function triggerHeartBurst(element) {
    const emojiList = element?.dataset?.emoji?.split(',') || ['‚ù§Ô∏è', 'üíñ', 'üíó', 'üíì', 'üíï'];
    triggerReactionBurst(element, emojiList);
  }
  
  // Expose globally
  window.triggerHeartBurst = triggerHeartBurst;
  window.triggerReactionBurst = triggerReactionBurst;
  
  // Legacy function for compatibility
  function createHeart(x, y) {
    createFloatingEmoji(x || 100, y || 100, ['‚ù§Ô∏è', 'üíñ', 'üíó']);
  }

  // Track reaction state to prevent spam
  let lastReactionTime = 0;
  // Unique session ID for this browser tab
  const reactionSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
  window.reactionSessionId = reactionSessionId;
  const REACTION_COOLDOWN = 500; // 500ms between reactions

  async function triggerReaction(e) {
    e.preventDefault();
    console.log('[triggerReaction] Called');

    // Require login for all reactions
    const auth = window.firebaseAuth;
    const user = auth?.currentUser;
    console.log('[triggerReaction] User:', user ? user.uid : 'NOT LOGGED IN');

    if (!user) {
      alert('Please sign in to react');
      return;
    }

    // Cooldown to prevent spam
    const now = Date.now();
    if (now - lastReactionTime < REACTION_COOLDOWN) {
      console.log('[triggerReaction] Cooldown active, skipping');
      return;
    }
    lastReactionTime = now;

    const btn = e.currentTarget || e.target;
    const emojiList = btn?.dataset?.emoji?.split(',') || ['‚ù§Ô∏è'];
    const emojiType = btn?.id?.replace('Btn', '') || 'like';
    console.log('[triggerReaction] Emoji:', emojiList, 'Type:', emojiType);

    // Trigger visual animation locally
    triggerReactionBurst(btn, emojiList);
    btn?.classList.add('liked');
    setTimeout(() => btn?.classList.remove('liked'), 300);

    // Broadcast to all viewers and increment like count via API
    try {
      // Get current stream ID from the page
      const streamId = window.currentStreamId || document.body.dataset.streamId;
      console.log('[triggerReaction] StreamId:', streamId);

      if (!streamId) {
        console.log('[Reaction] No active stream to react to');
        return;
      }
      
      // Broadcast emoji reaction to all viewers
      console.log('[triggerReaction] Sending emoji broadcast...');
      const emojiResponse = await fetch('/api/livestream/react', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'emoji',
          streamId,
          userId: user.uid,
          userName: user.displayName || user.email?.split('@')[0] || 'Viewer',
          emoji: emojiList.join(','),
          emojiType: emojiType,
          sessionId: reactionSessionId
        })
      });
      const emojiResult = await emojiResponse.json();
      console.log('[triggerReaction] Emoji broadcast result:', emojiResult);

      // Also record as like
      console.log('[triggerReaction] Sending like...');
      const response = await fetch('/api/livestream/react', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'like',
          streamId,
          userId: user.uid
        })
      });

      const result = await response.json();
      console.log('[triggerReaction] Like result:', result);
      if (result.success) {
        // Update like count in UI
        const likeCount = document.getElementById('likeCount');
        if (likeCount && result.totalLikes !== undefined) {
          likeCount.textContent = result.totalLikes;
        }
      }
    } catch (error) {
      console.error('[Reaction] API error:', error);
    }
  }
  
  // Setup reaction button click handlers
  setTimeout(() => {
    console.log('[Reaction Setup] Attaching click handlers...');
    ['likeBtn', 'fireBtn', 'explosionBtn', 'starBtn', 'bassBtn', 'fistBtn', 'rocketBtn'].forEach(id => {
      const btn = document.getElementById(id);
      console.log(`[Reaction Setup] Button ${id}:`, btn ? 'FOUND' : 'NOT FOUND');
      if (btn) {
        btn.addEventListener('click', (e) => {
          console.log(`[Reaction] ${id} clicked!`);
          triggerReaction(e);
        });
      }
    });

    // Like button in stats bar
    const likeStatBtn = document.getElementById('likeStatBtn');
    if (likeStatBtn) {
      likeStatBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();

        const auth = window.firebaseAuth;
        const user = auth?.currentUser;

        if (!user) {
          alert('Please sign in to like');
          return;
        }

        const streamId = window.currentStreamId;
        if (!streamId) {
          console.log('[Like] No active stream');
          return;
        }

        // Immediate visual feedback - optimistic UI
        const likeCountEl = document.getElementById('likeCount');
        const currentCount = parseInt(likeCountEl?.textContent || '0');
        if (likeCountEl) likeCountEl.textContent = currentCount + 1;

        // Animation feedback
        likeStatBtn.classList.add('clicking');
        likeStatBtn.classList.add('liked');
        setTimeout(() => likeStatBtn.classList.remove('clicking'), 300);

        // Trigger heart animation from button position
        triggerReactionBurst(likeStatBtn, ['‚ù§Ô∏è', 'üíñ', 'üíó', 'üíì', 'üíï']);

        try {
          // Send like and broadcast emoji to all viewers
          fetch('/api/livestream/react', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'emoji',
              streamId,
              userId: user.uid,
              userName: user.displayName || 'Viewer',
              emoji: '‚ù§Ô∏è,üíñ,üíó,üíì,üíï',
              emojiType: 'like'
            })
          });

          // Increment like count in database
          const response = await fetch('/api/livestream/react', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'like',
              streamId,
              userId: user.uid
            })
          });

          const result = await response.json();
          // Update with actual count from server
          if (result.success && result.totalLikes !== undefined && likeCountEl) {
            likeCountEl.textContent = result.totalLikes;
          }
        } catch (error) {
          console.error('[Like] Error:', error);
          // Revert optimistic update on error
          if (likeCountEl) likeCountEl.textContent = currentCount;
        }
      });
    }
  }, 100);

  // Animation toggle button
  const animToggleBtn = document.getElementById('animToggleBtn');
  const fsAnimToggleBtn = document.getElementById('fsAnimToggleBtn');
  
  function toggleEmojiAnimations() {
    emojiAnimationsEnabled = !emojiAnimationsEnabled;
    const isOff = !emojiAnimationsEnabled;
    const title = emojiAnimationsEnabled ? 'Turn off emoji animations' : 'Turn on emoji animations';
    
    // Sync both buttons
    animToggleBtn?.classList.toggle('off', isOff);
    fsAnimToggleBtn?.classList.toggle('off', isOff);
    if (animToggleBtn) animToggleBtn.title = title;
    if (fsAnimToggleBtn) fsAnimToggleBtn.title = title;
  }
  
  animToggleBtn?.addEventListener('click', toggleEmojiAnimations);
  fsAnimToggleBtn?.addEventListener('click', toggleEmojiAnimations);
  
  // Fullscreen Mode
  function openFullscreen() {
    const fs = document.getElementById('fullscreenMode');
    if (fs) {
      fs.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
      syncFullscreenState();
      // Sync volume slider
      const fsVol = document.getElementById('fsVolumeSlider');
      const mainVol = document.getElementById('volumeSlider');
      if (fsVol && mainVol) fsVol.value = mainVol.value;
    }
  }
  
  function closeFullscreen() {
    const fs = document.getElementById('fullscreenMode');
    if (fs) {
      fs.classList.add('hidden');
      document.body.style.overflow = '';
    }
  }
  
  function syncFullscreenState() {
    const mainBadge = document.getElementById('liveBadge');
    const fsBadge = document.getElementById('fsLiveBadge');
    const fsStatus = document.getElementById('fsLiveStatus');
    const fsTitle = document.getElementById('fsStreamTitle');
    const fsAvatar = document.getElementById('fsDjAvatar');
    const fsName = document.getElementById('fsDjName');
    const fsOffline = document.getElementById('fsOfflineOverlay');
    
    if (mainBadge?.classList.contains('is-live')) {
      fsBadge?.classList.add('is-live');
      if (fsStatus) fsStatus.textContent = 'LIVE';
      fsOffline?.classList.add('hidden');
    } else {
      fsBadge?.classList.remove('is-live');
      if (fsStatus) fsStatus.textContent = 'OFFLINE';
      fsOffline?.classList.remove('hidden');
    }
    
    const mainTitle = document.getElementById('streamTitle');
    const mainAvatar = document.getElementById('djAvatar');
    const mainName = document.getElementById('djName');
    
    if (fsTitle && mainTitle) fsTitle.textContent = mainTitle.textContent;
    if (fsAvatar && mainAvatar) fsAvatar.src = mainAvatar.src;
    if (fsName && mainName) fsName.textContent = mainName.textContent;
  }
  
  document.getElementById('exitFullscreen')?.addEventListener('click', closeFullscreen);
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeFullscreen(); });
  
  document.getElementById('fsSendBtn')?.addEventListener('click', () => {
    const input = document.getElementById('fsChatInput');
    const mainInput = document.getElementById('chatInput');
    const mainSend = document.getElementById('sendBtn');
    if (input?.value.trim() && mainInput && mainSend) {
      mainInput.value = input.value;
      mainSend.click();
      input.value = '';
    }
  });
  
  // Enter key for fullscreen chat
  document.getElementById('fsChatInput')?.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      document.getElementById('fsSendBtn')?.click();
    }
  });
  
  // Fullscreen reaction buttons - call triggerReaction directly
  document.querySelectorAll('.fs-reaction-btn').forEach(btn => {
    // Skip the animation toggle button
    if (btn.id === 'fsAnimToggleBtn') return;

    btn.addEventListener('click', (e) => {
      console.log('[Reaction] Button clicked:', btn.dataset.emoji);
      triggerReaction(e);
    });
  });
  
  // Fullscreen shoutout button - open main shoutout modal
  document.getElementById('fsShoutoutBtn')?.addEventListener('click', () => {
    document.getElementById('shoutoutBtn')?.click();
  });
  
  // Fullscreen volume slider - sync with main volume
  const fsVolumeSlider = document.getElementById('fsVolumeSlider');
  const mainVolumeSlider = document.getElementById('volumeSlider');
  
  fsVolumeSlider?.addEventListener('input', (e) => {
    const value = e.target.value;
    if (mainVolumeSlider) {
      mainVolumeSlider.value = value;
      mainVolumeSlider.dispatchEvent(new Event('input'));
    }
  });
  
  // Sync volume sliders when fullscreen opens
  function syncVolumeSliders() {
    if (fsVolumeSlider && mainVolumeSlider) {
      fsVolumeSlider.value = mainVolumeSlider.value;
    }
  }
  
  // Also sync main to fullscreen
  mainVolumeSlider?.addEventListener('input', () => {
    if (fsVolumeSlider) {
      fsVolumeSlider.value = mainVolumeSlider.value;
    }
  });
  
  // Sync fullscreen stats
  setInterval(() => {
    const fs = document.getElementById('fullscreenMode');
    if (fs && !fs.classList.contains('hidden')) {
      const fsViewers = document.getElementById('fsViewers');
      const fsLikes = document.getElementById('fsLikes');
      const fsDuration = document.getElementById('fsDuration');
      const mainViewers = document.getElementById('viewerCount');
      const mainLikes = document.getElementById('likeCount');
      const mainDuration = document.getElementById('streamDuration');
      
      if (fsViewers && mainViewers) fsViewers.textContent = mainViewers.textContent;
      if (fsLikes && mainLikes) fsLikes.textContent = mainLikes.textContent;
      if (fsDuration && mainDuration) fsDuration.textContent = mainDuration.textContent;
      
      const mainChat = document.getElementById('chatMessages');
      const fsChat = document.getElementById('fsChatMessages');
      if (mainChat && fsChat) {
        fsChat.innerHTML = mainChat.innerHTML;
        fsChat.scrollTop = fsChat.scrollHeight;
      }
    }
  }, 1000);
  
  // Calendar and time picker state
  let calendarDate = new Date();
  let selectedDate = null;
  let selectedTime = null;
  let selectedDuration = 60; // Default 1 hour
  let bookingMode = 'schedule'; // 'schedule' or 'queue'
  
  // Get booked slots for conflict checking
  function getBookedSlotsForDate(dateStr) {
    const slots = window.bookedSlots || [];
    return slots.filter(slot => 
      slot.startTime.startsWith(dateStr) && 
      ['scheduled', 'live', 'in_lobby', 'queued'].includes(slot.status)
    );
  }
  
  // Check if a time slot conflicts with existing bookings
  function isTimeSlotAvailable(dateStr, timeStr, duration) {
    const slotStart = new Date(`${dateStr}T${timeStr}:00`);
    const slotEnd = new Date(slotStart.getTime() + duration * 60000);
    
    const daySlots = getBookedSlotsForDate(dateStr);
    
    for (const booked of daySlots) {
      const bookedStart = new Date(booked.startTime);
      const bookedEnd = new Date(booked.endTime);
      
      // Check for overlap: new slot starts before booked ends AND new slot ends after booked starts
      if (slotStart < bookedEnd && slotEnd > bookedStart) {
        return false;
      }
    }
    return true;
  }
  
  // Format end time from start time and duration
  function getEndTime(timeStr, duration) {
    const [hours, mins] = timeStr.split(':').map(Number);
    const totalMins = hours * 60 + mins + duration;
    const endHours = Math.floor(totalMins / 60) % 24;
    const endMins = totalMins % 60;
    return `${String(endHours).padStart(2, '0')}:${String(endMins).padStart(2, '0')}`;
  }
  
  function renderCalendar() {
    const year = calendarDate.getFullYear();
    const month = calendarDate.getMonth();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const maxDate = new Date();
    maxDate.setDate(maxDate.getDate() + 30); // Allow booking up to 1 month ahead
    
    document.getElementById('calMonthYear').textContent = 
      calendarDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
    
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDay = (firstDay.getDay() + 6) % 7; // Monday = 0
    
    const daysContainer = document.getElementById('calDays');
    daysContainer.innerHTML = '';
    
    // Previous month days
    const prevMonthLastDay = new Date(year, month, 0).getDate();
    for (let i = startDay - 1; i >= 0; i--) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cal-day other-month disabled';
      btn.textContent = prevMonthLastDay - i;
      daysContainer.appendChild(btn);
    }
    
    // Current month days
    for (let d = 1; d <= lastDay.getDate(); d++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cal-day';
      btn.textContent = d;
      
      const thisDate = new Date(year, month, d);
      thisDate.setHours(0, 0, 0, 0);
      
      if (thisDate < today || thisDate > maxDate) {
        btn.classList.add('disabled');
      } else {
        btn.addEventListener('click', () => selectDate(year, month, d));
      }
      
      if (thisDate.getTime() === today.getTime()) {
        btn.classList.add('today');
      }
      
      if (selectedDate && 
          thisDate.getFullYear() === selectedDate.getFullYear() &&
          thisDate.getMonth() === selectedDate.getMonth() &&
          thisDate.getDate() === selectedDate.getDate()) {
        btn.classList.add('selected');
        btn.style.background = '#dc2626';
        btn.style.color = '#fff';
        btn.style.fontWeight = '700';
        btn.style.boxShadow = '0 2px 8px rgba(220, 38, 38, 0.4)';
      }
      
      daysContainer.appendChild(btn);
    }
    
    // Next month days
    const totalCells = daysContainer.children.length;
    const remaining = 42 - totalCells;
    for (let d = 1; d <= remaining && totalCells + d <= 42; d++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cal-day other-month disabled';
      btn.textContent = d;
      daysContainer.appendChild(btn);
    }
  }
  
  function selectDate(year, month, day) {
    selectedDate = new Date(year, month, day);
    document.getElementById('bookingDate').value = 
      `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    
    renderCalendar();
    
    // Re-validate time selection with new date
    updateTimeFromDropdowns();
  }
  
  function updateTimeFromDropdowns() {
    const hour = document.getElementById('bookingHour')?.value;
    const minute = document.getElementById('bookingMinute')?.value;
    
    if (hour && minute) {
      const timeStr = `${hour}:${minute}`;
      selectedTime = timeStr;
      document.getElementById('bookingTime').value = timeStr;
      
      // Check availability and show info
      const now = new Date();
      const dateStr = selectedDate ? 
        `${selectedDate.getFullYear()}-${String(selectedDate.getMonth() + 1).padStart(2, '0')}-${String(selectedDate.getDate()).padStart(2, '0')}` : 
        now.toISOString().split('T')[0];
      
      const isToday = dateStr === now.toISOString().split('T')[0];
      const isPast = isToday && (parseInt(hour) < now.getHours() || (parseInt(hour) === now.getHours() && parseInt(minute) <= now.getMinutes()));
      const isUnavailable = !isTimeSlotAvailable(dateStr, timeStr, selectedDuration);
      
      const infoEl = document.getElementById('selectedTimeInfo');
      if (infoEl && selectedDate) {
        if (isPast) {
          infoEl.textContent = '‚ö† This time has already passed';
          infoEl.className = 'selected-time-info error';
          infoEl.classList.remove('hidden');
        } else if (isUnavailable) {
          infoEl.textContent = '‚ö† This slot conflicts with another booking';
          infoEl.className = 'selected-time-info error';
          infoEl.classList.remove('hidden');
        } else {
          const endTime = getEndTime(timeStr, selectedDuration);
          const dateFormatted = selectedDate.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
          infoEl.textContent = `‚úì ${dateFormatted}: ${timeStr} - ${endTime}`;
          infoEl.className = 'selected-time-info';
          infoEl.classList.remove('hidden');
        }
      }
    } else {
      selectedTime = null;
      document.getElementById('bookingTime').value = '';
      document.getElementById('selectedTimeInfo')?.classList.add('hidden');
    }
  }
  
  function renderTimePicker() {
    // Reset dropdowns when date changes
    const hourSelect = document.getElementById('bookingHour');
    const minuteSelect = document.getElementById('bookingMinute');
    
    if (hourSelect && minuteSelect) {
      // Keep current selection but re-validate
      updateTimeFromDropdowns();
    }
  }
  
  // Time dropdown change handlers
  document.getElementById('bookingHour')?.addEventListener('change', updateTimeFromDropdowns);
  document.getElementById('bookingMinute')?.addEventListener('change', updateTimeFromDropdowns);
  
  // Duration change - reset time selection
  document.querySelectorAll('input[name="duration"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      selectedDuration = parseInt(e.target.value);
      // Re-validate current selection with new duration
      updateTimeFromDropdowns();
    });
  });
  
  // Calendar navigation
  document.getElementById('calPrevMonth')?.addEventListener('click', () => {
    calendarDate.setMonth(calendarDate.getMonth() - 1);
    renderCalendar();
  });
  
  document.getElementById('calNextMonth')?.addEventListener('click', () => {
    calendarDate.setMonth(calendarDate.getMonth() + 1);
    renderCalendar();
  });
  
  // Booking type toggle
  document.getElementById('bookingTypeSchedule')?.addEventListener('click', () => {
    bookingMode = 'schedule';
    document.getElementById('bookingTypeSchedule').classList.add('active');
    document.getElementById('bookingTypeQueue').classList.remove('active');
    document.getElementById('scheduledTimeSection').classList.remove('hidden');
    document.getElementById('queueSection').classList.add('hidden');
  });
  
  document.getElementById('bookingTypeQueue')?.addEventListener('click', () => {
    bookingMode = 'queue';
    document.getElementById('bookingTypeQueue').classList.add('active');
    document.getElementById('bookingTypeSchedule').classList.remove('active');
    document.getElementById('scheduledTimeSection').classList.add('hidden');
    document.getElementById('queueSection').classList.remove('hidden');
  });
  
  // Booking modal - check login first
  document.getElementById('bookSlotBtn')?.addEventListener('click', () => {
    console.log('[Live] Book Slot button clicked');

    // Check if user is logged in by looking for auth state
    const checkAuth = async () => {
      console.log('[Live] Checking auth state...');

      // Wait for auth to be ready
      let user = null;
      try {
        if (window.authReady) {
          console.log('[Live] Using window.authReady');
          user = await window.authReady;
        } else {
          console.log('[Live] Importing Firebase Auth...');
          const { getAuth } = await import('https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js');
          const auth = getAuth();
          user = auth.currentUser;
        }
      } catch (err) {
        console.error('[Live] Auth check error:', err);
      }

      console.log('[Live] User:', user ? { uid: user.uid, displayName: user.displayName, email: user.email } : null);

      if (!user) {
        // Not logged in - redirect to login
        console.log('[Live] No user, redirecting to login');
        window.location.href = '/login?redirect=/live';
        return;
      }

      // Logged in - open booking schedule modal
      const displayName = user.displayName || user.email?.split('@')[0] || 'DJ';
      console.log('[Live] Opening booking schedule with:', { uid: user.uid, displayName });
      window.openBookingSchedule(user.uid, displayName);
    };

    checkAuth();
  });
  
  // View Full Schedule - open public schedule modal (read-only)
  document.getElementById('viewScheduleBtn')?.addEventListener('click', () => {
    window.openPublicSchedule();
  });
  
  document.getElementById('closeBookingModal')?.addEventListener('click', () => {
    document.getElementById('bookingModal')?.classList.add('hidden');
  });
  
  // Close modals on overlay click
  document.querySelectorAll('.modal-overlay').forEach(overlay => {
    overlay.addEventListener('click', () => {
      document.getElementById('bookingModal')?.classList.add('hidden');
      document.getElementById('goLiveNowModal')?.classList.add('hidden');
      document.getElementById('shareModal')?.classList.add('hidden');
    });
  });
  
  // Go Live Now button handler - redirects to lobby page for preparation
  document.getElementById('goLiveNowBtn')?.addEventListener('click', () => {
    const checkAuth = async () => {
      // Wait for auth to be ready
      let user = null;
      if (window.authReady) {
        user = await window.authReady;
      } else {
        const { getAuth } = await import('https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js');
        const auth = getAuth();
        user = auth.currentUser;
      }
      
      if (!user) {
        window.location.href = '/login?redirect=/account/go-live';
        return;
      }
      
      // Redirect to the go-live lobby page where DJ can prepare
      window.location.href = '/account/go-live';
    };
    
    checkAuth();
  });
  
  document.getElementById('closeGoLiveNowModal')?.addEventListener('click', () => {
    document.getElementById('goLiveNowModal')?.classList.add('hidden');
  });
  
  // Copy Go Live Now stream key
  document.getElementById('copyGoLiveNowKey')?.addEventListener('click', () => {
    const key = document.getElementById('goLiveNowStreamKey')?.textContent;
    if (key && key !== '-') {
      navigator.clipboard.writeText(key);
      document.getElementById('copyGoLiveNowKey').textContent = 'Copied!';
      setTimeout(() => {
        document.getElementById('copyGoLiveNowKey').textContent = 'Copy';
      }, 2000);
    }
  });
  
  // Character counters for description fields
  document.getElementById('bookingDescription')?.addEventListener('input', (e) => {
    const count = e.target.value.length;
    document.getElementById('bookingDescCount').textContent = count;
  });
  
  document.getElementById('goLiveNowDescription')?.addEventListener('input', (e) => {
    const count = e.target.value.length;
    document.getElementById('goLiveNowDescCount').textContent = count;
  });
  
  // Share functionality
  let currentLiveInfo = null;
  
  function updateSharePreview(djName, djAvatar, crew) {
    currentLiveInfo = { djName, djAvatar, crew };
    document.getElementById('sharePreviewName').textContent = djName || 'Live Now';
    document.getElementById('sharePreviewAvatar').src = djAvatar || '/place-holder.webp';
    document.getElementById('sharePreviewCrew').textContent = crew || 'Fresh Wax Live Stream';
  }
  
  function getShareUrl() {
    return window.location.origin + '/live';
  }
  
  function getShareText() {
    if (currentLiveInfo) {
      return `${currentLiveInfo.djName} is LIVE NOW on Fresh Wax!`;
    }
    return 'Fresh Wax Live Stream';
  }
  
  // Open share modal
  document.getElementById('shareBtn')?.addEventListener('click', () => {
    const modal = document.getElementById('shareModal');
    if (modal) {
      modal.classList.remove('hidden');
      document.getElementById('shareLinkInput').value = getShareUrl();
      
      // Show native share button if supported
      if (navigator.share) {
        document.getElementById('nativeShare')?.classList.remove('hidden');
      }
    }
  });
  
  // Close share modal
  document.getElementById('closeShareModal')?.addEventListener('click', () => {
    document.getElementById('shareModal')?.classList.add('hidden');
  });
  
  // Copy share link
  document.getElementById('copyShareLink')?.addEventListener('click', () => {
    const input = document.getElementById('shareLinkInput');
    const btn = document.getElementById('copyShareLink');
    if (input && btn) {
      navigator.clipboard.writeText(input.value);
      btn.textContent = 'Copied!';
      setTimeout(() => { btn.textContent = 'Copy'; }, 2000);
    }
  });
  
  // Twitter/X share
  document.getElementById('shareTwitter')?.addEventListener('click', () => {
    const text = encodeURIComponent(getShareText());
    const url = encodeURIComponent(getShareUrl());
    window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank', 'width=550,height=420');
  });
  
  // Facebook share
  document.getElementById('shareFacebook')?.addEventListener('click', () => {
    const url = encodeURIComponent(getShareUrl());
    window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank', 'width=550,height=420');
  });
  
  // WhatsApp share
  document.getElementById('shareWhatsApp')?.addEventListener('click', () => {
    const text = encodeURIComponent(getShareText() + ' ' + getShareUrl());
    window.open(`https://wa.me/?text=${text}`, '_blank');
  });
  
  // Telegram share
  document.getElementById('shareTelegram')?.addEventListener('click', () => {
    const text = encodeURIComponent(getShareText());
    const url = encodeURIComponent(getShareUrl());
    window.open(`https://t.me/share/url?url=${url}&text=${text}`, '_blank');
  });
  
  // Native share (mobile)
  document.getElementById('nativeShare')?.addEventListener('click', async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: 'Fresh Wax Live Stream',
          text: getShareText(),
          url: getShareUrl()
        });
      } catch (e) {
        console.log('Share cancelled');
      }
    }
  });
  
  // Make updateSharePreview available globally
  window.updateSharePreview = updateSharePreview;
  
  // ============================================
  // SHOUTOUT FUNCTIONALITY
  // ============================================
  
  const shoutoutBtn = document.getElementById('shoutoutBtn');
  const shoutoutModal = document.getElementById('shoutoutModal');
  const closeShoutoutModal = document.getElementById('closeShoutoutModal');
  const shoutoutInput = document.getElementById('shoutoutInput');
  const shoutoutCharCount = document.getElementById('shoutoutCharCount');
  const sendShoutoutBtn = document.getElementById('sendShoutoutBtn');
  const shoutoutTrack = document.getElementById('shoutoutTrack');
  
  let shoutoutQueue = [];
  let isShoutoutPlaying = false;
  
  // Open shoutout modal function
  function openShoutoutModal() {
    const isLoggedIn = window.currentUserInfo?.loggedIn || false;
    if (!isLoggedIn) {
      alert('Please sign in to send a shoutout');
      return;
    }
    shoutoutModal?.classList.remove('hidden');
    shoutoutInput?.focus();
  }
  
  // Open shoutout modal
  shoutoutBtn?.addEventListener('click', openShoutoutModal);
  
  // Close shoutout modal
  closeShoutoutModal?.addEventListener('click', () => {
    shoutoutModal?.classList.add('hidden');
    if (shoutoutInput) shoutoutInput.value = '';
    if (shoutoutCharCount) shoutoutCharCount.textContent = '0';
    if (sendShoutoutBtn) sendShoutoutBtn.disabled = true;
  });
  
  // Close on overlay click
  shoutoutModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
    shoutoutModal?.classList.add('hidden');
    if (shoutoutInput) shoutoutInput.value = '';
    if (shoutoutCharCount) shoutoutCharCount.textContent = '0';
    if (sendShoutoutBtn) sendShoutoutBtn.disabled = true;
  });
  
  // Character count and enable/disable send button
  shoutoutInput?.addEventListener('input', () => {
    const len = shoutoutInput.value.length;
    if (shoutoutCharCount) shoutoutCharCount.textContent = len;
    if (sendShoutoutBtn) sendShoutoutBtn.disabled = len === 0;
  });
  
  // Emoji buttons
  document.querySelectorAll('.shoutout-emoji').forEach(btn => {
    btn.addEventListener('click', () => {
      if (shoutoutInput && shoutoutInput.value.length < 30) {
        const emoji = btn.dataset.emoji;
        const remaining = 30 - shoutoutInput.value.length;
        if (emoji.length <= remaining) {
          shoutoutInput.value += emoji;
          shoutoutInput.dispatchEvent(new Event('input'));
          shoutoutInput.focus();
        }
      }
    });
  });
  
  // Send shoutout
  sendShoutoutBtn?.addEventListener('click', async () => {
    const message = shoutoutInput?.value.trim();
    if (!message) return;
    
    // Use displayName for shoutouts (matches fullpage behavior)
    const userName = window.currentUserInfo?.displayName || window.currentUserInfo?.name || 'Anonymous';
    const userId = window.currentUserInfo?.id || null;
    
    // Disable button while sending
    sendShoutoutBtn.disabled = true;
    sendShoutoutBtn.innerHTML = '<span>Sending...</span>';
    
    try {
      // Get current stream ID from the page
      const streamId = window.currentStreamId || 'default';
      
      // Send via API to broadcast to all viewers
      const response = await fetch('/api/livestream/react', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'shoutout',
          streamId: streamId,
          userId: userId,
          userName: userName,
          message: message
        })
      });
      
      if (response.ok) {
        // Also play locally immediately
        shoutoutQueue.push({ name: userName, message: message });
        playNextShoutout();
      }
    } catch (e) {
      console.error('Shoutout error:', e);
    }
    
    // Close modal and reset
    shoutoutModal?.classList.add('hidden');
    if (shoutoutInput) shoutoutInput.value = '';
    if (shoutoutCharCount) shoutoutCharCount.textContent = '0';
    sendShoutoutBtn.disabled = true;
    sendShoutoutBtn.innerHTML = '<span>Send Shoutout</span><svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>';
  });
  
  // Play shoutout animation
  function playNextShoutout() {
    if (isShoutoutPlaying || shoutoutQueue.length === 0) return;
    
    isShoutoutPlaying = true;
    const shoutout = shoutoutQueue.shift();
    
    if (shoutoutTrack) {
      shoutoutTrack.innerHTML = `<span class="shoutout-message"><span class="shoutout-name">${shoutout.name}:</span> ${shoutout.message}</span>`;
      shoutoutTrack.classList.remove('scrolling');
      
      // Trigger reflow to restart animation
      void shoutoutTrack.offsetWidth;
      shoutoutTrack.classList.add('scrolling');
      
      // After animation ends, check for more shoutouts
      setTimeout(() => {
        isShoutoutPlaying = false;
        if (shoutoutQueue.length > 0) {
          playNextShoutout();
        } else {
          // Reset to placeholder
          shoutoutTrack.classList.remove('scrolling');
          shoutoutTrack.innerHTML = '<span class="shoutout-placeholder">üéâ Send a shoutout to appear here!</span>';
        }
      }, 30000); // Match animation duration
    }
  }
  
  // Listen for incoming shoutouts from Pusher
  window.handleIncomingShoutout = function(data) {
    shoutoutQueue.push({ name: data.name, message: data.message });
    playNextShoutout();
  };
  
  // Store user info globally for shoutout access
  window.currentUserInfo = { loggedIn: false, name: 'Anonymous', displayName: 'Anonymous', id: null };
</script>

<script type="module">
  import { initializeApp, getApps, getApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
  import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
  import { getFirestore, doc, setDoc, deleteDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';

  const firebaseConfig = {
    apiKey: "AIzaSyBiZGsWdvA9ESm3OsUpZ-VQpwqMjMpBY6g",
    authDomain: "freshwax-store.firebaseapp.com",
    projectId: "freshwax-store",
    storageBucket: "freshwax-store.firebasestorage.app",
    messagingSenderId: "675435782973",
    appId: "1:675435782973:web:e8459c2ec4a5f6d683db54"
  };

  // Prevent duplicate app initialization
  const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const firestoreDb = getFirestore(app);
  
  let currentUser = null;
  let isLoggedIn = false;
  let userInfo = null;
  let currentWeekStart = getWeekStart(new Date());
  let allSlots = [];
  let myUpcomingSlot = null;
  let scheduleCache = null;
  let scheduleCacheTime = 0;
  const CACHE_DURATION = 900000; // 15 minute cache to reduce Firebase reads
  
  // Chat clear timer - clears chat 20 minutes after stream ends
  let wasLive = false;
  let chatClearTimer = null;
  const CHAT_CLEAR_DELAY = 20 * 60 * 1000; // 20 minutes in milliseconds
  
  function clearChatMessages() {
    const chatMessages = document.getElementById('chatMessages');
    const fsChatMessages = document.getElementById('fsChatMessages');
    if (chatMessages) {
      chatMessages.innerHTML = '<div class="chat-system-message">Chat cleared</div>';
    }
    if (fsChatMessages) {
      fsChatMessages.innerHTML = '<div class="chat-system-message">Chat cleared</div>';
    }
    console.log('[Chat] Cleared chat messages 20 minutes after stream ended');
  }
  
  function scheduleChatClear() {
    // Cancel any existing timer
    if (chatClearTimer) {
      clearTimeout(chatClearTimer);
      chatClearTimer = null;
    }
    // Schedule chat clear in 20 minutes
    chatClearTimer = setTimeout(clearChatMessages, CHAT_CLEAR_DELAY);
    console.log('[Chat] Chat will be cleared in 20 minutes');
  }
  
  function cancelChatClear() {
    if (chatClearTimer) {
      clearTimeout(chatClearTimer);
      chatClearTimer = null;
      console.log('[Chat] Chat clear cancelled - new stream started');
    }
  }
  
  function getWeekStart(date) {
    const d = new Date(date);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    d.setDate(diff);
    d.setHours(0, 0, 0, 0);
    return d;
  }
  
  function formatTime(dateStr) {
    const d = new Date(dateStr);
    return d.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
  }
  
  function formatDate(dateStr) {
    const d = new Date(dateStr);
    return d.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
  }
  
  // Auth state - SINGLE CHECK, no repeated calls
  onAuthStateChanged(auth, async (user) => {
    currentUser = user;
    if (user) {
      await checkUserStatus(user.uid);
    }
    loadSchedule();
  });
  
  async function checkUserStatus(userId) {
    try {
      const response = await fetch(`/api/get-user-type?uid=${userId}`);
      const result = await response.json();
      
      if (result.success) {
        isLoggedIn = true;
        // Use Firebase Auth displayName first (same as Header.astro)
        const displayName = currentUser?.displayName || result.partnerDisplayName || result.name || 'User';
        userInfo = {
          id: userId,
          name: displayName,
          avatar: result.avatarUrl || currentUser?.photoURL || null,
          isDj: result.roles?.dj === true || result.roles?.artist === true,
          isAdmin: result.isAdmin || false,
          isApproved: result.isApproved || false,
          isPro: result.isPro || result.isAdmin || false
        };

        // Store Pro status globally for live-stream.js to access
        window.userIsPro = userInfo.isPro;
        
        // Update global user info for shoutouts
        window.currentUserInfo = {
          loggedIn: true,
          name: displayName,
          displayName: displayName,
          id: userId
        };
        
        const djNameField = document.getElementById('bookingDjName');
        if (djNameField) {
          djNameField.value = displayName;
        }
        
        // Show chat form
        document.getElementById('loginPrompt')?.classList.add('hidden');
        document.getElementById('chatForm')?.classList.remove('hidden');
        
        // Show DJ-only elements for approved DJs and admins
        if ((userInfo.isDj && userInfo.isApproved) || userInfo.isAdmin) {
          document.getElementById('djLobbyBtn')?.classList.remove('hidden');
          document.getElementById('takeoverSection')?.classList.remove('hidden');
          
          // Subscribe to incoming takeover requests
          subscribeToIncomingTakeover();
          setupTakeoverActions();
        }
      }
    } catch (e) {
      console.log('Could not check user status:', e);
    }
  }
  
  // Subscribe to incoming takeover requests (for streaming DJs) - Using Pusher
  async function subscribeToIncomingTakeover() {
    if (!currentUser || !userInfo?.isDj) return;
    
    // Wait for Pusher to be available (loaded by live-stream.js)
    const waitForPusher = () => new Promise((resolve) => {
      if (window.Pusher) return resolve();
      const check = setInterval(() => {
        if (window.Pusher) {
          clearInterval(check);
          resolve();
        }
      }, 100);
      // Timeout after 5 seconds
      setTimeout(() => { clearInterval(check); resolve(); }, 5000);
    });
    
    await waitForPusher();
    
    if (!window.Pusher) {
      console.warn('[Takeover] Pusher not available, falling back to polling');
      // Fallback: poll API every 10 seconds
      setInterval(async () => {
        try {
          const response = await fetch(`/api/dj-lobby/takeover?userId=${currentUser.uid}`);
          const result = await response.json();
          if (result.success && result.incoming?.status === 'pending') {
            showTakeoverNotification(result.incoming);
          } else {
            hideTakeoverNotification();
          }
        } catch (e) { console.warn('[Takeover] Poll error:', e); }
      }, 10000);
      return;
    }
    
    // Subscribe to private channel for takeover notifications
    const PUSHER_KEY = window.PUSHER_CONFIG?.key || '';
    const PUSHER_CLUSTER = window.PUSHER_CONFIG?.cluster || 'eu';
    
    const pusher = new window.Pusher(PUSHER_KEY, {
      cluster: PUSHER_CLUSTER,
      authEndpoint: '/api/dj-lobby/pusher-auth',
      auth: { params: { user_id: currentUser.uid } }
    });
    
    const privateChannel = pusher.subscribe(`private-dj-${currentUser.uid}`);
    
    privateChannel.bind('takeover-request', (data) => {
      console.log('[Takeover] Received request via Pusher:', data);
      showTakeoverNotification(data);
    });
    
    privateChannel.bind('takeover-cancelled', () => {
      hideTakeoverNotification();
    });
    
    console.log('[Takeover] Subscribed to Pusher channel');
  }
  
  function showTakeoverNotification(data) {
    const notification = document.getElementById('incomingTakeoverNotification');
    document.getElementById('incomingTakeoverName').textContent = data.requesterName || 'A DJ';
    document.getElementById('incomingTakeoverAvatar').src = data.requesterAvatar || '/place-holder.webp';
    notification.classList.remove('hidden');
    notification.dataset.requesterId = data.requesterId;
  }
  
  function hideTakeoverNotification() {
    document.getElementById('incomingTakeoverNotification').classList.add('hidden');
  }
  
  // Setup takeover action buttons
  function setupTakeoverActions() {
    document.getElementById('acceptIncomingTakeoverBtn')?.addEventListener('click', async () => {
      const notification = document.getElementById('incomingTakeoverNotification');
      const requesterId = notification.dataset.requesterId;
      
      if (!requesterId || !currentUser) return;
      
      try {
        const token = await currentUser.getIdToken();
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ action: 'getStreamKey', djId: currentUser.uid })
        });
        
        const result = await response.json();
        
        // Send stream key to requester
        await setDoc(doc(firestoreDb, 'djTakeoverRequests', `request_${requesterId}`), {
          status: 'approved',
          requesterId: requesterId,
          serverUrl: result.serverUrl || 'rtmp://rtmp.freshwax.co.uk/live',
          streamKey: result.streamKey || 'Contact admin for key',
          approvedAt: serverTimestamp()
        }, { merge: true });
        
        // Clear the request from my document
        await deleteDoc(doc(firestoreDb, 'djTakeoverRequests', currentUser.uid));
        
        notification.classList.add('hidden');
        alert('Takeover approved! Stream key has been shared.');
      } catch (e) {
        console.error('Accept takeover error:', e);
        alert('Failed to accept takeover');
      }
    });
    
    document.getElementById('declineIncomingTakeoverBtn')?.addEventListener('click', async () => {
      const notification = document.getElementById('incomingTakeoverNotification');
      const requesterId = notification.dataset.requesterId;
      
      if (!requesterId) return;
      
      try {
        // Update requester's document to show declined
        await setDoc(doc(firestoreDb, 'djTakeoverRequests', `request_${requesterId}`), {
          status: 'declined',
          declinedAt: serverTimestamp()
        }, { merge: true });
        
        // Remove from my document
        await deleteDoc(doc(firestoreDb, 'djTakeoverRequests', currentUser.uid));
        
        notification.classList.add('hidden');
      } catch (e) {
        console.error('Decline takeover error:', e);
      }
    });
  }
  
  // OPTIMIZED: Load schedule with caching to reduce API calls
  async function loadSchedule(forceRefresh = false) {
    const now = Date.now();
    
    // Use cache if valid (unless force refresh requested)
    if (!forceRefresh && scheduleCache && (now - scheduleCacheTime) < CACHE_DURATION) {
      allSlots = scheduleCache.slots;
      window.bookedSlots = allSlots; // Expose to regular script for booking form
      renderCalendar();
      renderTodaySchedule();
      updateLiveQueueBar(scheduleCache.currentLive, scheduleCache.upcoming);
      updateListenersList(scheduleCache.listeners || []);
      return;
    }
    
    try {
      const weekEnd = new Date(currentWeekStart);
      weekEnd.setDate(weekEnd.getDate() + 7);
      
      // Add cache buster for force refresh to bypass browser/CDN cache
      const cacheBuster = forceRefresh ? `&_t=${Date.now()}` : '';
      
      // Single API call that returns both schedule and live status
      const response = await fetch(`/api/livestream/slots?start=${currentWeekStart.toISOString()}&end=${weekEnd.toISOString()}${cacheBuster}`);
      const result = await response.json();
      
      if (result.success) {
        allSlots = result.slots || [];
        window.bookedSlots = allSlots; // Expose to regular script for booking form
        
        // Cache the result
        scheduleCache = {
          slots: allSlots,
          currentLive: result.currentLive || null,
          upcoming: result.upcoming || [],
          listeners: result.listeners || []
        };
        scheduleCacheTime = Date.now();
        
        renderCalendar();
        renderTodaySchedule();
        updateLiveQueueBar(result.currentLive, result.upcoming);
        updateListenersList(result.listeners || []);
        
        if (isLoggedIn) {
          checkMyUpcomingSlot();
        }
        
        console.log('[Schedule] Loaded', allSlots.length, 'slots, upcoming:', result.upcoming?.length || 0);
      }
    } catch (e) {
      console.error('Failed to load schedule:', e);
    }
  }
  
  // Update listeners display
  function updateListenersList(listeners) {
    const listenersList = document.getElementById('listenersList');
    const listenerCountBadge = document.getElementById('listenerCountBadge');
    
    if (listenerCountBadge) {
      listenerCountBadge.textContent = listeners.length;
      // Grey out badge if zero
      if (listeners.length === 0) {
        listenerCountBadge.style.background = '#9ca3af';
      } else {
        listenerCountBadge.style.background = '#dc2626';
      }
    }
    
    if (listenersList) {
      if (listeners.length > 0) {
        listenersList.innerHTML = listeners.map(listener => `
          <div class="listener-item">
            <img class="listener-avatar" src="${listener.avatar || '/place-holder.webp'}" alt="" onerror="this.src='/place-holder.webp'" />
            <span class="listener-name">${listener.name}</span>
          </div>
        `).join('');
      } else {
        listenersList.innerHTML = '<span class="empty-message">No one listening yet</span>';
      }
    }
  }
  
  // Send heartbeat to register as listener (logged in users only)
  let heartbeatInterval = null;
  
  async function sendListenerHeartbeat() {
    if (!currentUser || !userInfo) return;
    
    try {
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'heartbeat',
          odamiMa: currentUser.uid,
          name: userInfo.displayName || userInfo.firstName || 'Listener',
          avatar: userInfo.avatar || null
        })
      });
      
      const result = await response.json();
      if (result.success && result.listeners) {
        updateListenersList(result.listeners);
      }
    } catch (e) {
      console.error('Heartbeat failed:', e);
    }
  }
  
  // Start heartbeat when user is logged in
  function startListenerHeartbeat() {
    if (heartbeatInterval) clearInterval(heartbeatInterval);
    
    // Send immediately
    sendListenerHeartbeat();
    
    // Then every 60 seconds
    heartbeatInterval = setInterval(sendListenerHeartbeat, 60000);
  }
  
  // Stop heartbeat and notify leave
  function stopListenerHeartbeat() {
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
      heartbeatInterval = null;
    }
    
    if (currentUser) {
      navigator.sendBeacon('/api/livestream/slots', JSON.stringify({
        action: 'leave',
        odamiMa: currentUser.uid
      }));
    }
  }
  
  // Start heartbeat if logged in
  if (isLoggedIn) {
    startListenerHeartbeat();
  }
  
  // Clean up on page unload
  window.addEventListener('beforeunload', stopListenerHeartbeat);
  
  function checkMyUpcomingSlot() {
    if (!currentUser || !allSlots.length) return;
    
    const now = new Date();
    const mySlots = allSlots.filter(s => 
      s.djId === currentUser.uid && 
      new Date(s.startTime) > now &&
      ['scheduled', 'in_lobby', 'queued'].includes(s.status)
    );
    
    if (mySlots.length > 0) {
      myUpcomingSlot = mySlots[0];
      const startTime = new Date(myUpcomingSlot.startTime);
      const minsUntil = Math.floor((startTime - now) / 60000);
      
      // Show lobby panel if within 30 mins
      if (minsUntil <= 30 && myUpcomingSlot.status !== 'in_lobby') {
        showLobbyPanel(myUpcomingSlot);
      }
    }
  }
  
  function showLobbyPanel(slot) {
    const panel = document.getElementById('lobbyPanel');
    if (!panel) return;
    
    // Reset lobby state when entering
    resetLobbyState();
    
    panel.classList.remove('hidden');
    document.getElementById('lobbySlotTime').textContent = `${formatTime(slot.startTime)} - ${formatTime(slot.endTime)}`;
    document.getElementById('lobbyStreamKey').textContent = slot.streamKey || 'Loading...';
    
    updateLobbyCountdown(slot);
    
    // Check if someone is currently live and show takeover option
    checkForTakeoverOption(slot);
  }
  
  // Check if there's a live stream that can be taken over
  async function checkForTakeoverOption(mySlot) {
    const takeoverSection = document.getElementById('takeoverSection');
    if (!takeoverSection) return;
    
    // Only show takeover option for approved DJs
    if (!(userInfo?.isDj && userInfo?.isApproved) && !userInfo?.isAdmin) {
      takeoverSection.classList.add('hidden');
      return;
    }
    
    try {
      const response = await fetch('/api/livestream/slots');
      const result = await response.json();
      
      if (!result.success) return;
      
      // Find currently live slot
      const now = Date.now();
      const liveSlot = result.slots?.find(s => 
        s.status === 'live' && 
        new Date(s.endTime).getTime() > now &&
        s.djId !== currentUser?.uid // Not my own slot
      );
      
      if (liveSlot) {
        // Show takeover section
        takeoverSection.classList.remove('hidden');
        document.getElementById('takeoverDjName').textContent = liveSlot.djName;
        document.getElementById('takeoverDjAvatar').src = liveSlot.djAvatar || '/place-holder.webp';
        
        // Store live slot ID for takeover request
        takeoverSection.dataset.slotId = liveSlot.id;
        
        // Check if we already have a pending request
        if (liveSlot.takeoverRequest?.requesterId === currentUser?.uid && 
            liveSlot.takeoverRequest?.status === 'pending') {
          showTakeoverPending();
        }
      } else {
        takeoverSection.classList.add('hidden');
      }
    } catch (error) {
      console.error('Error checking for takeover option:', error);
    }
  }
  
  let takeoverPollInterval = null;
  
  function showTakeoverPending() {
    document.getElementById('requestTakeoverBtn')?.classList.add('hidden');
    document.getElementById('takeoverPending')?.classList.remove('hidden');
    document.getElementById('takeoverApproved')?.classList.add('hidden');
    
    // Start polling for approval
    startTakeoverPolling();
  }
  
  function hideTakeoverPending() {
    document.getElementById('requestTakeoverBtn')?.classList.remove('hidden');
    document.getElementById('takeoverPending')?.classList.add('hidden');
    document.getElementById('takeoverApproved')?.classList.add('hidden');
    
    // Stop polling
    stopTakeoverPolling();
  }
  
  function showTakeoverApproved(streamKey) {
    document.getElementById('requestTakeoverBtn')?.classList.add('hidden');
    document.getElementById('takeoverPending')?.classList.add('hidden');
    document.getElementById('takeoverApproved')?.classList.remove('hidden');
    document.getElementById('takeoverStreamKey').textContent = streamKey;
    
    // Stop polling
    stopTakeoverPolling();
  }
  
  function startTakeoverPolling() {
    if (takeoverPollInterval) return;
    
    takeoverPollInterval = setInterval(async () => {
      const takeoverSection = document.getElementById('takeoverSection');
      const slotId = takeoverSection?.dataset.slotId;
      
      if (!slotId || !currentUser) {
        stopTakeoverPolling();
        return;
      }
      
      try {
        // Check if takeover was approved
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'getStreamKey',
            slotId,
            djId: currentUser.uid
          })
        });
        
        const result = await response.json();
        
        if (result.success && result.streamKey) {
          // Takeover was approved! Show the key
          showTakeoverApproved(result.streamKey);
        }
      } catch (error) {
        console.error('Error polling takeover status:', error);
      }
    }, 3000); // Poll every 3 seconds
  }
  
  function stopTakeoverPolling() {
    if (takeoverPollInterval) {
      clearInterval(takeoverPollInterval);
      takeoverPollInterval = null;
    }
  }
  
  // Copy takeover key
  window.copyTakeoverKey = function() {
    const key = document.getElementById('takeoverStreamKey')?.textContent;
    if (key && key !== '-') {
      navigator.clipboard.writeText(key);
      showCopyFeedback('Stream key copied!');
    }
  };
  
  // Copy functions for lobby
  window.copyLobbyStreamKey = function() {
    const key = document.getElementById('lobbyStreamKey')?.textContent;
    if (key && key !== '-' && key !== 'Loading...') {
      navigator.clipboard.writeText(key);
      showCopyFeedback('Stream key copied!');
    }
  };
  
  window.copyRtmpUrl = function() {
    navigator.clipboard.writeText('rtmp://rtmp.freshwax.co.uk/live');
    showCopyFeedback('RTMP URL copied!');
  };
  
  function showCopyFeedback(msg) {
    const statusMsg = document.getElementById('lobbyStatusMsg');
    if (statusMsg) {
      statusMsg.textContent = msg;
      statusMsg.style.background = '#10b981';
      statusMsg.style.color = '#fff';
      statusMsg.classList.remove('hidden');
      setTimeout(() => statusMsg.classList.add('hidden'), 2000);
    }
  }
  
  // Request takeover button handler
  document.getElementById('requestTakeoverBtn')?.addEventListener('click', async () => {
    const takeoverSection = document.getElementById('takeoverSection');
    const slotId = takeoverSection?.dataset.slotId;
    
    if (!slotId || !currentUser) {
      alert('Please log in to request a takeover');
      return;
    }
    
    const btn = document.getElementById('requestTakeoverBtn');
    btn.disabled = true;
    btn.innerHTML = '<span>‚è≥ Sending request...</span>';
    
    try {
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'requestTakeover',
          slotId,
          requesterId: currentUser.uid,
          requesterName: userInfo?.name || userInfo?.displayName || 'DJ',
          requesterAvatar: userInfo?.avatarUrl || null
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        showTakeoverPending();
      } else {
        alert(result.error || 'Failed to send takeover request');
        btn.disabled = false;
        btn.innerHTML = '<span>üéß Request Takeover</span>';
      }
    } catch (error) {
      console.error('Error requesting takeover:', error);
      alert('Failed to send takeover request');
      btn.disabled = false;
      btn.innerHTML = '<span>üéß Request Takeover</span>';
    }
  });
  
  // Cancel takeover request button handler
  document.getElementById('cancelTakeoverBtn')?.addEventListener('click', async () => {
    const takeoverSection = document.getElementById('takeoverSection');
    const slotId = takeoverSection?.dataset.slotId;
    
    if (!slotId || !currentUser) return;
    
    // Stop polling immediately
    stopTakeoverPolling();
    
    try {
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancelTakeoverRequest',
          slotId,
          requesterId: currentUser.uid
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        hideTakeoverPending();
      } else {
        alert(result.error || 'Failed to cancel request');
        // Restart polling if cancel failed
        startTakeoverPolling();
      }
    } catch (error) {
      console.error('Error cancelling takeover:', error);
      startTakeoverPolling();
    }
  });
  
  // DJ Ready state
  let isDjReady = false;
  let slotExpired = false;
  const GRACE_PERIOD_SECONDS = 180; // 3 minutes
  
  function updateLobbyCountdown(slot) {
    const countdown = document.getElementById('lobbyCountdownBig');
    const countdownLabel = document.getElementById('lobbyCountdownLabel');
    const goLiveBtn = document.getElementById('goLiveBtn');
    const readyBtn = document.getElementById('readyBtn');
    const gracePeriod = document.getElementById('lobbyGracePeriod');
    const graceCountdown = document.getElementById('graceCountdown');
    const slotAvailable = document.getElementById('slotAvailableSection');
    
    const update = () => {
      const now = new Date();
      const start = new Date(slot.startTime);
      const secsUntilStart = Math.floor((start - now) / 1000);
      
      // Before start time
      if (secsUntilStart > 0) {
        gracePeriod?.classList.add('hidden');
        slotAvailable?.classList.add('hidden');
        
        const mins = Math.floor(secsUntilStart / 60);
        const s = secsUntilStart % 60;
        countdown.textContent = `${mins}:${s.toString().padStart(2, '0')}`;
        if (countdownLabel) countdownLabel.textContent = 'Time until live:';
        
        // Enable go live 2 mins before if ready
        if (isDjReady && secsUntilStart <= 120) {
          goLiveBtn.disabled = false;
        } else {
          goLiveBtn.disabled = true;
        }
        
        setTimeout(update, 1000);
        return;
      }
      
      // After start time - check grace period
      const secsLate = Math.abs(secsUntilStart);
      const graceRemaining = GRACE_PERIOD_SECONDS - secsLate;
      
      if (graceRemaining > 0 && !isDjReady && !slotExpired) {
        // In grace period - DJ is late but can still claim
        countdown.textContent = 'LATE';
        if (countdownLabel) countdownLabel.textContent = 'Your slot started!';
        gracePeriod?.classList.remove('hidden');
        slotAvailable?.classList.add('hidden');
        
        const gMins = Math.floor(graceRemaining / 60);
        const gSecs = graceRemaining % 60;
        if (graceCountdown) {
          graceCountdown.textContent = `${gMins}:${gSecs.toString().padStart(2, '0')}`;
        }
        
        // DJ can still press ready and go live
        goLiveBtn.disabled = !isDjReady;
        
        setTimeout(update, 1000);
        return;
      }
      
      if (isDjReady) {
        // DJ is ready - can go live
        countdown.textContent = 'NOW!';
        if (countdownLabel) countdownLabel.textContent = 'You\'re ready!';
        gracePeriod?.classList.add('hidden');
        slotAvailable?.classList.add('hidden');
        goLiveBtn.disabled = false;
        readyBtn?.classList.add('hidden');
        return;
      }
      
      // Grace period expired - slot is up for grabs
      if (!slotExpired) {
        slotExpired = true;
        handleSlotExpired(slot);
      }
      
      countdown.textContent = 'EXPIRED';
      if (countdownLabel) countdownLabel.textContent = 'Slot forfeited';
      gracePeriod?.classList.add('hidden');
      goLiveBtn.disabled = true;
      readyBtn?.classList.add('hidden');
      
      // Show slot available for others (but not for the late DJ)
      // The late DJ sees their slot is forfeited
    };
    
    update();
  }
  
  function handleSlotExpired(slot) {
    console.log('[Lobby] Slot expired for DJ:', slot.djName);
    
    // Notify server that slot is available for takeover
    notifySlotAvailable(slot.id);
  }
  
  async function notifySlotAvailable(slotId) {
    try {
      const token = await currentUser?.getIdToken();
      await fetch('/api/livestream/manage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'slot_expired',
          slotId,
          token
        })
      });
    } catch (err) {
      console.error('Failed to notify slot expiry:', err);
    }
  }
  
  function setDjReady() {
    isDjReady = true;
    
    const readyBtn = document.getElementById('readyBtn');
    const readyIndicator = document.getElementById('readyIndicator');
    const readyStatusText = document.getElementById('readyStatusText');
    const goLiveBtn = document.getElementById('goLiveBtn');
    const gracePeriod = document.getElementById('lobbyGracePeriod');
    
    if (readyBtn) {
      readyBtn.classList.add('is-ready');
      readyBtn.textContent = 'Ready!';
      readyBtn.disabled = true;
    }
    
    if (readyIndicator) {
      readyIndicator.classList.add('is-ready');
    }
    
    if (readyStatusText) {
      readyStatusText.textContent = 'Ready to go live';
    }
    
    // Hide grace period warning if it was showing
    gracePeriod?.classList.add('hidden');
    
    // Enable go live if start time has passed or is within 2 mins
    if (myUpcomingSlot) {
      const now = new Date();
      const start = new Date(myUpcomingSlot.startTime);
      const secsUntil = Math.floor((start - now) / 1000);
      
      if (secsUntil <= 120) {
        goLiveBtn.disabled = false;
      }
    }
    
    // Notify server that DJ is ready
    notifyDjReady();
  }
  
  async function notifyDjReady() {
    if (!myUpcomingSlot || !currentUser) return;
    
    try {
      const token = await currentUser.getIdToken();
      await fetch('/api/livestream/manage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'dj_ready',
          slotId: myUpcomingSlot.id,
          token
        })
      });
      console.log('[Lobby] DJ marked as ready');
    } catch (err) {
      console.error('Failed to notify ready status:', err);
    }
  }
  
  // Ready button click handler
  document.getElementById('readyBtn')?.addEventListener('click', setDjReady);
  
  // Reset ready state when entering lobby
  function resetLobbyState() {
    isDjReady = false;
    slotExpired = false;
    
    const readyBtn = document.getElementById('readyBtn');
    const readyIndicator = document.getElementById('readyIndicator');
    const readyStatusText = document.getElementById('readyStatusText');
    
    if (readyBtn) {
      readyBtn.classList.remove('is-ready', 'hidden');
      readyBtn.textContent = '‚úì Ready';
      readyBtn.disabled = false;
    }
    
    if (readyIndicator) {
      readyIndicator.classList.remove('is-ready');
    }
    
    if (readyStatusText) {
      readyStatusText.textContent = 'Not Ready';
    }
    
    document.getElementById('lobbyGracePeriod')?.classList.add('hidden');
    document.getElementById('slotAvailableSection')?.classList.add('hidden');
  }
  
  function renderCalendar() {
    const grid = document.getElementById('calendarGrid');
    if (!grid) return;
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    let html = '';
    for (let i = 0; i < 7; i++) {
      const date = new Date(currentWeekStart);
      date.setDate(date.getDate() + i);
      
      const isToday = date.getTime() === today.getTime();
      const dateStr = date.toISOString().split('T')[0];
      
      const daySlots = allSlots.filter(s => s.startTime.startsWith(dateStr));
      
      html += `<div class="cal-day${isToday ? ' today' : ''}">
        <div class="cal-day-header">
          <span class="cal-day-name">${dayNames[i]}</span>
          <span class="cal-day-num">${date.getDate()}</span>
        </div>
        <div class="cal-slots">`;
      
      daySlots.slice(0, 3).forEach(slot => {
        const isMySlot = currentUser && slot.djId === currentUser.uid;
        const isLive = slot.status === 'live';
        html += `<div class="cal-slot${isMySlot ? ' my-slot' : ''}${isLive ? ' live' : ''}"><span class="cal-time">${formatTime(slot.startTime)}</span> <span class="cal-dj">${slot.djName}</span></div>`;
      });
      
      if (daySlots.length > 3) {
        html += `<div class="cal-slot">+${daySlots.length - 3} more</div>`;
      }
      
      html += '</div></div>';
    }
    
    grid.innerHTML = html;
    
    // Update week label
    const weekLabel = document.getElementById('weekLabel');
    if (weekLabel) {
      const endDate = new Date(currentWeekStart);
      endDate.setDate(endDate.getDate() + 6);
      weekLabel.textContent = `${formatDate(currentWeekStart.toISOString())} - ${formatDate(endDate.toISOString())}`;
    }
  }
  
  function renderTodaySchedule() {
    const list = document.getElementById('scheduleList');
    if (!list) return;
    
    const now = new Date();
    const today = now.toISOString().split('T')[0];
    
    // Filter to today's slots that are current or future (not completed past shows)
    const todaySlots = allSlots.filter(s => {
      if (!s.startTime.startsWith(today)) return false;
      if (s.status === 'cancelled') return false;
      
      // Show if live, or if end time is in the future
      const endTime = new Date(s.endTime);
      return s.status === 'live' || endTime > now;
    });
    
    // Sort by start time
    todaySlots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
    
    if (todaySlots.length === 0) {
      list.innerHTML = '<p class="empty-message">No upcoming shows today</p>';
      return;
    }
    
    list.innerHTML = todaySlots.map(slot => {
      const isMySlot = currentUser && slot.djId === currentUser.uid;
      const isLive = slot.status === 'live';
      const durationMins = Math.round((new Date(slot.endTime) - new Date(slot.startTime)) / 60000);

      // Format duration nicely: "1 hour", "2 hours", "1.5 hours", or "30 mins"
      let durationText;
      if (durationMins >= 60) {
        const hours = durationMins / 60;
        if (hours === Math.floor(hours)) {
          durationText = hours === 1 ? '1 hour' : `${hours} hours`;
        } else {
          durationText = `${hours.toFixed(1)} hours`;
        }
      } else {
        durationText = `${durationMins} mins`;
      }

      // Format status text
      let statusText = slot.status;
      if (slot.status === 'in_lobby') statusText = 'In Lobby';
      else if (slot.status === 'queued') statusText = 'Queued';
      else if (slot.status === 'scheduled') statusText = 'Scheduled';
      else if (slot.status === 'live') statusText = 'LIVE';

      return `<div class="schedule-item${isMySlot ? ' my-slot' : ''}${isLive ? ' live' : ''}">
        <div class="schedule-time-block">
          <span class="schedule-time-val">${formatTime(slot.startTime)}</span>
          <span class="schedule-duration-val">${durationText}</span>
        </div>
        <div class="schedule-dj-info">
          <h4>${slot.djName}</h4>
          ${slot.title && slot.title !== slot.djName ? `<span class="schedule-title">${slot.title}</span>` : ''}
          ${statusText ? `<span class="schedule-status ${slot.status}">${statusText}</span>` : ''}
        </div>
        ${isMySlot && (slot.status === 'scheduled' || slot.status === 'queued') ? `<button class="cancel-slot-btn" onclick="cancelSlot('${slot.id}')">√ó</button>` : ''}
      </div>`;
    }).join('');
  }
  
  function updateLiveQueueBar(currentLive, upcoming) {
    const liveStatusCard = document.getElementById('liveStatusCard');
    const liveIndicator = document.getElementById('liveIndicator');
    const liveIndicatorText = document.getElementById('liveIndicatorText');
    const liveDjAvatarCard = document.getElementById('liveDjAvatarCard');
    const liveDjNameCard = document.getElementById('liveDjNameCard');
    const liveDjEndsCard = document.getElementById('liveDjEndsCard');
    const queueListCard = document.getElementById('queueListCard');
    
    const streamInfoBar = document.getElementById('streamInfoBar');
    const liveBadge = document.getElementById('liveBadge');
    const liveStatusText = document.getElementById('liveStatusText');
    const streamTitle = document.getElementById('streamTitle');
    const djAvatar = document.getElementById('djAvatar');
    const djName = document.getElementById('djName');
    
    const offlineOverlay = document.getElementById('offlineOverlay');
    const countdownOverlay = document.getElementById('countdownOverlay');
    const playBtn = document.getElementById('playBtn');
    
    // Track live status changes for chat clear timer
    const isLiveNow = !!currentLive;
    if (wasLive && !isLiveNow) {
      // Stream just ended - schedule chat clear in 20 minutes
      scheduleChatClear();
    } else if (!wasLive && isLiveNow) {
      // Stream just started - cancel any pending chat clear
      cancelChatClear();
    }
    wasLive = isLiveNow;
    
    if (currentLive) {
      liveStatusCard?.classList.add('is-live');
      liveIndicator?.classList.add('is-live');
      if (liveIndicatorText) liveIndicatorText.textContent = 'NOW LIVE';
      if (liveDjAvatarCard) liveDjAvatarCard.src = currentLive.djAvatar || '/place-holder.webp';
      if (liveDjNameCard) liveDjNameCard.textContent = currentLive.djName;
      if (liveDjEndsCard) liveDjEndsCard.textContent = `Ends ${formatTime(currentLive.endTime)}`;
      
      streamInfoBar?.classList.add('is-live');
      liveBadge?.classList.add('is-live');
      // Hide status text when live and show "On Air"
      if (liveStatusText) liveStatusText.classList.add('hidden');
      const onAirText = document.getElementById('onAirText');
      if (onAirText) onAirText.classList.remove('hidden');
      if (streamTitle) streamTitle.innerHTML = '<span class="title-live">LIVE</span> <span class="title-session">SESSION</span>';
      if (djAvatar) djAvatar.src = currentLive.djAvatar || '/place-holder.webp';
      if (djName) djName.textContent = currentLive.djName;
      
      // Update controls DJ info bar
      const controlsDjName = document.getElementById('controlsDjName');
      const controlsSetTitle = document.getElementById('controlsSetTitle');
      const djInfoBar = document.querySelector('.dj-info-bar');
      if (controlsDjName) controlsDjName.textContent = currentLive.djName || 'DJ';
      if (controlsSetTitle) controlsSetTitle.textContent = currentLive.title || 'Live Set';
      if (djInfoBar) djInfoBar.classList.add('is-live');
      
      offlineOverlay?.classList.add('hidden');
      countdownOverlay?.classList.add('hidden');
      if (playBtn) playBtn.disabled = false;
      
      // Activate share button when live
      const shareBtn = document.getElementById('shareBtn');
      if (shareBtn) {
        shareBtn.classList.add('live-active');
      }
      
      // Update share preview
      if (window.updateSharePreview) {
        window.updateSharePreview(currentLive.djName, currentLive.djAvatar, currentLive.crew);
      }
    } else {
      liveStatusCard?.classList.remove('is-live');
      liveIndicator?.classList.remove('is-live');
      if (liveIndicatorText) liveIndicatorText.textContent = 'OFFLINE';
      if (liveDjAvatarCard) liveDjAvatarCard.src = '/place-holder.webp';
      if (liveDjNameCard) liveDjNameCard.textContent = 'No one streaming';
      if (liveDjEndsCard) liveDjEndsCard.textContent = 'Check back soon';
      
      streamInfoBar?.classList.remove('is-live');
      liveBadge?.classList.remove('is-live');
      // Show "OFFLINE" and hide "On Air"
      if (liveStatusText) {
        liveStatusText.textContent = 'OFFLINE';
        liveStatusText.classList.remove('hidden');
      }
      const onAirTextOff = document.getElementById('onAirText');
      if (onAirTextOff) onAirTextOff.classList.add('hidden');
      if (streamTitle) streamTitle.innerHTML = '<span class="title-live">LIVE</span> <span class="title-session">SESSION</span>';
      if (djAvatar) djAvatar.src = '/place-holder.webp';
      if (djName) djName.textContent = 'Offline';
      
      // Update controls DJ info bar to offline state
      const controlsDjName = document.getElementById('controlsDjName');
      const controlsSetTitle = document.getElementById('controlsSetTitle');
      const djInfoBar = document.querySelector('.dj-info-bar');
      if (controlsDjName) controlsDjName.textContent = '--';
      if (controlsSetTitle) controlsSetTitle.textContent = 'Waiting for stream...';
      if (djInfoBar) djInfoBar.classList.remove('is-live');
      
      if (playBtn) playBtn.disabled = true;
      
      // Deactivate share button when offline
      const shareBtn = document.getElementById('shareBtn');
      if (shareBtn) {
        shareBtn.classList.remove('live-active');
      }
      
      // Check for countdown
      const inLobby = upcoming?.filter(s => s.status === 'in_lobby') || [];
      if (inLobby.length > 0) {
        showCountdown(inLobby[0]);
      } else {
        // Offline overlay removed - no longer showing "OFFLINE" message
        countdownOverlay?.classList.add('hidden');
      }
    }
    
    // Update queue - show all upcoming slots (scheduled, queued, in_lobby)
    const upcomingSlots = upcoming?.filter(s => 
      ['scheduled', 'queued', 'in_lobby'].includes(s.status)
    ).sort((a, b) => new Date(a.startTime) - new Date(b.startTime)) || [];
    
    if (queueListCard) {
      if (upcomingSlots.length > 0) {
        queueListCard.innerHTML = upcomingSlots.slice(0, 5).map(slot => {
          const statusBadge = slot.status === 'in_lobby' ? 
            '<span class="status-badge lobby">LOBBY</span>' : 
            slot.status === 'queued' ?
            '<span class="status-badge queued">QUEUED</span>' :
            '';
          return `<div class="queue-item">
            <span>${slot.djName}${statusBadge}</span>
            <span class="queue-time">${formatTime(slot.startTime)}</span>
          </div>`;
        }).join('');
      } else {
        queueListCard.innerHTML = '<span class="empty-message">No upcoming DJs</span>';
      }
    }
  }
  
  let countdownInterval = null;
  
  function showCountdown(nextDj) {
    const offlineOverlay = document.getElementById('offlineOverlay');
    const countdownOverlay = document.getElementById('countdownOverlay');
    const countdownDjAvatar = document.getElementById('countdownDjAvatar');
    const countdownDjName = document.getElementById('countdownDjName');
    
    offlineOverlay?.classList.add('hidden');
    countdownOverlay?.classList.remove('hidden');
    
    if (countdownDjAvatar) countdownDjAvatar.src = nextDj.djAvatar || '/place-holder.webp';
    if (countdownDjName) countdownDjName.textContent = nextDj.djName;
    
    if (countdownInterval) clearInterval(countdownInterval);
    
    const startTime = new Date(nextDj.startTime);
    
    countdownInterval = setInterval(() => {
      const now = new Date();
      const secs = Math.floor((startTime - now) / 1000);
      
      if (secs <= 0) {
        clearInterval(countdownInterval);
        scheduleCache = null;
        loadSchedule(true); // Force refresh when DJ should go live
        return;
      }
      
      const mins = Math.floor(secs / 60);
      const s = secs % 60;
      
      const countdownTime = document.getElementById('countdownTime');
      if (countdownTime) countdownTime.textContent = `${mins}:${s.toString().padStart(2, '0')}`;
      
      const progress = document.getElementById('countdownProgress');
      if (progress) progress.style.width = `${(secs / 60) * 100}%`;
    }, 1000);
  }
  
  // Calendar navigation
  document.getElementById('prevWeek')?.addEventListener('click', () => {
    currentWeekStart.setDate(currentWeekStart.getDate() - 7);
    scheduleCache = null; // Invalidate cache for new week
    loadSchedule();
  });
  
  document.getElementById('nextWeek')?.addEventListener('click', () => {
    currentWeekStart.setDate(currentWeekStart.getDate() + 7);
    scheduleCache = null;
    loadSchedule();
  });
  
  // Booking form submit - needs to be in module for currentUser access
  document.getElementById('bookingForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const submitBtn = document.getElementById('submitBooking');
    const errorDiv = document.getElementById('bookingError');
    
    // Check if logged in first
    if (!currentUser) {
      errorDiv.textContent = 'Please sign in to book a slot';
      errorDiv.classList.remove('hidden');
      
      // Show login link
      setTimeout(() => {
        window.location.href = '/login?redirect=/live';
      }, 1500);
      return;
    }
    
    const djName = document.getElementById('bookingDjName').value.trim();
    const crew = document.getElementById('bookingCrew')?.value.trim() || '';
    const description = document.getElementById('bookingDescription')?.value.trim() || '';
    const duration = document.querySelector('input[name="duration"]:checked')?.value || '60';
    
    // Check if queue mode
    const isQueueMode = document.getElementById('bookingTypeQueue')?.classList.contains('active');
    
    if (!djName) {
      errorDiv.textContent = 'Please enter your DJ name';
      errorDiv.classList.remove('hidden');
      return;
    }
    
    if (!isQueueMode) {
      const date = document.getElementById('bookingDate').value;
      const time = document.getElementById('bookingTime').value;
      
      if (!date || !time) {
        errorDiv.textContent = 'Please select a date and time';
        errorDiv.classList.remove('hidden');
        return;
      }
    }
    
    submitBtn.disabled = true;
    submitBtn.textContent = isQueueMode ? 'Joining Queue...' : 'Booking...';
    errorDiv.classList.add('hidden');
    
    try {
      const token = await currentUser.getIdToken();
      
      let requestBody;
      
      if (isQueueMode) {
        // Queue mode - play after next DJ
        requestBody = {
          action: 'queue',
          djId: currentUser.uid,
          djName,
          djAvatar: userInfo?.avatar || null,
          crew: crew || null,
          representing: null,
          description: description || null,
          duration: parseInt(duration),
          token
        };
      } else {
        // Schedule mode - specific date/time
        const date = document.getElementById('bookingDate').value;
        const time = document.getElementById('bookingTime').value;
        const startTime = new Date(`${date}T${time}`).toISOString();
        
        requestBody = {
          action: 'book',
          djId: currentUser.uid,
          djName,
          djAvatar: userInfo?.avatar || null,
          crew: crew || null,
          representing: null,
          description: description || null,
          startTime,
          duration: parseInt(duration),
          token
        };
      }
      
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });
      
      const result = await response.json();
      
      if (result.success) {
        document.getElementById('bookingForm')?.classList.add('hidden');
        document.getElementById('streamKeyDisplay').textContent = result.streamKey;
        document.getElementById('bookingSuccess')?.classList.remove('hidden');
        
        // Force refresh to show new booking immediately
        // Small delay to ensure server has fully processed the booking
        scheduleCache = null;
        await new Promise(resolve => setTimeout(resolve, 500));
        await loadSchedule(true);
      } else {
        errorDiv.textContent = result.error || 'Failed to book slot';
        errorDiv.classList.remove('hidden');
      }
    } catch (err) {
      errorDiv.textContent = 'Network error. Please try again.';
      errorDiv.classList.remove('hidden');
    }
    
    submitBtn.disabled = false;
    submitBtn.textContent = 'Book Slot';
  });
  
  // Copy stream key
  document.getElementById('copyStreamKey')?.addEventListener('click', () => {
    const key = document.getElementById('streamKeyDisplay')?.textContent;
    if (key) {
      navigator.clipboard.writeText(key);
      document.getElementById('copyStreamKey').textContent = 'Copied!';
      setTimeout(() => {
        document.getElementById('copyStreamKey').textContent = 'Copy';
      }, 2000);
    }
  });
  
  // Go Live Now submit handler
  document.getElementById('submitGoLiveNow')?.addEventListener('click', async () => {
    const submitBtn = document.getElementById('submitGoLiveNow');
    const errorDiv = document.getElementById('goLiveNowError');
    
    if (!currentUser) {
      errorDiv.textContent = 'Please sign in to go live';
      errorDiv.classList.remove('hidden');
      setTimeout(() => {
        window.location.href = '/login?redirect=/live';
      }, 1500);
      return;
    }
    
    const djName = document.getElementById('goLiveNowDjName')?.value.trim();
    const crew = document.getElementById('goLiveNowCrew')?.value.trim() || '';
    const description = document.getElementById('goLiveNowDescription')?.value.trim() || '';
    
    if (!djName) {
      errorDiv.textContent = 'Please enter your DJ name';
      errorDiv.classList.remove('hidden');
      return;
    }
    
    submitBtn.disabled = true;
    submitBtn.textContent = 'Going Live...';
    errorDiv.classList.add('hidden');
    
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'go_live_now',
          djId: currentUser.uid,
          djName,
          djAvatar: userInfo?.avatar || null,
          crew: crew || null,
          representing: null,
          description: description || null,
          token
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // Close the modal
        document.getElementById('goLiveNowModal')?.classList.add('hidden');
        
        // Show lobby panel with stream info
        const lobbyPanel = document.getElementById('lobbyPanel');
        const lobbyStreamKey = document.getElementById('lobbyStreamKey');
        const lobbySlotTime = document.getElementById('lobbySlotTime');
        const lobbyCountdownBig = document.getElementById('lobbyCountdownBig');
        const goLiveBtn = document.getElementById('goLiveBtn');
        const endStreamBtn = document.getElementById('endStreamBtn');
        
        if (lobbyPanel) lobbyPanel.classList.remove('hidden');
        if (lobbyStreamKey) lobbyStreamKey.textContent = result.streamKey;
        if (lobbySlotTime) lobbySlotTime.textContent = `Now - ${result.endTimeFormatted || 'Live'}`;
        if (lobbyCountdownBig) lobbyCountdownBig.textContent = 'LIVE NOW';
        if (goLiveBtn) {
          goLiveBtn.textContent = 'You are LIVE!';
          goLiveBtn.disabled = true;
          goLiveBtn.classList.add('is-live');
        }
        if (endStreamBtn) {
          endStreamBtn.classList.remove('hidden');
        }
        
        // Store current slot info for later
        window.currentLiveSlot = result.slot;
        
        // Force refresh to show live status immediately
        scheduleCache = null;
        await loadSchedule(true);
      } else {
        errorDiv.textContent = result.error || 'Failed to go live';
        errorDiv.classList.remove('hidden');
      }
    } catch (err) {
      errorDiv.textContent = 'Network error. Please try again.';
      errorDiv.classList.remove('hidden');
    }
    
    submitBtn.disabled = false;
    submitBtn.textContent = 'Go Live Now';
  });
  
  // Cancel slot
  window.cancelSlot = async (slotId) => {
    if (!confirm('Cancel this slot?')) return;
    
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancel',
          slotId,
          djId: currentUser.uid,
          token
        })
      });
      
      const result = await response.json();
      if (result.success) {
        scheduleCache = null;
        await loadSchedule(true);
      } else {
        alert(result.error || 'Failed to cancel');
      }
    } catch (err) {
      alert('Network error');
    }
  };
  
  // Lobby buttons
  document.getElementById('goLiveBtn')?.addEventListener('click', async () => {
    if (!myUpcomingSlot) return;
    
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/manage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'go_live',
          slotId: myUpcomingSlot.id,
          token
        })
      });
      
      const result = await response.json();
      if (result.success) {
        scheduleCache = null;
        await loadSchedule(true);
      }
    } catch (err) {
      console.error('Failed to go live:', err);
    }
  });
  
  document.getElementById('leaveLobbyBtn')?.addEventListener('click', () => {
    document.getElementById('lobbyPanel')?.classList.add('hidden');
  });
  
  // Claim available slot handler
  document.getElementById('claimSlotBtn')?.addEventListener('click', async () => {
    const claimBtn = document.getElementById('claimSlotBtn');
    if (!claimBtn) return;
    
    claimBtn.disabled = true;
    claimBtn.textContent = '‚è≥ Claiming...';
    
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/manage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'claim_slot',
          token
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // Successfully claimed - update UI
        document.getElementById('slotAvailableSection')?.classList.add('hidden');
        document.getElementById('lobbyStreamKey').textContent = result.streamKey || 'Ready!';
        
        // Reset and show ready state
        isDjReady = true;
        setDjReady();
        
        alert('Slot claimed! You can now go live.');
        
        // Refresh schedule
        scheduleCache = null;
        await loadSchedule(true);
      } else {
        alert(result.error || 'Failed to claim slot - someone else may have claimed it first.');
        claimBtn.disabled = false;
        claimBtn.textContent = 'üéß Claim This Slot';
      }
    } catch (err) {
      console.error('Failed to claim slot:', err);
      alert('Network error. Please try again.');
      claimBtn.disabled = false;
      claimBtn.textContent = 'üéß Claim This Slot';
    }
  });
  
  // Poll for available slots (for DJs not currently in the late slot)
  let availableSlotPollInterval = null;
  
  function startAvailableSlotPolling() {
    if (availableSlotPollInterval) return;
    
    availableSlotPollInterval = setInterval(async () => {
      // Only poll if user is a DJ and lobby panel is visible
      if (!userInfo?.isDj || document.getElementById('lobbyPanel')?.classList.contains('hidden')) {
        return;
      }
      
      try {
        const response = await fetch('/api/livestream/slots?checkAvailable=true');
        const result = await response.json();
        
        if (result.availableSlot) {
          // There's an available slot - show claim option
          const slotAvailable = document.getElementById('slotAvailableSection');
          const mySlotId = myUpcomingSlot?.id;
          
          // Don't show to the DJ who forfeited their own slot
          if (result.availableSlot.id !== mySlotId) {
            slotAvailable?.classList.remove('hidden');
          }
        }
      } catch (err) {
        console.error('Error polling for available slots:', err);
      }
    }, 5000); // Poll every 5 seconds
  }
  
  function stopAvailableSlotPolling() {
    if (availableSlotPollInterval) {
      clearInterval(availableSlotPollInterval);
      availableSlotPollInterval = null;
    }
  }
  
  // Start polling when page loads for DJs
  if (userInfo?.isDj) {
    startAvailableSlotPolling();
  }
  
  // End Stream button handler
  document.getElementById('endStreamBtn')?.addEventListener('click', async () => {
    if (!confirm('Are you sure you want to end your stream?')) return;
    
    const endBtn = document.getElementById('endStreamBtn');
    if (endBtn) {
      endBtn.disabled = true;
      endBtn.textContent = '‚è≥ Ending...';
    }
    
    try {
      const slotId = window.currentLiveSlot?.id;
      if (!slotId) {
        alert('No active stream found');
        return;
      }
      
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'endStream',
          slotId: slotId,
          djId: currentUser.uid,
          token
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // Hide lobby panel
        document.getElementById('lobbyPanel')?.classList.add('hidden');
        
        // Reset buttons
        const goLiveBtn = document.getElementById('goLiveBtn');
        if (goLiveBtn) {
          goLiveBtn.textContent = 'Go Live';
          goLiveBtn.disabled = true;
          goLiveBtn.classList.remove('is-live');
        }
        if (endBtn) {
          endBtn.classList.add('hidden');
          endBtn.disabled = false;
          endBtn.textContent = '‚èπÔ∏è End Stream';
        }
        
        // Clear current slot
        window.currentLiveSlot = null;
        
        // Refresh schedule
        scheduleCache = null;
        await loadSchedule(true);
        
        alert('Stream ended successfully!');
      } else {
        alert(result.error || 'Failed to end stream');
        if (endBtn) {
          endBtn.disabled = false;
          endBtn.textContent = '‚èπÔ∏è End Stream';
        }
      }
    } catch (err) {
      console.error('Failed to end stream:', err);
      alert('Network error. Please try again.');
      if (endBtn) {
        endBtn.disabled = false;
        endBtn.textContent = '‚èπÔ∏è End Stream';
      }
    }
  });
  
  // Smart polling with visibility API to reduce Firebase reads
  let refreshInterval = null;
  const REFRESH_INTERVAL = 900000; // 15 minutes when visible
  const QUICK_REFRESH = 90000; // 1.5 minutes for live status during active streams (was 60s)
  
  function startRefreshInterval() {
    if (refreshInterval) clearInterval(refreshInterval);
    
    // Use shorter interval if someone is live (for real-time feel)
    const isLive = document.getElementById('liveBadge')?.classList.contains('is-live');
    const interval = isLive ? QUICK_REFRESH : REFRESH_INTERVAL;
    
    refreshInterval = setInterval(() => {
      if (!document.hidden) {
        scheduleCache = null;
        loadSchedule();
      }
    }, interval);
  }
  
  // Pause polling when tab is hidden, resume when visible
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // Tab hidden - stop polling to save reads
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    } else {
      // Tab visible again - force refresh to get latest data
      scheduleCache = null;
      loadSchedule(true);
      startRefreshInterval();
    }
  });
  
  // Listen for schedule updates from booking modal
  window.addEventListener('schedule-updated', () => {
    console.log('[Schedule] Booking update detected, refreshing lineup...');
    scheduleCache = null;
    loadSchedule(true);
  });
  
  // ============================================
  // MOBILE TAB NAVIGATION
  // ============================================
  const mobileTabs = document.querySelectorAll('.mobile-tab');
  const scheduleColumn = document.querySelector('.schedule-column');
  const playerColumn = document.querySelector('.player-column');
  const chatColumn = document.querySelector('.chat-column');
  
  function switchMobileTab(tabName) {
    // Update tab buttons
    mobileTabs.forEach(tab => {
      tab.classList.toggle('active', tab.dataset.tab === tabName);
    });
    
    // Update sections
    scheduleColumn?.classList.toggle('mobile-active', tabName === 'schedule');
    playerColumn?.classList.toggle('mobile-active', tabName === 'player');
    chatColumn?.classList.toggle('mobile-active', tabName === 'chat');
    
    // Clear chat badge when viewing chat
    if (tabName === 'chat') {
      const chatBadge = document.querySelector('.mobile-tab[data-tab="chat"] .tab-badge');
      if (chatBadge) chatBadge.remove();
    }
    
    // Scroll to top of content
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
  
  // Tab click handlers
  mobileTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      switchMobileTab(tab.dataset.tab);
    });
  });
  
  // Set initial state
  if (window.innerWidth <= 900) {
    playerColumn?.classList.add('mobile-active');
  }
  
  // Add chat notification badge when new message arrives
  let lastChatCount = 0;
  function addChatBadge() {
    const chatTab = document.querySelector('.mobile-tab[data-tab="chat"]');
    if (!chatTab || chatTab.classList.contains('active')) return;
    
    let badge = chatTab.querySelector('.tab-badge');
    if (!badge) {
      badge = document.createElement('span');
      badge.className = 'tab-badge';
      badge.textContent = '1';
      chatTab.appendChild(badge);
    } else {
      const count = parseInt(badge.textContent) + 1;
      badge.textContent = count > 9 ? '9+' : count;
    }
  }
  
  // Expose for chat system to call
  window.notifyNewChatMessage = addChatBadge;
  
  // Start initial polling
  startRefreshInterval();
  
  // ============================================
  // MOBILE MINI PLAYER
  // ============================================
  const miniPlayer = document.getElementById('miniPlayer');
  const miniPlayBtn = document.getElementById('miniPlayBtn');
  const miniExpandBtn = document.getElementById('miniExpandBtn');
  const miniPlayIcon = document.getElementById('miniPlayIcon');
  const miniPauseIcon = document.getElementById('miniPauseIcon');
  const miniDjName = document.getElementById('miniDjName');
  const miniDjAvatar = document.getElementById('miniDjAvatar');
  const miniLedStrip = document.getElementById('miniLedStrip');
  const playerContainer = document.getElementById('playerContainer');
  
  let miniPlayerVisible = false;
  let lastScrollY = 0;
  
  // Show/hide mini player based on scroll position
  function updateMiniPlayer() {
    if (!playerContainer || !miniPlayer) return;
    
    const rect = playerContainer.getBoundingClientRect();
    const shouldShow = rect.bottom < 0 && window.innerWidth <= 768;
    
    if (shouldShow && !miniPlayerVisible) {
      miniPlayer.classList.remove('hidden');
      setTimeout(() => miniPlayer.classList.add('visible'), 10);
      miniPlayerVisible = true;
    } else if (!shouldShow && miniPlayerVisible) {
      miniPlayer.classList.remove('visible');
      setTimeout(() => miniPlayer.classList.add('hidden'), 300);
      miniPlayerVisible = false;
    }
  }
  
  // Sync mini player state with main player
  function syncMiniPlayer() {
    const playBtn = document.getElementById('playBtn');
    const djName = document.getElementById('djName');
    const djAvatar = document.getElementById('djAvatar');
    
    if (playBtn && miniPlayBtn) {
      const isPlaying = playBtn.classList.contains('playing');
      if (isPlaying) {
        miniPlayIcon?.classList.add('hidden');
        miniPauseIcon?.classList.remove('hidden');
      } else {
        miniPlayIcon?.classList.remove('hidden');
        miniPauseIcon?.classList.add('hidden');
      }
    }
    
    if (djName && miniDjName) {
      miniDjName.textContent = djName.textContent;
    }
    
    if (djAvatar && miniDjAvatar) {
      miniDjAvatar.src = djAvatar.src;
    }
  }
  
  // Mini player play/pause
  miniPlayBtn?.addEventListener('click', () => {
    const playBtn = document.getElementById('playBtn');
    playBtn?.click();
    syncMiniPlayer();
  });
  
  // Expand back to full player
  miniExpandBtn?.addEventListener('click', () => {
    playerContainer?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  });
  
  // Update mini LED strip (simplified visualization)
  function updateMiniLeds(level) {
    if (!miniLedStrip) return;
    const leds = miniLedStrip.querySelectorAll('.mini-led');
    const activeLeds = Math.floor(level * leds.length);
    leds.forEach((led, i) => {
      led.classList.toggle('active', i < activeLeds);
    });
  }
  
  // Throttled scroll handler
  let scrollTimeout;
  window.addEventListener('scroll', () => {
    if (scrollTimeout) return;
    scrollTimeout = setTimeout(() => {
      updateMiniPlayer();
      scrollTimeout = null;
    }, 100);
  }, { passive: true });
  
  // Observe play state changes
  const playBtn = document.getElementById('playBtn');
  if (playBtn) {
    const observer = new MutationObserver(syncMiniPlayer);
    observer.observe(playBtn, { attributes: true, attributeFilter: ['class'] });
  }
  
  // ============================================
  // KEYBOARD SHORTCUTS
  // ============================================
  document.addEventListener('keydown', (e) => {
    // Don't trigger if typing in an input
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch(e.code) {
      case 'Space':
        e.preventDefault();
        document.getElementById('playBtn')?.click();
        break;
      case 'KeyM':
        // Toggle mute
        const slider = document.getElementById('volumeSlider');
        if (slider) {
          slider.value = slider.value > 0 ? 0 : 80;
          slider.dispatchEvent(new Event('input'));
        }
        break;
      case 'ArrowUp':
        e.preventDefault();
        adjustVolume(10);
        break;
      case 'ArrowDown':
        e.preventDefault();
        adjustVolume(-10);
        break;
      case 'KeyF':
        // Fullscreen
        document.getElementById('fullscreenBtn')?.click();
        break;
    }
  });
  
  function adjustVolume(delta) {
    const slider = document.getElementById('volumeSlider');
    if (slider) {
      let newVal = parseInt(slider.value) + delta;
      newVal = Math.max(0, Math.min(100, newVal));
      slider.value = newVal;
      slider.dispatchEvent(new Event('input'));
      showVolumeHint(newVal);
    }
  }
  
  function showVolumeHint(vol) {
    let hint = document.getElementById('volumeHint');
    if (!hint) {
      hint = document.createElement('div');
      hint.id = 'volumeHint';
      hint.className = 'swipe-hint';
      document.body.appendChild(hint);
    }
    hint.textContent = `Volume: ${vol}%`;
    hint.classList.add('visible');
    setTimeout(() => hint.classList.remove('visible'), 1000);
  }
  
  // ============================================
  // TOUCH GESTURES FOR MOBILE
  // ============================================
  let touchStartY = 0;
  let touchStartX = 0;
  
  playerContainer?.addEventListener('touchstart', (e) => {
    touchStartY = e.touches[0].clientY;
    touchStartX = e.touches[0].clientX;
  }, { passive: true });
  
  playerContainer?.addEventListener('touchend', (e) => {
    const touchEndY = e.changedTouches[0].clientY;
    const touchEndX = e.changedTouches[0].clientX;
    const deltaY = touchStartY - touchEndY;
    const deltaX = touchEndX - touchStartX;
    
    // Vertical swipe for volume (if more vertical than horizontal)
    if (Math.abs(deltaY) > 50 && Math.abs(deltaY) > Math.abs(deltaX)) {
      const volumeChange = deltaY > 0 ? 10 : -10;
      adjustVolume(volumeChange);
    }
    
    // Double tap to like
    // (handled by native dblclick)
  }, { passive: true });
  
  // Double tap to trigger reaction
  let lastTap = 0;
  playerContainer?.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTap < 300) {
      // Double tap!
      const likeBtn = document.getElementById('likeBtn');
      likeBtn?.click();
    }
    lastTap = now;
  }, { passive: true });
</script>

<script type="module" src="/live-stream.js?v=20251216-8"></script>
