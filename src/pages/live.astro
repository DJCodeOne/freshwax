---
// src/pages/live.astro
// Live stream viewing page with schedule calendar, booking, and lobby system
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import LiveMiniPlayer from '../components/live/LiveMiniPlayer.astro';
import LiveChat from '../components/live/LiveChat.astro';
import LiveReactions from '../components/live/LiveReactions.astro';
import '../styles/live.css';
import ScheduleModal from '../components/ScheduleModal.astro';
import PlaylistModal from '../components/live/PlaylistModal.astro';

export const prerender = false;

// GIPHY API key - use env var if set, otherwise fallback to public key
const giphyApiKey = import.meta.env.GIPHY_API_KEY || 'p0USqLUVxus8d82HAcPhQ2GqG6SfraYr';

// Firebase config for client-side scripts (with fallback)
const firebaseConfig = {
  apiKey: import.meta.env.PUBLIC_FIREBASE_API_KEY || 'AIzaSyBiZGsWdvA9ESm3OsUpZ-VQpwqMjMpBY6g',
  authDomain: "freshwax-store.firebaseapp.com",
  projectId: "freshwax-store",
  storageBucket: "freshwax-store.firebasestorage.app",
  messagingSenderId: "675435782973",
  appId: "1:675435782973:web:e8459c2ec4a5f6d683db54"
};

// Dynamic thumbnail URL for social sharing - shows current stream or DJ image when live
const ogImageUrl = 'https://freshwax.co.uk/api/livestream/thumbnail';
---

<Layout
  title="Live Stream"
  description="Watch live DJ streams on Fresh Wax. Tune in for live jungle, drum & bass, and breakbeat sets from our resident and guest DJs."
  image={ogImageUrl}
  imageAlt="Fresh Wax Live Stream"
  type="video.other"
  hideShuffle={true}
  video={{
    duration: "PT0M",
    uploadDate: new Date().toISOString(),
    thumbnailUrl: ogImageUrl,
    contentUrl: "https://freshwax.co.uk/live",
    embedUrl: "https://freshwax.co.uk/live/embed"
  }}
>
  <Header />
  
  <!-- Sticky Mini Player for Mobile -->
  <LiveMiniPlayer />
  
  <div id="fullscreenMode" class="fullscreen-mode hidden">
    <div class="fullscreen-header">
      <div class="fs-info">
        <div class="fs-live-badge is-loading" id="fsLiveBadge">
          <span class="fs-live-dot"></span>
          <span id="fsLiveStatus">LOADING...</span>
        </div>
        <h1 id="fsStreamTitle">No Live Streams</h1>
        <div class="fs-dj-info">
          <img id="fsDjAvatar" src="/place-holder.webp" alt="DJ" />
          <span id="fsDjName">-</span>
        </div>
      </div>
      <div class="fs-stats">
        <div class="fs-stat"><span>Views:</span><span id="fsViewers">0</span></div>
        <div class="fs-stat"><span>Reacts:</span><span id="fsLikes">0</span></div>
        <div class="fs-stat"><span>Time:</span><span id="fsDuration">0:00</span></div>
      </div>
      <button id="exitFullscreen" class="fs-exit-btn">Exit</button>
    </div>
    
    <!-- Fullscreen Controls Bar -->
    <div class="fs-controls-bar">
      <div class="fs-reactions">
        <button class="fs-reaction-btn reactions-disabled" data-emoji="‚ù§Ô∏è" title="Love" disabled>‚ù§Ô∏è</button>
        <button class="fs-reaction-btn reactions-disabled" data-emoji="üî•" title="Fire" disabled>üî•</button>
        <button class="fs-reaction-btn reactions-disabled" data-emoji="üí•" title="Explosion" disabled>üí•</button>
        <button class="fs-reaction-btn reactions-disabled" data-emoji="‚≠ê" title="Star" disabled>‚≠ê</button>
        <button class="fs-reaction-btn reactions-disabled" data-emoji="üîä" title="Bass" disabled>üîä</button>
        <button class="fs-reaction-btn reactions-disabled" data-emoji="üëä" title="Fist" disabled>üëä</button>
        <button class="fs-reaction-btn reactions-disabled" data-emoji="üëè" title="Clap" disabled>üëè</button>
        <button class="fs-reaction-btn reactions-disabled" data-emoji="üöÄ" title="Rocket" disabled>üöÄ</button>
        <button id="fsAnimToggleBtn" class="fs-reaction-btn fs-anim-toggle reactions-disabled" title="Turn off emoji animations" disabled>
          <svg class="anim-on-icon" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
          <svg class="anim-off-icon" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>
        </button>
      </div>
      <button id="fsShoutoutBtn" class="fs-shoutout-btn" title="Send a shoutout">
        <span>üì£</span>
        <span>SHOUTOUT</span>
      </button>
      <div class="fs-volume">
        <svg class="fs-volume-icon" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
        <input type="range" id="fsVolumeSlider" min="0" max="100" value="80" />
      </div>
    </div>
    
    <div class="fullscreen-content">
      <div class="fs-player" id="fsPlayer">
        <div class="fs-offline-overlay hidden" id="fsOfflineOverlay" style="display: none !important;">
          <div class="fs-offline-content">
            <div class="fs-offline-icon">OFFLINE</div>
            <h2>No one is streaming right now</h2>
            <p class="fs-offline-subtext" style="font-size: 0.875rem; color: #888; margin-top: 0.5rem;">The playlist will start in a moment</p>
          </div>
        </div>
        <div class="fs-video-container">
          <video id="fsVideo" class="fs-video hidden" controls playsinline></video>
        </div>
        <!-- Fullscreen Audio Placeholder (BUTT mode) -->
        <div id="fsAudioPlaceholder" class="fs-audio-placeholder hidden">
          <!-- Fresh Wax branding top right -->
          <div class="fs-audio-placeholder-branding">
            <span class="brand-fresh">FRESH</span><span class="brand-wax">WAX</span>
          </div>
          <div class="fs-audio-dj-info">
            <div class="fs-audio-dj-name" id="fsAudioDjName">DJ Name</div>
            <div class="fs-audio-show-title">Live on <span class="brand-fresh">Fresh</span> <span class="brand-wax">Wax</span></div>
            <div class="fs-audio-live-badge">
              <span class="fs-live-pulse"></span>
              <span id="fsAudioBadgeText">AUDIO ONLY</span>
            </div>
          </div>
          <div class="fs-turntables-row">
            <div class="fs-vinyl-container fs-vinyl-left">
              <div class="fs-vinyl-record">
                <div class="fs-vinyl-label">
                  <img id="fsVinylDjAvatar" src="/place-holder.webp" alt="DJ" class="fs-vinyl-avatar" />
                </div>
              </div>
              <div class="fs-tonearm fs-tonearm-left"></div>
            </div>
            <div class="fs-audio-waveform">
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
              <div class="fs-audio-bar"></div>
            </div>
            <div class="fs-vinyl-container fs-vinyl-right">
              <div class="fs-vinyl-record">
                <div class="fs-vinyl-label fs-vinyl-label-right">
                  <img id="fsVinylDjAvatar2" src="/place-holder.webp" alt="DJ" class="fs-vinyl-avatar" />
                </div>
              </div>
              <div class="fs-tonearm fs-tonearm-right"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="fs-chat">
        <div class="fs-chat-header">
          <div class="fs-chat-tabs">
            <button class="fs-chat-tab active" data-chat="freshwax">Fresh Wax</button>
            <button class="fs-chat-tab hidden" data-chat="twitch" id="fsTwitchChatTab">
              <svg class="twitch-icon" viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                <path d="M11.571 4.714h1.715v5.143H11.57zm4.715 0H18v5.143h-1.714zM6 0L1.714 4.286v15.428h5.143V24l4.286-4.286h3.428L22.286 12V0zm14.571 11.143l-3.428 3.428h-3.429l-3 3v-3H6.857V1.714h13.714z"/>
              </svg>
              Twitch
            </button>
          </div>
        </div>
        <!-- Fresh Wax Chat Container -->
        <div id="fsFreshwaxChatContainer" class="fs-chat-container active">
          <div class="fs-chat-messages" id="fsChatMessages"></div>
          <div class="fs-chat-input">
            <input type="text" id="fsChatInput" placeholder="Say something..." maxlength="500" />
            <button id="fsSendBtn">Send</button>
          </div>
        </div>
        <!-- Twitch Chat Container -->
        <div id="fsTwitchChatContainer" class="fs-chat-container hidden">
          <iframe id="fsTwitchChatFrame" class="fs-twitch-chat-frame" frameborder="0" scrolling="yes" allowfullscreen="true"></iframe>
          <div class="fs-twitch-placeholder" id="fsTwitchPlaceholder">
            <svg viewBox="0 0 24 24" fill="currentColor" width="32" height="32">
              <path d="M11.571 4.714h1.715v5.143H11.57zm4.715 0H18v5.143h-1.714zM6 0L1.714 4.286v15.428h5.143V24l4.286-4.286h3.428L22.286 12V0zm14.571 11.143l-3.428 3.428h-3.429l-3 3v-3H6.857V1.714h13.714z"/>
            </svg>
            <p>Twitch chat will appear when the DJ is streaming on Twitch</p>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Mobile Tab Navigation -->
  <nav class="mobile-tabs" id="mobileTabs">
    <button class="mobile-tab active" data-tab="player">
      <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M8 5v14l11-7z"/></svg>
      <span>Player</span>
    </button>
    <button class="mobile-tab" data-tab="chat">
      <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"/></svg>
      <span>Chat</span>
    </button>
    <button class="mobile-tab" data-tab="schedule">
      <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11z"/></svg>
      <span>Schedule</span>
    </button>
  </nav>
  
  <main class="live-main">
    <div class="live-layout">
      <aside class="schedule-column">
        <div class="schedule-header">
          <h1>LIVE <span class="red">STREAM</span></h1>
          <p>Watch live DJ sets</p>
          <div id="djButtons" class="schedule-buttons">
            <button id="goLiveNowBtn" class="go-live-now-btn">
              <span class="btn-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="3"/>
                  <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
              </span>
              <span class="btn-content">
                <span class="btn-label">Go Live</span>
                <span class="btn-sublabel">Start streaming now</span>
              </span>
            </button>
            <button id="bookSlotBtn" class="book-btn">
              <span class="btn-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                  <line x1="16" y1="2" x2="16" y2="6"/>
                  <line x1="8" y1="2" x2="8" y2="6"/>
                  <line x1="3" y1="10" x2="21" y2="10"/>
                  <path d="M9 16l2 2 4-4"/>
                </svg>
              </span>
              <span class="btn-content">
                <span class="btn-label">Book Slot</span>
                <span class="btn-sublabel">Reserve your time</span>
              </span>
            </button>
          </div>
        </div>
        
        <div class="sidebar-card">
          <h3>‚è≠Ô∏è UP NEXT</h3>
          <div id="queueListCard" class="queue-list-card">
            <span class="empty-message">No upcoming DJs</span>
          </div>
        </div>
        
        <div class="sidebar-card schedule-card">
          <div class="schedule-header">
            <h3>TODAY'S LINEUP</h3>
            <button id="viewFullScheduleBtn" class="view-full-btn" onclick="openPublicSchedule()">
              View Full Schedule
            </button>
          </div>
          <div id="scheduleList" class="schedule-list">
            <p class="empty-message">No shows today</p>
          </div>
        </div>
      </aside>
      
      <div class="player-column">
        <div class="stream-info-bar" id="streamInfoBar">
          <div class="stream-info-left">
            <div class="stream-meta">
              <button id="playlistBtn" class="playlist-btn hidden">
                <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
                  <path d="M3 6h10v2H3V6zm0 4h10v2H3v-2zm0 4h7v2H3v-2zm13-4v8l6-4-6-4z"/>
                </svg>
                <span>Playlist</span>
              </button>
            </div>
            <!-- Record Button (Pro Feature) -->
            <div class="record-control">
              <button id="recordBtn" class="record-btn pro-locked" disabled title="Upgrade to Pro to record livestreams">
                <span class="record-dot"></span>
                <span class="record-text">REC</span>
              </button>
              <span id="recordDuration" class="record-duration hidden">00:00</span>
            </div>
          </div>
          <div class="stream-info-right">
            <div class="stream-stats">
              <div class="stat"><span class="stat-icon">Views</span><span id="viewerCount">0</span></div>
              <button class="stat like-stat" id="likeStatBtn" title="React to this stream">
                <span class="stat-icon">Reacts</span><span id="likeCount">0</span>
              </button>
              <div class="stat"><span class="stat-icon">Time</span><span id="streamDuration">0:00</span></div>
              <a href="/account/dj-lobby" id="djLobbyBtn" class="dj-lobby-btn hidden" title="Open DJ Lobby">
                <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                  <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                </svg>
                <span>DJ Lobby</span>
              </a>
            </div>
            <div class="live-badge is-loading" id="liveBadge">
              <span class="live-dot"></span>
              <span id="liveStatusText">LOADING...</span>
              <span id="onAirText" class="on-air-text hidden">On Air</span>
            </div>
          </div>
        </div>
        
        <div class="player-container" id="playerContainer">
          <!-- Relay Source Attribution -->
          <div class="relay-attribution" id="relayAttribution">www.theundergroundlair.fr</div>

          <!-- Offline Overlay - shown by default, hidden when stream is active -->
          <div id="offlineOverlay" class="offline-overlay is-loading">
            <div class="offline-overlay-content">
              <div class="offline-icon-large" id="offlineIconText">LOADING...</div>
              <p class="offline-text" id="offlineMainText">Checking for active streams</p>
              <p class="offline-subtext" id="offlineSubText">Please wait...</p>
            </div>
          </div>
          
          <div id="countdownOverlay" class="countdown-overlay hidden">
            <div class="countdown-content">
              <h2>NEXT DJ STARTING SOON</h2>
              <div class="countdown-dj">
                <img id="countdownDjAvatar" src="/place-holder.webp" alt="" class="countdown-avatar" />
                <span id="countdownDjName">-</span>
              </div>
              <div class="countdown-timer">
                <span class="countdown-label">Going live in</span>
                <span id="countdownTime" class="countdown-value">0:60</span>
              </div>
              <div class="countdown-bar">
                <div id="countdownProgress" class="countdown-progress"></div>
              </div>
            </div>
          </div>

          <!-- Initializing Overlay - shown while stream connects, hidden after audio plays or 10s -->
          <div id="initializingOverlay" class="initializing-overlay">
            <div class="initializing-content">
              <div class="initializing-spinner"></div>
              <h2 class="initializing-title">CONNECTING</h2>
              <p class="initializing-text">Initializing audio stream...</p>
              <p class="initializing-subtext">This may take a few seconds. Please be patient while we link up to the servers.</p>
              <div class="initializing-bars">
                <div class="init-bar"></div>
                <div class="init-bar"></div>
                <div class="init-bar"></div>
                <div class="init-bar"></div>
                <div class="init-bar"></div>
              </div>
            </div>
          </div>
          <!-- Inline fallback script to ensure overlay always hides -->
          <script>
            (function() {
              var overlay = document.getElementById('initializingOverlay');
              if (overlay) {
                setTimeout(function() {
                  if (overlay && !overlay.classList.contains('hidden')) {
                    overlay.classList.add('fade-out');
                  }
                }, 5000);
                setTimeout(function() {
                  if (overlay) {
                    overlay.classList.add('hidden');
                  }
                }, 10000);
              }
            })();
          </script>

          <div id="audioPlayer" class="audio-player hidden">
            <div class="audio-only-placeholder">
              <!-- Fresh Wax branding top right -->
              <div class="audio-placeholder-branding">
                <span class="brand-fresh">FRESH</span><span class="brand-wax">WAX</span>
              </div>
              <!-- DJ Info at top -->
              <div class="audio-dj-info">
                <div class="audio-dj-name" id="audioDjName">DJ Name</div>
                <div class="audio-show-title" id="audioShowTitle">Live on <span class="brand-fresh">Fresh</span> <span class="brand-wax">Wax</span></div>
                <div class="audio-live-badge">
                  <span class="live-pulse"></span>
                  <span id="audioBadgeText">AUDIO ONLY</span>
                </div>
              </div>

              <!-- Turntables row: Left deck, Waveform, Right deck -->
              <div class="turntables-row">
                <!-- Left Deck -->
                <div class="vinyl-container vinyl-left">
                  <div class="vinyl-record">
                    <div class="vinyl-label">
                      <img id="vinylDjAvatar" src="/place-holder.webp" alt="DJ" class="vinyl-avatar" />
                    </div>
                    <div class="vinyl-grooves"></div>
                  </div>
                  <div class="tonearm tonearm-left"></div>
                </div>

                <!-- Waveform in center -->
                <div class="audio-waveform">
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                  <div class="audio-bar"></div>
                </div>

                <!-- Right Deck -->
                <div class="vinyl-container vinyl-right">
                  <div class="vinyl-record">
                    <div class="vinyl-label vinyl-label-right">
                      <img id="vinylDjAvatar2" src="/place-holder.webp" alt="DJ" class="vinyl-avatar" />
                    </div>
                    <div class="vinyl-grooves"></div>
                  </div>
                  <div class="tonearm tonearm-right"></div>
                </div>
              </div>
            </div>
            <audio id="audioElement" crossorigin="anonymous" preload="auto"></audio>
          </div>

          <!-- Video Player (for both live stream and playlist) -->
          <div id="videoPlayer" class="video-player hidden" transition:persist="live-video-player">
            <video id="hlsVideoElement" class="hls-video" controls playsinline preload="auto" autoplay muted></video>
            <!-- Playlist embeds will be injected here when active -->
            <div id="playlistPlayer" class="playlist-player hidden"></div>
          </div>

        </div>
        
        <div class="player-controls">
          <button id="playBtn" class="play-btn" disabled>
            <svg id="playIcon" class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
            <svg id="pauseIcon" class="pause-icon hidden" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
          </button>

          <!-- Stereo LED Meters (for live stream) -->
          <div class="stereo-meters-wrapper hidden" id="stereoMetersWrapper">
            <button id="toggleMetersBtn" class="toggle-meters-btn" title="Toggle LED meters">
              <svg class="meters-visible-icon" viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
                <rect x="3" y="12" width="3" height="8" rx="1"/>
                <rect x="8" y="8" width="3" height="12" rx="1"/>
                <rect x="13" y="4" width="3" height="16" rx="1"/>
                <rect x="18" y="10" width="3" height="10" rx="1"/>
              </svg>
              <svg class="meters-hidden-icon hidden" viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
                <rect x="3" y="12" width="3" height="8" rx="1" opacity="0.3"/>
                <rect x="8" y="8" width="3" height="12" rx="1" opacity="0.3"/>
                <rect x="13" y="4" width="3" height="16" rx="1" opacity="0.3"/>
                <rect x="18" y="10" width="3" height="10" rx="1" opacity="0.3"/>
                <line x1="4" y1="4" x2="20" y2="20" stroke="currentColor" stroke-width="2"/>
              </svg>
            </button>
            <div class="stereo-meters" id="stereoMeters">
              <div class="meter-row">
                <span class="meter-label">L</span>
                <div class="led-strip" id="leftMeter">
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led yellow"></div>
                  <div class="led yellow"></div>
                  <div class="led yellow"></div>
                  <div class="led orange"></div>
                  <div class="led orange"></div>
                  <div class="led red"></div>
                  <div class="led red"></div>
                  <div class="led red clip"></div>
                </div>
              </div>
              <div class="meter-row">
                <span class="meter-label">R</span>
                <div class="led-strip" id="rightMeter">
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led green"></div>
                  <div class="led yellow"></div>
                  <div class="led yellow"></div>
                  <div class="led yellow"></div>
                  <div class="led orange"></div>
                  <div class="led orange"></div>
                  <div class="led red"></div>
                  <div class="led red"></div>
                  <div class="led red clip"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Sound Wave Animation (for playlist) -->
          <div class="sound-wave-wrapper paused" id="soundWaveWrapper">
            <div class="sound-wave">
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
              <span class="wave-bar"></span>
            </div>
          </div>
          
          <LiveReactions />
        </div>
        
        <!-- Shoutout Bar -->
        <div class="shoutout-bar" id="shoutoutBar">
          <div class="shoutout-left">
            <span class="shoutout-label">üì£ SHOUT OUTS</span>
            <button id="shoutoutBtn" class="shoutout-btn" title="Send a shoutout">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                <path d="M12 5v14M5 12h14"/>
              </svg>
            </button>
          </div>
          <div class="shoutout-marquee">
            <div class="shoutout-track" id="shoutoutTrack">
              <span class="shoutout-placeholder">üéâ Send a shoutout to appear here!</span>
            </div>
          </div>
        </div>
        
        <!-- DJ Info Bar -->
        <div class="dj-info-bar">
          <img id="djAvatar" src="/place-holder.webp" alt="DJ" class="dj-avatar" />
          <button id="nowPlayingSaveBtn" class="now-playing-save-btn" title="Save to My Playlist">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
            </svg>
          </button>
          <div class="dj-info-center">
            <span class="dj-info-label" id="controlsLabel">NOW PLAYING</span>
            <span class="dj-info-name" id="controlsDjName">--</span>
            <span class="dj-info-title" id="npTrackTitle"></span>
          </div>
          <div class="dj-info-right">
            <div class="np-duration-box" id="bottomDurationBox" style="display: none;">
              <span class="np-duration-label" id="bottomDurationLabel">LEFT</span>
              <span class="np-duration" id="bottomDuration">--:--</span>
            </div>
            <span class="stream-genre" id="streamGenre">Jungle / D&B</span>
          </div>
        </div>
      </div>
      
      <aside class="chat-column">
        <LiveChat />
      </aside>

      <!-- Online Users Sidebar -->
      <aside class="online-users-column">
        <div class="online-users-header">
          <span class="online-dot"></span>
          <span>Online</span>
          <span class="online-count" id="onlineUserCount">0</span>
        </div>
        <div class="online-users-list" id="onlineUsersList">
          <p class="no-users-msg">No users online</p>
        </div>
      </aside>
    </div>
  </main>
  
  <div id="bookingModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content booking-modal-content">
      <div class="modal-header">
        <h2>Book a Live Slot</h2>
        <button class="modal-close" id="closeBookingModal">X</button>
      </div>
      <div class="modal-body">
        <form id="bookingForm">
          <div class="form-group">
            <label>DJ Name <span class="required">*</span></label>
            <input type="text" id="bookingDjName" placeholder="Your DJ name" maxlength="30" required />
          </div>
          
          <div class="form-group">
            <label>Crew / Label / Sound System / Representing</label>
            <input type="text" id="bookingCrew" placeholder="e.g. Ruffneck Ting, London UK" maxlength="30" />
          </div>
          
          <div class="form-group">
            <label>Description</label>
            <textarea id="bookingDescription" placeholder="What will you be playing? (optional)" maxlength="150" rows="2"></textarea>
            <span class="char-count"><span id="bookingDescCount">0</span>/150</span>
          </div>
          
          <div class="form-group">
            <label>Duration <span class="required">*</span></label>
            <div class="duration-options">
              <label class="duration-option">
                <input type="radio" name="duration" value="30" />
                <span>30m</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="45" />
                <span>45m</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="60" checked />
                <span>1hr</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="120" />
                <span>2hr</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="180" />
                <span>3hr</span>
              </label>
              <label class="duration-option">
                <input type="radio" name="duration" value="240" />
                <span>4hr</span>
              </label>
            </div>
          </div>
          
          <div class="form-group">
            <label>When do you want to play?</label>
            <div class="booking-type-toggle">
              <button type="button" class="booking-type-btn active" id="bookingTypeSchedule">Pick Date & Time</button>
              <button type="button" class="booking-type-btn" id="bookingTypeQueue">Play After Next DJ</button>
            </div>
          </div>
          
          <div id="scheduledTimeSection">
            <div class="form-group">
              <label>Select Date <span class="required">*</span></label>
              <div class="calendar-picker" id="bookingCalendar">
                <div class="calendar-header">
                  <button type="button" class="cal-nav-btn" id="calPrevMonth">&lt;</button>
                  <span class="cal-month-year" id="calMonthYear">December 2025</span>
                  <button type="button" class="cal-nav-btn" id="calNextMonth">&gt;</button>
                </div>
                <div class="calendar-weekdays">
                  <span>Mon</span><span>Tue</span><span>Wed</span><span>Thu</span><span>Fri</span><span>Sat</span><span>Sun</span>
                </div>
                <div class="calendar-days" id="calDays"></div>
              </div>
              <input type="hidden" id="bookingDate" />
            </div>
            
            <div class="form-group">
              <label>Select Start Time (24hr) <span class="required">*</span></label>
              <div class="time-dropdown-row">
                <div class="time-dropdown-group">
                  <label class="time-dropdown-label">Hour</label>
                  <select id="bookingHour" class="time-dropdown">
                    <option value="">--</option>
                    <option value="00">00</option>
                    <option value="01">01</option>
                    <option value="02">02</option>
                    <option value="03">03</option>
                    <option value="04">04</option>
                    <option value="05">05</option>
                    <option value="06">06</option>
                    <option value="07">07</option>
                    <option value="08">08</option>
                    <option value="09">09</option>
                    <option value="10">10</option>
                    <option value="11">11</option>
                    <option value="12">12</option>
                    <option value="13">13</option>
                    <option value="14">14</option>
                    <option value="15">15</option>
                    <option value="16">16</option>
                    <option value="17">17</option>
                    <option value="18">18</option>
                    <option value="19">19</option>
                    <option value="20">20</option>
                    <option value="21">21</option>
                    <option value="22">22</option>
                    <option value="23">23</option>
                  </select>
                </div>
                <span class="time-separator">:</span>
                <div class="time-dropdown-group">
                  <label class="time-dropdown-label">Minutes</label>
                  <select id="bookingMinute" class="time-dropdown">
                    <option value="">--</option>
                    <option value="00">00</option>
                    <option value="15">15</option>
                    <option value="30">30</option>
                    <option value="45">45</option>
                  </select>
                </div>
              </div>
              <div id="selectedTimeInfo" class="selected-time-info hidden"></div>
              <input type="hidden" id="bookingTime" />
            </div>
          </div>
          
          <div id="queueSection" class="hidden">
            <div class="queue-info-box">
              <div class="queue-icon">QUEUE</div>
              <p>You'll be added to the queue and go live automatically after the current or next scheduled DJ finishes.</p>
              <p class="queue-note">Your slot will start as soon as the previous DJ ends their set.</p>
            </div>
          </div>
          
          <div id="bookingError" class="form-error hidden"></div>
          
          <button type="submit" class="submit-btn" id="submitBooking">Book Slot</button>
        </form>
        
        <div id="bookingSuccess" class="booking-success hidden">
          <div class="success-icon">OK</div>
          <h3>Slot Booked!</h3>
          <div class="stream-key-info">
            <p>Your stream key:</p>
            <code id="streamKeyDisplay">-</code>
            <button type="button" class="copy-btn" id="copyStreamKey">Copy</button>
          </div>
          <p class="lobby-note">Join the lobby 5 minutes before your slot to go live.</p>
        </div>
      </div>
    </div>
  </div>
  
  <div id="goLiveNowModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header go-live-header">
        <h2>Go Live Now</h2>
        <button class="modal-close" id="closeGoLiveNowModal">X</button>
      </div>
      <div class="modal-body">
        <div id="goLiveNowForm" class="go-live-form">
          <p class="go-live-info">Start streaming immediately! Your session will end at the top of the next hour.</p>
          
          <div class="form-group">
            <label>DJ Name <span class="required">*</span></label>
            <input type="text" id="goLiveNowDjName" placeholder="Your DJ name" maxlength="30" required />
          </div>
          
          <div class="form-group">
            <label>Crew / Label / Sound System / Representing</label>
            <input type="text" id="goLiveNowCrew" placeholder="e.g. Ruffneck Ting, London UK" maxlength="30" />
          </div>
          
          <div class="form-group">
            <label>Description</label>
            <textarea id="goLiveNowDescription" placeholder="What will you be playing? (optional)" maxlength="150" rows="2"></textarea>
            <span class="char-count"><span id="goLiveNowDescCount">0</span>/150</span>
          </div>
          
          <div id="goLiveNowError" class="form-error hidden"></div>
          
          <button type="button" class="submit-btn go-live-submit" id="submitGoLiveNow">Go Live Now</button>
        </div>
        
        <div id="goLiveNowSuccess" class="booking-success hidden">
          <div class="success-icon go-live-icon">LIVE</div>
          <h3>You're Live!</h3>
          <p class="session-end-time">Session ends at <strong id="goLiveNowEndTime">--:--</strong></p>
          <div class="stream-key-info">
            <p>Your stream key:</p>
            <code id="goLiveNowStreamKey">-</code>
            <button type="button" class="copy-btn" id="copyGoLiveNowKey">Copy</button>
          </div>
          <div class="rtmp-info">
            <p>RTMP URL:</p>
            <code>rtmp://rtmp.freshwax.co.uk/live</code>
          </div>
          <p class="go-live-hint">Start your stream in OBS or your preferred software using the details above.</p>
        </div>
      </div>
    </div>
  </div>

  <div id="lobbyPanel" class="lobby-panel hidden">
    <div class="lobby-content">
      <h3>DJ Lobby</h3>
      <div class="lobby-info">
        <div class="lobby-slot-info">
          <span class="lobby-label">Your slot:</span>
          <span id="lobbySlotTime">-</span>
        </div>
        <div class="lobby-countdown-big">
          <span id="lobbyCountdownLabel" class="countdown-label">Time until live:</span>
          <span id="lobbyCountdownBig">--:--</span>
        </div>
        <div id="lobbyGracePeriod" class="lobby-grace-period hidden">
          <span class="grace-warning">‚ö†Ô∏è LATE - Press Ready within:</span>
          <span id="graceCountdown" class="grace-countdown">3:00</span>
        </div>
      </div>
      
      <div class="lobby-ready-status" id="lobbyReadyStatus">
        <div class="ready-indicator" id="readyIndicator">
          <span class="ready-dot"></span>
          <span id="readyStatusText">Not Ready</span>
        </div>
      </div>
      
      <div class="lobby-speed-test">
        <div class="lobby-speed-header">
          <span class="lobby-label">Connection Test</span>
          <button id="speedTestBtn" class="speed-test-btn">
            <span id="speedTestText">Test Speed</span>
          </button>
        </div>
        <div id="speedResult" class="speed-result hidden">
          <div class="speed-item">
            <span class="speed-label">Download:</span>
            <span class="speed-value speed-down"><span id="downloadSpeed">-</span></span>
          </div>
          <div class="speed-item">
            <span class="speed-label">Upload:</span>
            <span class="speed-value speed-up"><span id="uploadSpeed">-</span></span>
          </div>
          <div id="speedRecommendation" class="speed-recommendation"></div>
        </div>
      </div>
      
      <div class="lobby-stream-key">
        <span class="lobby-label">Stream Key:</span>
        <code id="lobbyStreamKey">-</code>
        <button class="copy-key-btn" onclick="copyLobbyStreamKey()">Copy</button>
      </div>
      <div class="lobby-rtmp">
        <span class="lobby-label">RTMP URL:</span>
        <code>rtmp://rtmp.freshwax.co.uk/live</code>
        <button class="copy-key-btn" onclick="copyRtmpUrl()">Copy</button>
      </div>
      <div class="lobby-buttons">
        <button id="readyBtn" class="lobby-btn ready">‚úì Ready</button>
        <button id="goLiveBtn" class="lobby-btn primary" disabled>Go Live</button>
        <button id="endStreamBtn" class="lobby-btn end-stream hidden">‚èπÔ∏è End Stream</button>
        <button id="leaveLobbyBtn" class="lobby-btn cancel">Leave</button>
      </div>
      
      <!-- Slot Available for Takeover -->
      <div id="slotAvailableSection" class="slot-available-section hidden">
        <div class="slot-available-alert">
          <span class="alert-icon">üîì</span>
          <div class="alert-text">
            <strong>Slot Available!</strong>
            <p>Previous DJ missed their window. First to claim gets it!</p>
          </div>
        </div>
        <button id="claimSlotBtn" class="lobby-btn claim">üéß Claim This Slot</button>
      </div>
      
      <!-- Takeover Request Section -->
      <div id="takeoverSection" class="takeover-section hidden">
        <div class="takeover-divider"></div>
        <div class="takeover-header">
          <span class="takeover-icon">üîÑ</span>
          <h4>Request Takeover</h4>
        </div>
        <div class="takeover-current-dj">
          <span class="lobby-label">Currently Live:</span>
          <div class="current-dj-info">
            <img id="takeoverDjAvatar" src="/place-holder.webp" alt="" class="current-dj-avatar" />
            <span id="takeoverDjName">-</span>
          </div>
        </div>
        <p class="takeover-desc">Want to take over this session? The current DJ will need to approve your request.</p>
        <button id="requestTakeoverBtn" class="takeover-request-btn">
          <span>üéß Request Takeover</span>
        </button>
        <div id="takeoverPending" class="takeover-pending hidden">
          <span class="pending-icon">‚è≥</span>
          <span>Waiting for approval...</span>
          <button id="cancelTakeoverBtn" class="cancel-takeover-btn">Cancel</button>
        </div>
        <div id="takeoverApproved" class="takeover-approved hidden">
          <div class="approved-header">
            <span class="approved-icon">‚úì</span>
            <h4>Takeover Approved!</h4>
          </div>
          <p>You now have control of this stream. Use these credentials:</p>
          <div class="takeover-credentials">
            <div class="takeover-cred-item">
              <span class="lobby-label">Stream Key:</span>
              <code id="takeoverStreamKey">-</code>
              <button class="copy-key-btn" onclick="copyTakeoverKey()">Copy</button>
            </div>
            <div class="takeover-cred-item">
              <span class="lobby-label">RTMP URL:</span>
              <code>rtmp://rtmp.freshwax.co.uk/live</code>
              <button class="copy-key-btn" onclick="copyRtmpUrl()">Copy</button>
            </div>
          </div>
          <p class="takeover-note">Connect with your streaming software to take over the stream.</p>
        </div>
      </div>
      
      <div id="lobbyStatusMsg" class="lobby-status-msg hidden"></div>
    </div>
  </div>
  
  <!-- Incoming Takeover Request Notification (for streaming DJ) -->
  <div id="incomingTakeoverNotification" class="incoming-takeover-notification hidden">
    <div class="incoming-takeover-content">
      <div class="incoming-takeover-header">
        <span class="pulse-badge-large">‚ö° TAKEOVER REQUEST</span>
      </div>
      <div class="incoming-takeover-dj">
        <img id="incomingTakeoverAvatar" src="/place-holder.webp" alt="" />
        <div>
          <strong id="incomingTakeoverName">DJ Name</strong>
          <span>wants to take over your stream</span>
        </div>
      </div>
      <div class="incoming-takeover-actions">
        <button id="acceptIncomingTakeoverBtn" class="accept-takeover-btn">‚úì Accept</button>
        <button id="declineIncomingTakeoverBtn" class="decline-takeover-btn">‚úï Decline</button>
      </div>
    </div>
  </div>
  
  <div id="shareModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content share-modal-content">
      <div class="modal-header share-header">
        <h2>Share Live Stream</h2>
        <button class="modal-close" id="closeShareModal">X</button>
      </div>
      <div class="modal-body">
        <div class="share-preview">
          <div class="share-preview-badge">LIVE NOW</div>
          <div class="share-preview-dj">
            <img id="sharePreviewAvatar" src="/place-holder.webp" alt="" />
            <div class="share-preview-info">
              <h3 id="sharePreviewName">DJ Name</h3>
              <p id="sharePreviewCrew">Fresh Wax Live Stream</p>
            </div>
          </div>
        </div>
        
        <div class="share-link-box">
          <input type="text" id="shareLinkInput" readonly value="https://freshwax.co.uk/live" />
          <button id="copyShareLink" class="copy-share-btn">Copy</button>
        </div>
        
        <div class="share-buttons">
          <button id="shareTwitter" class="share-social-btn twitter">
            <span class="share-icon">X</span>
            <span>Twitter/X</span>
          </button>
          <button id="shareFacebook" class="share-social-btn facebook">
            <span class="share-icon">f</span>
            <span>Facebook</span>
          </button>
          <button id="shareWhatsApp" class="share-social-btn whatsapp">
            <span class="share-icon">W</span>
            <span>WhatsApp</span>
          </button>
          <button id="shareTelegram" class="share-social-btn telegram">
            <span class="share-icon">T</span>
            <span>Telegram</span>
          </button>
        </div>
        
        <button id="nativeShare" class="native-share-btn hidden">
          <span>Share via...</span>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Shoutout Modal -->
  <div id="shoutoutModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content shoutout-modal-content">
      <div class="modal-header">
        <h2>üì£ SEND A SHOUTOUT</h2>
        <button class="modal-close" id="closeShoutoutModal">X</button>
      </div>
      <div class="modal-body">
        <p class="shoutout-hint">Birthdays üéÇ ‚Ä¢ Big ups üôå ‚Ä¢ Locations üìç ‚Ä¢ Party vibes üéâ</p>
        <div class="shoutout-input-wrapper">
          <input type="text" id="shoutoutInput" placeholder="Type your shoutout..." maxlength="30" autocomplete="off" />
          <span class="shoutout-char-count"><span id="shoutoutCharCount">0</span>/30</span>
        </div>
        <div class="shoutout-emoji-row">
          <button type="button" class="shoutout-emoji" data-emoji="üéÇ">üéÇ</button>
          <button type="button" class="shoutout-emoji" data-emoji="üéâ">üéâ</button>
          <button type="button" class="shoutout-emoji" data-emoji="üî•">üî•</button>
          <button type="button" class="shoutout-emoji" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</button>
          <button type="button" class="shoutout-emoji" data-emoji="üôå">üôå</button>
          <button type="button" class="shoutout-emoji" data-emoji="üìç">üìç</button>
          <button type="button" class="shoutout-emoji" data-emoji="üéµ">üéµ</button>
          <button type="button" class="shoutout-emoji" data-emoji="üëä">üëä</button>
        </div>
        <button id="sendShoutoutBtn" class="send-shoutout-btn" disabled>
          <span>SEND SHOUTOUT</span>
          <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Schedule Modals (Public & Booking) -->
  <ScheduleModal />

  <!-- Playlist Modal -->
  <PlaylistModal />
</Layout>

<script define:vars={{ giphyApiKey }}>
  window.GIPHY_API_KEY = giphyApiKey;
</script>

<script>
  // ==========================================
  // EMOJI & GIF PICKER - Global Functions
  // ==========================================
  const EMOJI_CATEGORIES = {
    music: ['üéµ', 'üé∂', 'üéß', 'üé§', 'üéπ', 'ü•Å', 'üé∏', 'üé∫', 'üé∑', 'üîä', 'üìª', 'üíø'],
    reactions: ['üî•', '‚ù§Ô∏è', 'üíØ', 'üôå', 'üëè', 'ü§ò', '‚ú®', 'üí•', '‚ö°', 'üåü', 'üí™', 'üëä'],
    faces: ['üòç', 'ü•∞', 'üòé', 'ü§©', 'ü•≥', 'üòà', 'üëÄ', 'ü§Ø', 'üò±', 'ü´†', 'üíÄ', 'üòÇ'],
    vibes: ['üå¥', 'üåô', 'üåä', 'üçæ', 'ü•Ç', 'üí®', 'üåà', '‚òÄÔ∏è', 'üå∫', 'ü¶ã', 'üêç', 'ü¶Å']
  };

  let currentEmojiCategory = 'music';
  let giphySearchTimeout = null;

  // Toggle emoji picker
  window.toggleEmojiPicker = function() {
    console.log('[Picker] Toggle emoji picker');
    const emojiPicker = document.getElementById('emojiPicker');
    const giphyPicker = document.getElementById('giphyPicker');
    const emojiBtn = document.getElementById('emojiBtn');
    const giphyBtn = document.getElementById('giphyBtn');

    // Hide giphy picker
    giphyPicker?.classList.add('hidden');
    giphyBtn?.classList.remove('active');

    // Toggle emoji picker
    const isHidden = emojiPicker?.classList.contains('hidden');
    if (isHidden) {
      emojiPicker?.classList.remove('hidden');
      emojiBtn?.classList.add('active');
      window.renderEmojis(currentEmojiCategory);
    } else {
      emojiPicker?.classList.add('hidden');
      emojiBtn?.classList.remove('active');
    }
  };

  // Toggle GIF picker
  window.toggleGiphyPicker = function() {
    console.log('[Picker] Toggle GIF picker');
    const emojiPicker = document.getElementById('emojiPicker');
    const giphyPicker = document.getElementById('giphyPicker');
    const emojiBtn = document.getElementById('emojiBtn');
    const giphyBtn = document.getElementById('giphyBtn');

    // Hide emoji picker
    emojiPicker?.classList.add('hidden');
    emojiBtn?.classList.remove('active');

    // Toggle giphy picker
    const isHidden = giphyPicker?.classList.contains('hidden');
    if (isHidden) {
      giphyPicker?.classList.remove('hidden');
      giphyBtn?.classList.add('active');
      window.searchGiphy(''); // Load trending
    } else {
      giphyPicker?.classList.add('hidden');
      giphyBtn?.classList.remove('active');
    }
  };

  // Switch emoji category
  window.switchEmojiCategory = function(category) {
    console.log('[Picker] Switch emoji category:', category);
    currentEmojiCategory = category;

    // Update active button
    document.querySelectorAll('.emoji-cat').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.cat === category);
    });

    window.renderEmojis(category);
  };

  // Render emojis for a category
  window.renderEmojis = function(category) {
    const emojiGrid = document.getElementById('emojiGrid');
    if (!emojiGrid) return;

    const emojis = EMOJI_CATEGORIES[category] || [];
    emojiGrid.innerHTML = emojis.map(emoji =>
      `<button type="button" class="emoji-item" onclick="window.insertEmoji('${emoji}')">${emoji}</button>`
    ).join('');
  };

  // Insert emoji into chat input
  window.insertEmoji = function(emoji) {
    console.log('[Picker] Insert emoji:', emoji);
    const chatInput = document.getElementById('chatInput');
    if (chatInput) {
      chatInput.value += emoji;
      chatInput.focus();
    }
  };

  // Debounced GIF search
  window.searchGiphyDebounced = function(query) {
    clearTimeout(giphySearchTimeout);
    giphySearchTimeout = setTimeout(() => window.searchGiphy(query), 500);
  };

  // Search GIFs
  window.searchGiphy = async function(query) {
    const giphyGrid = document.getElementById('giphyGrid');
    const apiKey = window.GIPHY_API_KEY;

    if (!apiKey || !giphyGrid) {
      if (giphyGrid) giphyGrid.innerHTML = '<p class="giphy-hint">GIF search unavailable</p>';
      return;
    }

    giphyGrid.innerHTML = '<p class="giphy-hint">Loading...</p>';

    try {
      const endpoint = query
        ? `https://api.giphy.com/v1/gifs/search?api_key=${apiKey}&q=${encodeURIComponent(query)}&limit=20&rating=pg-13`
        : `https://api.giphy.com/v1/gifs/trending?api_key=${apiKey}&limit=20&rating=pg-13`;

      const response = await fetch(endpoint);
      const data = await response.json();

      if (data.data?.length > 0) {
        giphyGrid.innerHTML = data.data.map(gif => `
          <div class="giphy-item" onclick="window.selectGif('${gif.images.fixed_height.url}', '${gif.id}')">
            <img src="${gif.images.fixed_height_small.url}" alt="${gif.title || 'GIF'}" loading="lazy" />
          </div>
        `).join('');
      } else {
        giphyGrid.innerHTML = '<p class="giphy-hint">No GIFs found</p>';
      }
    } catch (error) {
      console.error('[Picker] Giphy error:', error);
      giphyGrid.innerHTML = '<p class="giphy-hint">Failed to load GIFs</p>';
    }
  };

  // Select a GIF to send
  window.selectGif = async function(giphyUrl, giphyId) {
    console.log('[Picker] Select GIF:', giphyUrl);

    // Close picker
    document.getElementById('giphyPicker')?.classList.add('hidden');
    document.getElementById('giphyBtn')?.classList.remove('active');

    // Get current user and stream
    const currentUser = window.firebaseAuth?.currentUser;
    const streamId = window.currentStreamId;

    if (!currentUser || !streamId) {
      console.warn('[Picker] Cannot send GIF - not logged in or no stream');
      alert('Please sign in to send GIFs');
      return;
    }

    try {
      const response = await fetch('/api/livestream/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          streamId,
          userId: currentUser.uid,
          userName: currentUser.displayName || currentUser.email?.split('@')[0] || 'User',
          message: '[GIF]',
          type: 'giphy',
          giphyUrl,
          giphyId
        })
      });

      const result = await response.json();
      if (!result.success) {
        console.error('[Picker] Failed to send GIF:', result.error);
      }
    } catch (error) {
      console.error('[Picker] GIF send error:', error);
    }
  };

  // Close pickers when clicking outside
  document.addEventListener('click', function(e) {
    const emojiPicker = document.getElementById('emojiPicker');
    const giphyPicker = document.getElementById('giphyPicker');
    const emojiBtn = document.getElementById('emojiBtn');
    const giphyBtn = document.getElementById('giphyBtn');

    // Check if click is outside emoji picker
    if (emojiPicker && !emojiPicker.classList.contains('hidden')) {
      if (!emojiPicker.contains(e.target) && e.target !== emojiBtn) {
        emojiPicker.classList.add('hidden');
        emojiBtn?.classList.remove('active');
      }
    }

    // Check if click is outside giphy picker
    if (giphyPicker && !giphyPicker.classList.contains('hidden')) {
      if (!giphyPicker.contains(e.target) && e.target !== giphyBtn) {
        giphyPicker.classList.add('hidden');
        giphyBtn?.classList.remove('active');
      }
    }
  });

  console.log('[Picker] Emoji & GIF picker functions loaded');
</script>

<script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>

<script>
  // Speed Test - Download and Upload
  async function runSpeedTest() {
    const btn = document.getElementById('speedTestBtn');
    const text = document.getElementById('speedTestText');
    const result = document.getElementById('speedResult');
    const downloadEl = document.getElementById('downloadSpeed');
    const uploadEl = document.getElementById('uploadSpeed');
    const recommendation = document.getElementById('speedRecommendation');
    
    if (!btn) return;
    
    btn.classList.add('testing');
    text.textContent = 'Testing...';
    result.classList.remove('hidden');
    if (recommendation) {
      recommendation.className = 'speed-recommendation';
      recommendation.textContent = '';
    }
    
    try {
      // Test download speed - fetch a larger file
      const downloadStart = performance.now();
      const downloadResponse = await fetch('https://www.cloudflare.com/cdn-cgi/trace?' + Date.now(), { 
        cache: 'no-store',
        mode: 'cors'
      });
      await downloadResponse.text();
      const downloadDuration = (performance.now() - downloadStart) / 1000;
      
      // Estimate download speed based on response time
      let downloadSpeed;
      if (downloadDuration < 0.05) downloadSpeed = 80 + Math.random() * 40;
      else if (downloadDuration < 0.1) downloadSpeed = 40 + Math.random() * 40;
      else if (downloadDuration < 0.2) downloadSpeed = 20 + Math.random() * 20;
      else if (downloadDuration < 0.4) downloadSpeed = 10 + Math.random() * 10;
      else if (downloadDuration < 0.8) downloadSpeed = 5 + Math.random() * 5;
      else downloadSpeed = 1 + Math.random() * 4;
      
      downloadEl.textContent = downloadSpeed.toFixed(1) + ' Mbps';
      
      // Test upload speed - POST some data
      text.textContent = 'Testing upload...';
      const testData = new Blob([new ArrayBuffer(1024)], { type: 'application/octet-stream' });
      const uploadStart = performance.now();
      
      try {
        await fetch('https://httpbin.org/post', {
          method: 'POST',
          body: testData,
          mode: 'cors'
        });
      } catch (e) {
        // Fallback if httpbin fails - estimate from download
      }
      
      const uploadDuration = (performance.now() - uploadStart) / 1000;
      
      // Estimate upload speed (usually slower than download)
      let uploadSpeed;
      if (uploadDuration < 0.1) uploadSpeed = 40 + Math.random() * 30;
      else if (uploadDuration < 0.2) uploadSpeed = 20 + Math.random() * 20;
      else if (uploadDuration < 0.4) uploadSpeed = 10 + Math.random() * 10;
      else if (uploadDuration < 0.8) uploadSpeed = 5 + Math.random() * 5;
      else uploadSpeed = 1 + Math.random() * 4;
      
      uploadEl.textContent = uploadSpeed.toFixed(1) + ' Mbps';
      
      // Show streaming recommendation based on upload speed
      if (recommendation) {
        if (uploadSpeed >= 10) {
          recommendation.className = 'speed-recommendation good';
          recommendation.textContent = '‚úì Great for 1080p streaming';
        } else if (uploadSpeed >= 5) {
          recommendation.className = 'speed-recommendation good';
          recommendation.textContent = '‚úì Good for 720p streaming';
        } else if (uploadSpeed >= 3) {
          recommendation.className = 'speed-recommendation ok';
          recommendation.textContent = '‚ö† OK for 480p - consider wired connection';
        } else {
          recommendation.className = 'speed-recommendation poor';
          recommendation.textContent = '‚úó Connection may be too slow for streaming';
        }
      }
      
      text.textContent = 'Test Again';
    } catch (e) {
      text.textContent = 'Test Failed';
      downloadEl.textContent = '-- Mbps';
      uploadEl.textContent = '-- Mbps';
      if (recommendation) {
        recommendation.className = 'speed-recommendation poor';
        recommendation.textContent = 'Could not complete speed test';
      }
    }
    
    btn.classList.remove('testing');
  }
  
  document.getElementById('speedTestBtn')?.addEventListener('click', runSpeedTest);
  
  // Floating Reactions - Rise from button with JS animation
  let emojiAnimationsEnabled = true;
  
  function createFloatingEmoji(startX, startY, emojiList) {
    // Only show emojis on live pages (ViewTransitions keeps scripts alive across pages)
    const path = window.location.pathname;
    if (!path.startsWith('/live') && !path.includes('/account/dj-lobby')) {
      return;
    }

    // Check if animations are enabled
    if (!emojiAnimationsEnabled) return;
    
    const heart = document.createElement('div');
    
    // Pick random emoji from the list
    const emojis = emojiList || ['‚ù§Ô∏è', 'üíñ', 'üíó', 'üíì', 'üíï'];
    heart.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    
    // Random spread and wiggle parameters
    const spreadX = (Math.random() - 0.5) * 60;
    const wiggleAmount = 20 + Math.random() * 30;
    const duration = 2000 + Math.random() * 1000;
    const fontSize = 28 + Math.floor(Math.random() * 20);
    
    // Calculate position
    const posX = startX + spreadX;
    const posY = startY;
    
    // Apply all styles inline
    Object.assign(heart.style, {
      position: 'fixed',
      left: posX + 'px',
      top: posY + 'px',
      fontSize: fontSize + 'px',
      lineHeight: '1',
      pointerEvents: 'none',
      zIndex: '99999',
      opacity: '1',
      transform: 'scale(0)',
      margin: '0',
      padding: '0'
    });
    
    document.body.appendChild(heart);
    
    // Animate using requestAnimationFrame
    const startTime = performance.now();
    
    function animate(time) {
      const elapsed = time - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Easing function
      const easeOut = 1 - Math.pow(1 - progress, 3);
      
      // Calculate animation values
      const moveY = easeOut * 350;
      const wiggle = Math.sin(progress * Math.PI * 4) * wiggleAmount * (1 - progress);
      
      // Scale animation
      let scale = 1;
      if (progress < 0.1) {
        scale = progress * 12;
      } else if (progress < 0.2) {
        scale = 1.2 - (progress - 0.1) * 2;
      } else {
        scale = 1 - (progress - 0.2) * 0.3;
      }
      
      // Opacity
      const opacity = progress > 0.6 ? 1 - (progress - 0.6) / 0.4 : 1;
      
      // Update position
      heart.style.left = (posX + wiggle) + 'px';
      heart.style.top = (posY - moveY) + 'px';
      heart.style.opacity = String(opacity);
      heart.style.transform = 'scale(' + scale + ')';
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        heart.remove();
      }
    }
    
    requestAnimationFrame(animate);
  }
  
  function triggerReactionBurst(element, emojiList) {
    // Only show emojis on live pages (ViewTransitions keeps scripts alive across pages)
    const path = window.location.pathname;
    if (!path.startsWith('/live') && !path.includes('/account/dj-lobby')) {
      return;
    }

    // Get position from element or default to video player area
    let x = window.innerWidth / 2;
    let y = window.innerHeight / 2;

    if (element && element.getBoundingClientRect) {
      const rect = element.getBoundingClientRect();
      x = rect.left + rect.width / 2;
      y = rect.top + rect.height / 2;
    } else {
      // Position over the video player when no element provided (incoming reactions from other users)
      const playerContainer = document.getElementById('playerContainer');
      if (playerContainer) {
        const rect = playerContainer.getBoundingClientRect();
        x = rect.left + rect.width / 2;
        y = rect.top + rect.height * 0.7; // Start near bottom of player
      }
    }
    
    // Create burst of emojis
    const numHearts = 1;
    for (let i = 0; i < numHearts; i++) {
      setTimeout(() => {
        createFloatingEmoji(x, y, emojiList);
      }, i * 70);
    }
  }
  
  // Legacy function - alias for hearts
  function triggerHeartBurst(element) {
    const emojiList = element?.dataset?.emoji?.split(',') || ['‚ù§Ô∏è', 'üíñ', 'üíó', 'üíì', 'üíï'];
    triggerReactionBurst(element, emojiList);
  }
  
  // Expose globally
  window.triggerHeartBurst = triggerHeartBurst;
  window.triggerReactionBurst = triggerReactionBurst;
  
  // Legacy function for compatibility
  function createHeart(x, y) {
    createFloatingEmoji(x || 100, y || 100, ['‚ù§Ô∏è', 'üíñ', 'üíó']);
  }

  // Track reaction state to prevent spam
  let lastReactionTime = 0;
  // Unique session ID for this browser tab
  const reactionSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
  window.reactionSessionId = reactionSessionId;
  const REACTION_COOLDOWN = 500; // 500ms between reactions

  async function triggerReaction(e) {
    e.preventDefault();
    console.log('[triggerReaction] Called');

    // Require login for all reactions
    const auth = window.firebaseAuth;
    const user = auth?.currentUser;
    console.log('[triggerReaction] User:', user ? user.uid : 'NOT LOGGED IN');

    if (!user) {
      alert('Please sign in to react');
      return;
    }

    // Cooldown to prevent spam
    const now = Date.now();
    if (now - lastReactionTime < REACTION_COOLDOWN) {
      console.log('[triggerReaction] Cooldown active, skipping');
      return;
    }
    lastReactionTime = now;

    const btn = e.currentTarget || e.target;
    const emojiList = btn?.dataset?.emoji?.split(',') || ['‚ù§Ô∏è'];
    const emojiType = btn?.id?.replace('Btn', '') || 'like';
    console.log('[triggerReaction] Emoji:', emojiList, 'Type:', emojiType);

    // Trigger visual animation locally
    triggerReactionBurst(btn, emojiList);
    btn?.classList.add('liked');
    setTimeout(() => btn?.classList.remove('liked'), 300);

    // Optimistic UI - increment count immediately
    const likeCountEl = document.getElementById('likeCount');
    const currentCount = parseInt(likeCountEl?.textContent || '0');
    if (likeCountEl) likeCountEl.textContent = currentCount + 1;

    // Check if we're in playlist mode or livestream mode
    const isPlaylistMode = window.isPlaylistActive;
    const streamId = window.currentStreamId || document.body.dataset.streamId;

    try {
      if (isPlaylistMode) {
        // Playlist mode - use livestream react API with playlist-global streamId
        // This ensures emojis broadcast to all viewers (same as fullscreen page)
        console.log('[triggerReaction] Playlist mode - using livestream react API');
        const emojiResponse = await fetch('/api/livestream/react', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'emoji',
            streamId: 'playlist-global',
            userId: user.uid,
            userName: user.displayName || user.email?.split('@')[0] || 'Viewer',
            emoji: emojiList.join(','),
            emojiType: emojiType,
            sessionId: reactionSessionId
          })
        });
        const emojiResult = await emojiResponse.json();
        console.log('[triggerReaction] Playlist emoji result:', emojiResult);

        // Also update the global reaction count
        const countResponse = await fetch('/api/playlist/global', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'react' })
        });
        const countResult = await countResponse.json();
        if (countResult.success && countResult.playlist?.reactionCount !== undefined && likeCountEl) {
          likeCountEl.textContent = countResult.playlist.reactionCount;
        }
      } else if (streamId) {
        // Livestream mode - use livestream react API
        console.log('[triggerReaction] Livestream mode - streamId:', streamId);
        const emojiResponse = await fetch('/api/livestream/react', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'emoji',
            streamId,
            userId: user.uid,
            userName: user.displayName || user.email?.split('@')[0] || 'Viewer',
            emoji: emojiList.join(','),
            emojiType: emojiType,
            sessionId: reactionSessionId
          })
        });
        const emojiResult = await emojiResponse.json();
        console.log('[triggerReaction] Emoji broadcast result:', emojiResult);

        // Update with actual count from server if available (only if > 0)
        if (emojiResult.success && emojiResult.totalLikes > 0 && likeCountEl) {
          likeCountEl.textContent = emojiResult.totalLikes;
        }
      } else {
        console.log('[Reaction] No active stream or playlist to react to');
        if (likeCountEl) likeCountEl.textContent = currentCount;
      }
    } catch (error) {
      console.error('[Reaction] API error:', error);
      // Revert optimistic update on error
      if (likeCountEl) likeCountEl.textContent = currentCount;
    }
  }
  
  // Setup reaction button click handlers
  setTimeout(() => {
    console.log('[Reaction Setup] Attaching click handlers...');
    ['likeBtn', 'fireBtn', 'explosionBtn', 'starBtn', 'bassBtn', 'fistBtn', 'clapBtn', 'rocketBtn'].forEach(id => {
      const btn = document.getElementById(id);
      console.log(`[Reaction Setup] Button ${id}:`, btn ? 'FOUND' : 'NOT FOUND');
      if (btn) {
        btn.addEventListener('click', (e) => {
          console.log(`[Reaction] ${id} clicked!`);
          triggerReaction(e);
        });
      }
    });

    // Like button in stats bar
    const likeStatBtn = document.getElementById('likeStatBtn');
    if (likeStatBtn) {
      likeStatBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();

        const auth = window.firebaseAuth;
        const user = auth?.currentUser;

        if (!user) {
          alert('Please sign in to like');
          return;
        }

        const streamId = window.currentStreamId;
        if (!streamId) {
          console.log('[Like] No active stream');
          return;
        }

        // Immediate visual feedback - optimistic UI
        const likeCountEl = document.getElementById('likeCount');
        const currentCount = parseInt(likeCountEl?.textContent || '0');
        if (likeCountEl) likeCountEl.textContent = currentCount + 1;

        // Animation feedback
        likeStatBtn.classList.add('clicking');
        likeStatBtn.classList.add('liked');
        setTimeout(() => likeStatBtn.classList.remove('clicking'), 300);

        // Trigger heart animation from button position
        triggerReactionBurst(likeStatBtn, ['‚ù§Ô∏è', 'üíñ', 'üíó', 'üíì', 'üíï']);

        try {
          // Send like and broadcast emoji to all viewers
          fetch('/api/livestream/react', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'emoji',
              streamId,
              userId: user.uid,
              userName: user.displayName || 'Viewer',
              emoji: '‚ù§Ô∏è,üíñ,üíó,üíì,üíï',
              emojiType: 'like'
            })
          });

          // Increment like count in database
          const response = await fetch('/api/livestream/react', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'like',
              streamId,
              userId: user.uid
            })
          });

          const result = await response.json();
          // Update with actual count from server (only if > 0)
          if (result.success && result.totalLikes > 0 && likeCountEl) {
            likeCountEl.textContent = result.totalLikes;
          }
        } catch (error) {
          console.error('[Like] Error:', error);
          // Revert optimistic update on error
          if (likeCountEl) likeCountEl.textContent = currentCount;
        }
      });
    }
  }, 100);

  // Animation toggle button
  const animToggleBtn = document.getElementById('animToggleBtn');
  const fsAnimToggleBtn = document.getElementById('fsAnimToggleBtn');
  
  function toggleEmojiAnimations() {
    emojiAnimationsEnabled = !emojiAnimationsEnabled;
    const isOff = !emojiAnimationsEnabled;
    const title = emojiAnimationsEnabled ? 'Turn off emoji animations' : 'Turn on emoji animations';
    
    // Sync both buttons
    animToggleBtn?.classList.toggle('off', isOff);
    fsAnimToggleBtn?.classList.toggle('off', isOff);
    if (animToggleBtn) animToggleBtn.title = title;
    if (fsAnimToggleBtn) fsAnimToggleBtn.title = title;
  }
  
  animToggleBtn?.addEventListener('click', toggleEmojiAnimations);
  fsAnimToggleBtn?.addEventListener('click', toggleEmojiAnimations);
  
  // Fullscreen Mode
  function openFullscreen() {
    const fs = document.getElementById('fullscreenMode');
    if (fs) {
      fs.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
      syncFullscreenState();
      // Sync volume slider
      const fsVol = document.getElementById('fsVolumeSlider');
      const mainVol = document.getElementById('volumeSlider');
      if (fsVol && mainVol) fsVol.value = mainVol.value;
    }
  }
  
  function closeFullscreen() {
    const fs = document.getElementById('fullscreenMode');
    if (fs) {
      fs.classList.add('hidden');
      document.body.style.overflow = '';
    }
  }
  
  function syncFullscreenState() {
    const mainBadge = document.getElementById('liveBadge');
    const fsBadge = document.getElementById('fsLiveBadge');
    const fsStatus = document.getElementById('fsLiveStatus');
    const fsTitle = document.getElementById('fsStreamTitle');
    const fsAvatar = document.getElementById('fsDjAvatar');
    const fsName = document.getElementById('fsDjName');
    const fsOffline = document.getElementById('fsOfflineOverlay');
    const fsAudioPlaceholder = document.getElementById('fsAudioPlaceholder');
    const fsVideo = document.getElementById('fsVideo');

    // Clear loading state when syncing
    fsBadge?.classList.remove('is-loading');

    // Check if we're in audio-only mode (audioPlayer is visible)
    const audioPlayer = document.getElementById('audioPlayer');
    const isAudioMode = audioPlayer && !audioPlayer.classList.contains('hidden');

    if (mainBadge?.classList.contains('is-live')) {
      fsBadge?.classList.add('is-live');
      if (fsStatus) fsStatus.textContent = 'LIVE';
      fsOffline?.classList.add('hidden');

      // Show/hide audio placeholder based on mode
      if (isAudioMode) {
        fsAudioPlaceholder?.classList.remove('hidden');
        fsVideo?.classList.add('hidden');

        // Sync DJ info to fullscreen audio placeholder
        const mainDjName = document.getElementById('audioDjName');
        const mainDjAvatar = document.getElementById('vinylDjAvatar');
        const mainAudioBadge = document.getElementById('audioBadgeText');
        const fsAudioDjName = document.getElementById('fsAudioDjName');
        const fsVinylAvatar = document.getElementById('fsVinylDjAvatar');
        const fsVinylAvatar2 = document.getElementById('fsVinylDjAvatar2');
        const fsAudioBadge = document.getElementById('fsAudioBadgeText');

        if (fsAudioDjName && mainDjName) fsAudioDjName.innerHTML = mainDjName.innerHTML;
        if (fsVinylAvatar && mainDjAvatar) fsVinylAvatar.src = mainDjAvatar.src;
        if (fsVinylAvatar2 && mainDjAvatar) fsVinylAvatar2.src = mainDjAvatar.src;
        if (fsAudioBadge && mainAudioBadge) fsAudioBadge.textContent = mainAudioBadge.textContent;
      } else {
        fsAudioPlaceholder?.classList.add('hidden');
        fsVideo?.classList.remove('hidden');
      }
    } else {
      fsBadge?.classList.remove('is-live');
      if (fsStatus) fsStatus.textContent = 'OFFLINE';
      fsOffline?.classList.remove('hidden');
      fsAudioPlaceholder?.classList.add('hidden');
    }

    const mainTitle = document.getElementById('streamTitle');
    const mainAvatar = document.getElementById('djAvatar');
    const mainName = document.getElementById('controlsDjName');

    if (fsTitle && mainTitle) fsTitle.textContent = mainTitle.textContent;
    if (fsAvatar && mainAvatar) fsAvatar.src = mainAvatar.src;
    if (fsName && mainName) fsName.innerHTML = mainName.innerHTML;
  }
  
  document.getElementById('exitFullscreen')?.addEventListener('click', closeFullscreen);
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeFullscreen(); });
  
  document.getElementById('fsSendBtn')?.addEventListener('click', () => {
    const input = document.getElementById('fsChatInput');
    const mainInput = document.getElementById('chatInput');
    const mainSend = document.getElementById('sendBtn');
    if (input?.value.trim() && mainInput && mainSend) {
      mainInput.value = input.value;
      mainSend.click();
      input.value = '';
    }
  });
  
  // Enter key for fullscreen chat
  document.getElementById('fsChatInput')?.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      document.getElementById('fsSendBtn')?.click();
    }
  });
  
  // Fullscreen reaction buttons - call triggerReaction directly
  document.querySelectorAll('.fs-reaction-btn').forEach(btn => {
    // Skip the animation toggle button
    if (btn.id === 'fsAnimToggleBtn') return;

    btn.addEventListener('click', (e) => {
      console.log('[Reaction] Button clicked:', btn.dataset.emoji);
      triggerReaction(e);
    });
  });
  
  // Fullscreen shoutout button - open main shoutout modal
  document.getElementById('fsShoutoutBtn')?.addEventListener('click', () => {
    document.getElementById('shoutoutBtn')?.click();
  });
  
  // Fullscreen volume slider - sync with main volume
  const fsVolumeSlider = document.getElementById('fsVolumeSlider');
  const mainVolumeSlider = document.getElementById('volumeSlider');
  
  fsVolumeSlider?.addEventListener('input', (e) => {
    const value = e.target.value;
    if (mainVolumeSlider) {
      mainVolumeSlider.value = value;
      mainVolumeSlider.dispatchEvent(new Event('input'));
    }
  });
  
  // Sync volume sliders when fullscreen opens
  function syncVolumeSliders() {
    if (fsVolumeSlider && mainVolumeSlider) {
      fsVolumeSlider.value = mainVolumeSlider.value;
    }
  }
  
  // Also sync main to fullscreen
  mainVolumeSlider?.addEventListener('input', () => {
    if (fsVolumeSlider) {
      fsVolumeSlider.value = mainVolumeSlider.value;
    }
  });
  
  // Sync fullscreen stats
  setInterval(() => {
    const fs = document.getElementById('fullscreenMode');
    if (fs && !fs.classList.contains('hidden')) {
      const fsViewers = document.getElementById('fsViewers');
      const fsLikes = document.getElementById('fsLikes');
      const fsDuration = document.getElementById('fsDuration');
      const mainViewers = document.getElementById('viewerCount');
      const mainLikes = document.getElementById('likeCount');
      const mainDuration = document.getElementById('streamDuration');
      
      if (fsViewers && mainViewers) fsViewers.textContent = mainViewers.textContent;
      if (fsLikes && mainLikes) fsLikes.textContent = mainLikes.textContent;
      if (fsDuration && mainDuration) fsDuration.textContent = mainDuration.textContent;
      
      const mainChat = document.getElementById('chatMessages');
      const fsChat = document.getElementById('fsChatMessages');
      if (mainChat && fsChat) {
        fsChat.innerHTML = mainChat.innerHTML;
        fsChat.scrollTop = fsChat.scrollHeight;
      }
    }
  }, 1000);

  // Fullscreen Twitch Chat Integration
  let fsTwitchChannel = null;

  function setupFsTwitchChat(twitchChannel) {
    const twitchTab = document.getElementById('fsTwitchChatTab');
    const twitchContainer = document.getElementById('fsTwitchChatContainer');
    const twitchFrame = document.getElementById('fsTwitchChatFrame');
    const twitchPlaceholder = document.getElementById('fsTwitchPlaceholder');

    if (twitchChannel && twitchChannel.trim()) {
      // Show Twitch tab
      twitchTab?.classList.remove('hidden');
      fsTwitchChannel = twitchChannel.trim().toLowerCase();

      // Set up iframe URL with parent domain
      const host = window.location.hostname;
      const twitchChatUrl = `https://www.twitch.tv/embed/${fsTwitchChannel}/chat?parent=${host}&darkpopout`;

      if (twitchFrame) {
        twitchFrame.src = twitchChatUrl;
        twitchPlaceholder?.classList.add('hidden');
      }
    } else {
      // Hide Twitch tab if no channel
      twitchTab?.classList.add('hidden');
      fsTwitchChannel = null;

      // Switch to Fresh Wax chat if currently on Twitch
      const activeTwitchTab = document.querySelector('.fs-chat-tab[data-chat="twitch"].active');
      if (activeTwitchTab) {
        switchFsChat('freshwax');
      }
    }
  }

  function switchFsChat(chatType) {
    const tabs = document.querySelectorAll('.fs-chat-tab');
    const containers = document.querySelectorAll('.fs-chat-container');

    tabs.forEach(tab => {
      if (tab.dataset.chat === chatType) {
        tab.classList.add('active');
      } else {
        tab.classList.remove('active');
      }
    });

    containers.forEach(container => {
      if (container.id === `fs${chatType.charAt(0).toUpperCase() + chatType.slice(1)}ChatContainer`) {
        container.classList.add('active');
      } else {
        container.classList.remove('active');
      }
    });
  }

  // Chat tab click handlers
  document.querySelectorAll('.fs-chat-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      const chatType = tab.dataset.chat;
      if (chatType) {
        switchFsChat(chatType);
      }
    });
  });

  // Expose function globally for live-stream.js to call
  window.setupFsTwitchChat = setupFsTwitchChat;

  // Calendar and time picker state
  let calendarDate = new Date();
  let selectedDate = null;
  let selectedTime = null;
  let selectedDuration = 60; // Default 1 hour
  let bookingMode = 'schedule'; // 'schedule' or 'queue'
  
  // Get booked slots for conflict checking
  function getBookedSlotsForDate(dateStr) {
    const slots = window.bookedSlots || [];
    return slots.filter(slot => 
      slot.startTime.startsWith(dateStr) && 
      ['scheduled', 'live', 'in_lobby', 'queued'].includes(slot.status)
    );
  }
  
  // Check if a time slot conflicts with existing bookings
  function isTimeSlotAvailable(dateStr, timeStr, duration) {
    const slotStart = new Date(`${dateStr}T${timeStr}:00`);
    const slotEnd = new Date(slotStart.getTime() + duration * 60000);
    
    const daySlots = getBookedSlotsForDate(dateStr);
    
    for (const booked of daySlots) {
      const bookedStart = new Date(booked.startTime);
      const bookedEnd = new Date(booked.endTime);
      
      // Check for overlap: new slot starts before booked ends AND new slot ends after booked starts
      if (slotStart < bookedEnd && slotEnd > bookedStart) {
        return false;
      }
    }
    return true;
  }
  
  // Format end time from start time and duration
  function getEndTime(timeStr, duration) {
    const [hours, mins] = timeStr.split(':').map(Number);
    const totalMins = hours * 60 + mins + duration;
    const endHours = Math.floor(totalMins / 60) % 24;
    const endMins = totalMins % 60;
    return `${String(endHours).padStart(2, '0')}:${String(endMins).padStart(2, '0')}`;
  }
  
  function renderCalendar() {
    const year = calendarDate.getFullYear();
    const month = calendarDate.getMonth();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const maxDate = new Date();
    maxDate.setDate(maxDate.getDate() + 30); // Allow booking up to 1 month ahead
    
    document.getElementById('calMonthYear').textContent = 
      calendarDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
    
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDay = (firstDay.getDay() + 6) % 7; // Monday = 0
    
    const daysContainer = document.getElementById('calDays');
    daysContainer.innerHTML = '';
    
    // Previous month days
    const prevMonthLastDay = new Date(year, month, 0).getDate();
    for (let i = startDay - 1; i >= 0; i--) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cal-day other-month disabled';
      btn.textContent = prevMonthLastDay - i;
      daysContainer.appendChild(btn);
    }
    
    // Current month days
    for (let d = 1; d <= lastDay.getDate(); d++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cal-day';
      btn.textContent = d;
      
      const thisDate = new Date(year, month, d);
      thisDate.setHours(0, 0, 0, 0);
      
      if (thisDate < today || thisDate > maxDate) {
        btn.classList.add('disabled');
      } else {
        btn.addEventListener('click', () => selectDate(year, month, d));
      }
      
      if (thisDate.getTime() === today.getTime()) {
        btn.classList.add('today');
      }
      
      if (selectedDate && 
          thisDate.getFullYear() === selectedDate.getFullYear() &&
          thisDate.getMonth() === selectedDate.getMonth() &&
          thisDate.getDate() === selectedDate.getDate()) {
        btn.classList.add('selected');
        btn.style.background = '#dc2626';
        btn.style.color = '#fff';
        btn.style.fontWeight = '700';
        btn.style.boxShadow = '0 2px 8px rgba(220, 38, 38, 0.4)';
      }
      
      daysContainer.appendChild(btn);
    }
    
    // Next month days
    const totalCells = daysContainer.children.length;
    const remaining = 42 - totalCells;
    for (let d = 1; d <= remaining && totalCells + d <= 42; d++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cal-day other-month disabled';
      btn.textContent = d;
      daysContainer.appendChild(btn);
    }
  }
  
  function selectDate(year, month, day) {
    selectedDate = new Date(year, month, day);
    document.getElementById('bookingDate').value = 
      `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    
    renderCalendar();
    
    // Re-validate time selection with new date
    updateTimeFromDropdowns();
  }
  
  function updateTimeFromDropdowns() {
    const hour = document.getElementById('bookingHour')?.value;
    const minute = document.getElementById('bookingMinute')?.value;
    
    if (hour && minute) {
      const timeStr = `${hour}:${minute}`;
      selectedTime = timeStr;
      document.getElementById('bookingTime').value = timeStr;
      
      // Check availability and show info
      const now = new Date();
      const dateStr = selectedDate ? 
        `${selectedDate.getFullYear()}-${String(selectedDate.getMonth() + 1).padStart(2, '0')}-${String(selectedDate.getDate()).padStart(2, '0')}` : 
        now.toISOString().split('T')[0];
      
      const isToday = dateStr === now.toISOString().split('T')[0];
      const isPast = isToday && (parseInt(hour) < now.getHours() || (parseInt(hour) === now.getHours() && parseInt(minute) <= now.getMinutes()));
      const isUnavailable = !isTimeSlotAvailable(dateStr, timeStr, selectedDuration);
      
      const infoEl = document.getElementById('selectedTimeInfo');
      if (infoEl && selectedDate) {
        if (isPast) {
          infoEl.textContent = '‚ö† This time has already passed';
          infoEl.className = 'selected-time-info error';
          infoEl.classList.remove('hidden');
        } else if (isUnavailable) {
          infoEl.textContent = '‚ö† This slot conflicts with another booking';
          infoEl.className = 'selected-time-info error';
          infoEl.classList.remove('hidden');
        } else {
          const endTime = getEndTime(timeStr, selectedDuration);
          const dateFormatted = selectedDate.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
          infoEl.textContent = `‚úì ${dateFormatted}: ${timeStr} - ${endTime}`;
          infoEl.className = 'selected-time-info';
          infoEl.classList.remove('hidden');
        }
      }
    } else {
      selectedTime = null;
      document.getElementById('bookingTime').value = '';
      document.getElementById('selectedTimeInfo')?.classList.add('hidden');
    }
  }
  
  function renderTimePicker() {
    // Reset dropdowns when date changes
    const hourSelect = document.getElementById('bookingHour');
    const minuteSelect = document.getElementById('bookingMinute');
    
    if (hourSelect && minuteSelect) {
      // Keep current selection but re-validate
      updateTimeFromDropdowns();
    }
  }
  
  // Time dropdown change handlers
  document.getElementById('bookingHour')?.addEventListener('change', updateTimeFromDropdowns);
  document.getElementById('bookingMinute')?.addEventListener('change', updateTimeFromDropdowns);
  
  // Duration change - reset time selection
  document.querySelectorAll('input[name="duration"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      selectedDuration = parseInt(e.target.value);
      // Re-validate current selection with new duration
      updateTimeFromDropdowns();
    });
  });
  
  // Calendar navigation
  document.getElementById('calPrevMonth')?.addEventListener('click', () => {
    calendarDate.setMonth(calendarDate.getMonth() - 1);
    renderCalendar();
  });
  
  document.getElementById('calNextMonth')?.addEventListener('click', () => {
    calendarDate.setMonth(calendarDate.getMonth() + 1);
    renderCalendar();
  });
  
  // Booking type toggle
  document.getElementById('bookingTypeSchedule')?.addEventListener('click', () => {
    bookingMode = 'schedule';
    document.getElementById('bookingTypeSchedule').classList.add('active');
    document.getElementById('bookingTypeQueue').classList.remove('active');
    document.getElementById('scheduledTimeSection').classList.remove('hidden');
    document.getElementById('queueSection').classList.add('hidden');
  });
  
  document.getElementById('bookingTypeQueue')?.addEventListener('click', () => {
    bookingMode = 'queue';
    document.getElementById('bookingTypeQueue').classList.add('active');
    document.getElementById('bookingTypeSchedule').classList.remove('active');
    document.getElementById('scheduledTimeSection').classList.add('hidden');
    document.getElementById('queueSection').classList.remove('hidden');
  });
  
  // NOTE: Booking button listeners moved to setupBookingButtons() for View Transitions support
  
  // Close modals on overlay click
  document.querySelectorAll('.modal-overlay').forEach(overlay => {
    overlay.addEventListener('click', () => {
      document.getElementById('bookingModal')?.classList.add('hidden');
      document.getElementById('goLiveNowModal')?.classList.add('hidden');
      document.getElementById('shareModal')?.classList.add('hidden');
    });
  });
  
  // Go Live Now button handler - redirects directly to DJ lobby
  // The DJ lobby page handles eligibility checking with the dark theme
  document.getElementById('goLiveNowBtn')?.addEventListener('click', async () => {
    // Wait for auth to be ready
    let user = null;
    if (window.authReady) {
      user = await window.authReady;
    } else {
      const { getAuth } = await import('https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js');
      const auth = getAuth();
      user = auth.currentUser;
    }

    if (!user) {
      // Not logged in - redirect to login
      window.location.href = '/login?redirect=/account/dj-lobby';
      return;
    }

    // Redirect directly to DJ lobby - it handles eligibility checking
    window.location.href = '/account/dj-lobby';
  });


  
  document.getElementById('closeGoLiveNowModal')?.addEventListener('click', () => {
    document.getElementById('goLiveNowModal')?.classList.add('hidden');
  });
  
  // Copy Go Live Now stream key
  document.getElementById('copyGoLiveNowKey')?.addEventListener('click', () => {
    const key = document.getElementById('goLiveNowStreamKey')?.textContent;
    if (key && key !== '-') {
      navigator.clipboard.writeText(key);
      document.getElementById('copyGoLiveNowKey').textContent = 'Copied!';
      setTimeout(() => {
        document.getElementById('copyGoLiveNowKey').textContent = 'Copy';
      }, 2000);
    }
  });
  
  // Character counters for description fields
  document.getElementById('bookingDescription')?.addEventListener('input', (e) => {
    const count = e.target.value.length;
    document.getElementById('bookingDescCount').textContent = count;
  });
  
  document.getElementById('goLiveNowDescription')?.addEventListener('input', (e) => {
    const count = e.target.value.length;
    document.getElementById('goLiveNowDescCount').textContent = count;
  });
  
  // Share functionality
  let currentLiveInfo = null;
  
  function updateSharePreview(djName, djAvatar, crew) {
    currentLiveInfo = { djName, djAvatar, crew };
    document.getElementById('sharePreviewName').textContent = djName || 'Live Now';
    document.getElementById('sharePreviewAvatar').src = djAvatar || '/place-holder.webp';
    document.getElementById('sharePreviewCrew').textContent = crew || 'Fresh Wax Live Stream';
  }
  
  function getShareUrl() {
    return window.location.origin + '/live';
  }
  
  function getShareText() {
    if (currentLiveInfo) {
      return `${currentLiveInfo.djName} is LIVE NOW on Fresh Wax!`;
    }
    return 'Fresh Wax Live Stream';
  }
  
  // Open share modal
  document.getElementById('shareBtn')?.addEventListener('click', () => {
    const modal = document.getElementById('shareModal');
    if (modal) {
      modal.classList.remove('hidden');
      document.getElementById('shareLinkInput').value = getShareUrl();
      
      // Show native share button if supported
      if (navigator.share) {
        document.getElementById('nativeShare')?.classList.remove('hidden');
      }
    }
  });
  
  // Close share modal
  document.getElementById('closeShareModal')?.addEventListener('click', () => {
    document.getElementById('shareModal')?.classList.add('hidden');
  });

  // Close share modal on overlay click
  document.querySelector('#shareModal .modal-overlay')?.addEventListener('click', () => {
    document.getElementById('shareModal')?.classList.add('hidden');
  });
  
  // Copy share link
  document.getElementById('copyShareLink')?.addEventListener('click', () => {
    const input = document.getElementById('shareLinkInput');
    const btn = document.getElementById('copyShareLink');
    if (input && btn) {
      navigator.clipboard.writeText(input.value);
      btn.textContent = 'Copied!';
      setTimeout(() => { btn.textContent = 'Copy'; }, 2000);
    }
  });
  
  // Twitter/X share
  document.getElementById('shareTwitter')?.addEventListener('click', () => {
    const text = encodeURIComponent(getShareText());
    const url = encodeURIComponent(getShareUrl());
    window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank', 'width=550,height=420');
  });
  
  // Facebook share - use Feed Dialog for better video preview support
  document.getElementById('shareFacebook')?.addEventListener('click', () => {
    const shareUrl = getShareUrl();
    const djName = document.getElementById('sharePreviewName')?.textContent || 'Fresh Wax DJ';
    const title = encodeURIComponent(`üî¥ LIVE NOW: ${djName} on Fresh Wax`);
    const description = encodeURIComponent('Tune in now for live jungle, drum & bass, and breakbeat!');
    const url = encodeURIComponent(shareUrl);
    // Use feed dialog for richer sharing with video preview
    window.open(
      `https://www.facebook.com/dialog/feed?app_id=966242223397117&link=${url}&name=${title}&description=${description}&redirect_uri=${encodeURIComponent('https://freshwax.co.uk/live')}`,
      '_blank',
      'width=626,height=436'
    );
  });
  
  // WhatsApp share
  document.getElementById('shareWhatsApp')?.addEventListener('click', () => {
    const text = encodeURIComponent(getShareText() + ' ' + getShareUrl());
    window.open(`https://wa.me/?text=${text}`, '_blank');
  });
  
  // Telegram share
  document.getElementById('shareTelegram')?.addEventListener('click', () => {
    const text = encodeURIComponent(getShareText());
    const url = encodeURIComponent(getShareUrl());
    window.open(`https://t.me/share/url?url=${url}&text=${text}`, '_blank');
  });
  
  // Native share (mobile) - closes modal and opens OS share sheet
  document.getElementById('nativeShare')?.addEventListener('click', async () => {
    if (navigator.share) {
      // Close the modal first
      document.getElementById('shareModal')?.classList.add('hidden');
      try {
        await navigator.share({
          title: 'Fresh Wax Live Stream',
          text: getShareText(),
          url: getShareUrl()
        });
      } catch (e) {
        console.log('Share cancelled');
      }
    }
  });
  
  // Make updateSharePreview available globally
  window.updateSharePreview = updateSharePreview;
  
  // ============================================
  // SHOUTOUT FUNCTIONALITY
  // ============================================
  
  const shoutoutBtn = document.getElementById('shoutoutBtn');
  const shoutoutModal = document.getElementById('shoutoutModal');
  const closeShoutoutModal = document.getElementById('closeShoutoutModal');
  const shoutoutInput = document.getElementById('shoutoutInput');
  const shoutoutCharCount = document.getElementById('shoutoutCharCount');
  const sendShoutoutBtn = document.getElementById('sendShoutoutBtn');
  const shoutoutTrack = document.getElementById('shoutoutTrack');
  
  let shoutoutQueue = [];
  let isShoutoutPlaying = false;
  
  // Open shoutout modal function
  function openShoutoutModal() {
    const isLoggedIn = window.currentUserInfo?.loggedIn || false;
    if (!isLoggedIn) {
      alert('Please sign in to send a shoutout');
      return;
    }
    shoutoutModal?.classList.remove('hidden');
    shoutoutInput?.focus();
  }
  
  // Open shoutout modal
  shoutoutBtn?.addEventListener('click', openShoutoutModal);
  
  // Close shoutout modal
  closeShoutoutModal?.addEventListener('click', () => {
    shoutoutModal?.classList.add('hidden');
    if (shoutoutInput) shoutoutInput.value = '';
    if (shoutoutCharCount) shoutoutCharCount.textContent = '0';
    if (sendShoutoutBtn) sendShoutoutBtn.disabled = true;
  });
  
  // Close on overlay click
  shoutoutModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
    shoutoutModal?.classList.add('hidden');
    if (shoutoutInput) shoutoutInput.value = '';
    if (shoutoutCharCount) shoutoutCharCount.textContent = '0';
    if (sendShoutoutBtn) sendShoutoutBtn.disabled = true;
  });
  
  // Character count and enable/disable send button
  shoutoutInput?.addEventListener('input', () => {
    const len = shoutoutInput.value.length;
    if (shoutoutCharCount) shoutoutCharCount.textContent = len;
    if (sendShoutoutBtn) sendShoutoutBtn.disabled = len === 0;
  });
  
  // Emoji buttons
  document.querySelectorAll('.shoutout-emoji').forEach(btn => {
    btn.addEventListener('click', () => {
      if (shoutoutInput && shoutoutInput.value.length < 30) {
        const emoji = btn.dataset.emoji;
        const remaining = 30 - shoutoutInput.value.length;
        if (emoji.length <= remaining) {
          shoutoutInput.value += emoji;
          shoutoutInput.dispatchEvent(new Event('input'));
          shoutoutInput.focus();
        }
      }
    });
  });
  
  // Send shoutout
  sendShoutoutBtn?.addEventListener('click', async () => {
    const message = shoutoutInput?.value.trim();
    if (!message) return;
    
    // Use displayName for shoutouts (matches fullpage behavior)
    const userName = window.currentUserInfo?.displayName || window.currentUserInfo?.name || 'Anonymous';
    const userId = window.currentUserInfo?.id || null;
    
    // Disable button while sending
    sendShoutoutBtn.disabled = true;
    sendShoutoutBtn.innerHTML = '<span>Sending...</span>';
    
    try {
      // Get current stream ID - use playlist-global for playlist mode
      const streamId = window.currentStreamId || 'playlist-global';

      // Send via API to broadcast to all viewers
      const response = await fetch('/api/livestream/react', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'shoutout',
          streamId: streamId,
          userId: userId,
          userName: userName,
          message: message
        })
      });
      
      if (response.ok) {
        // Also play locally immediately
        shoutoutQueue.push({ name: userName, message: message });
        playNextShoutout();
      }
    } catch (e) {
      console.error('Shoutout error:', e);
    }
    
    // Close modal and reset
    shoutoutModal?.classList.add('hidden');
    if (shoutoutInput) shoutoutInput.value = '';
    if (shoutoutCharCount) shoutoutCharCount.textContent = '0';
    sendShoutoutBtn.disabled = true;
    sendShoutoutBtn.innerHTML = '<span>Send Shoutout</span><svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>';
  });
  
  // Play shoutout animation
  function playNextShoutout() {
    if (isShoutoutPlaying || shoutoutQueue.length === 0) return;
    
    isShoutoutPlaying = true;
    const shoutout = shoutoutQueue.shift();
    
    if (shoutoutTrack) {
      shoutoutTrack.innerHTML = `<span class="shoutout-message"><span class="shoutout-name">${shoutout.name}:</span> ${shoutout.message}</span>`;
      shoutoutTrack.classList.remove('scrolling');
      
      // Trigger reflow to restart animation
      void shoutoutTrack.offsetWidth;
      shoutoutTrack.classList.add('scrolling');
      
      // After animation ends, check for more shoutouts
      setTimeout(() => {
        isShoutoutPlaying = false;
        if (shoutoutQueue.length > 0) {
          playNextShoutout();
        } else {
          // Reset to placeholder
          shoutoutTrack.classList.remove('scrolling');
          shoutoutTrack.innerHTML = '<span class="shoutout-placeholder">üéâ Send a shoutout to appear here!</span>';
        }
      }, 30000); // Match animation duration
    }
  }
  
  // Listen for incoming shoutouts from Pusher
  window.handleIncomingShoutout = function(data) {
    shoutoutQueue.push({ name: data.name, message: data.message });
    playNextShoutout();
  };
  
  // Store user info globally for shoutout access
  // Try to restore from localStorage cache first (for instant auth on page reload)
  let cachedAuth = null;
  try {
    const cached = localStorage.getItem('fw_auth_cache');
    if (cached) {
      cachedAuth = JSON.parse(cached);
      // Only use cache if less than 24 hours old
      if (cachedAuth.cachedAt && Date.now() - cachedAuth.cachedAt < 86400000) {
        console.log('[Live] Restored auth from cache:', cachedAuth.id);
      } else {
        cachedAuth = null;
        localStorage.removeItem('fw_auth_cache');
      }
    }
  } catch (e) { /* Ignore cache errors */ }

  window.currentUserInfo = cachedAuth || { loggedIn: false, name: 'Anonymous', displayName: 'Anonymous', id: null };

  // If we have cached auth, dispatch event immediately for components like PlaylistModal
  if (cachedAuth && cachedAuth.loggedIn) {
    // Use setTimeout to ensure DOM is ready
    setTimeout(() => {
      document.dispatchEvent(new CustomEvent('userAuthReady', {
        detail: { user: null, userInfo: window.currentUserInfo }
      }));
    }, 0);
  }

  // Function to setup booking button - needs to be re-attached on View Transitions
  function setupBookingButtons() {
    console.log('[Live] Setting up booking buttons...');

    const bookSlotBtn = document.getElementById('bookSlotBtn');
    if (bookSlotBtn && !bookSlotBtn._listenerAttached) {
      bookSlotBtn._listenerAttached = true;
      bookSlotBtn.addEventListener('click', () => {
        console.log('[Live] Book Slot button clicked');

        const checkAuth = async () => {
          console.log('[Live] Checking auth state...');
          let user = null;
          const cachedUid = localStorage.getItem('fw_uid');

          try {
            // First check if we already have a current user
            if (window.firebaseAuth?.currentUser) {
              user = window.firebaseAuth.currentUser;
              console.log('[Live] Using firebaseAuth.currentUser');
            } else if (window.authReady) {
              console.log('[Live] Using window.authReady');
              user = await window.authReady;
            }

            // If no user but we have cached UID, wait for auth to sync
            if (!user && cachedUid) {
              console.log('[Live] No user but have cached UID, waiting for auth sync...');
              const { getAuth, onAuthStateChanged } = await import('https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js');
              const auth = window.firebaseAuth || getAuth();

              // Wait up to 2 seconds for auth to sync
              user = await new Promise((resolve) => {
                const timeout = setTimeout(() => {
                  console.log('[Live] Auth sync timeout');
                  resolve(auth.currentUser);
                }, 2000);

                const unsubscribe = onAuthStateChanged(auth, (u) => {
                  clearTimeout(timeout);
                  unsubscribe();
                  console.log('[Live] onAuthStateChanged resolved:', u?.uid);
                  resolve(u);
                });
              });
            }
          } catch (err) {
            console.error('[Live] Auth check error:', err);
          }

          console.log('[Live] User:', user ? { uid: user.uid, displayName: user.displayName } : null);

          if (!user) {
            console.log('[Live] No user, redirecting to login');
            window.location.href = '/login?redirect=/live';
            return;
          }

          const displayName = user.displayName || user.email?.split('@')[0] || 'DJ';
          console.log('[Live] Opening booking schedule with:', { uid: user.uid, displayName });
          window.openBookingSchedule(user.uid, displayName);
        };

        checkAuth();
      });
      console.log('[Live] Book Slot button listener attached');
    }

    const viewScheduleBtn = document.getElementById('viewScheduleBtn');
    if (viewScheduleBtn && !viewScheduleBtn._listenerAttached) {
      viewScheduleBtn._listenerAttached = true;
      viewScheduleBtn.addEventListener('click', () => {
        window.openPublicSchedule();
      });
    }

    const closeBookingModal = document.getElementById('closeBookingModal');
    if (closeBookingModal && !closeBookingModal._listenerAttached) {
      closeBookingModal._listenerAttached = true;
      closeBookingModal.addEventListener('click', () => {
        document.getElementById('bookingModal')?.classList.add('hidden');
      });
    }
  }

  // Initial setup
  setupBookingButtons();

  // Re-setup on View Transitions navigation
  document.addEventListener('astro:page-load', () => {
    console.log('[Live] astro:page-load - re-setting up booking buttons');
    // Reset listener flags since View Transitions may have replaced elements
    const bookSlotBtn = document.getElementById('bookSlotBtn');
    const viewScheduleBtn = document.getElementById('viewScheduleBtn');
    const closeBookingModal = document.getElementById('closeBookingModal');
    if (bookSlotBtn) bookSlotBtn._listenerAttached = false;
    if (viewScheduleBtn) viewScheduleBtn._listenerAttached = false;
    if (closeBookingModal) closeBookingModal._listenerAttached = false;
    setupBookingButtons();
    setupMetersToggle();
  });

  // LED meters toggle setup
  function setupMetersToggle() {
    const toggleBtn = document.getElementById('toggleMetersBtn');
    const stereoMeters = document.getElementById('stereoMeters');

    if (!toggleBtn || !stereoMeters) {
      console.log('[Meters] Toggle elements not found');
      return;
    }

    const visibleIcon = toggleBtn.querySelector('.meters-visible-icon');
    const hiddenIcon = toggleBtn.querySelector('.meters-hidden-icon');

    // Check localStorage for saved preference
    const metersHidden = localStorage.getItem('fw_meters_hidden') === 'true';
    if (metersHidden) {
      stereoMeters.classList.add('meters-hidden');
      toggleBtn.classList.add('meters-off');
      if (visibleIcon) visibleIcon.classList.add('hidden');
      if (hiddenIcon) hiddenIcon.classList.remove('hidden');
    }

    // Prevent duplicate listeners
    if (toggleBtn._metersListenerAttached) return;
    toggleBtn._metersListenerAttached = true;

    toggleBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[Meters] Toggle clicked');

      const isHidden = stereoMeters.classList.toggle('meters-hidden');
      toggleBtn.classList.toggle('meters-off', isHidden);
      if (visibleIcon) visibleIcon.classList.toggle('hidden', isHidden);
      if (hiddenIcon) hiddenIcon.classList.toggle('hidden', !isHidden);
      localStorage.setItem('fw_meters_hidden', isHidden ? 'true' : 'false');
      console.log('[Meters] Meters hidden:', isHidden);
    });

    console.log('[Meters] Toggle setup complete');
  }

  // Initial LED meters toggle setup - wait for DOM
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupMetersToggle);
  } else {
    setupMetersToggle();
  }
</script>

<script type="module" define:vars={{ firebaseConfig }}>
  import { initializeApp, getApps, getApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
  import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
  import { getFirestore, doc, setDoc, deleteDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';

  // Prevent duplicate app initialization
  const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const firestoreDb = getFirestore(app);
  
  let currentUser = null;
  let isLoggedIn = false;
  let userInfo = null;
  let currentWeekStart = getWeekStart(new Date());
  let allSlots = [];
  let myUpcomingSlot = null;
  let scheduleCache = null;
  let scheduleCacheTime = 0;
  const CACHE_DURATION = 900000; // 15 minute cache to reduce Firebase reads
  
  // Chat clear timer - clears chat 20 minutes after stream ends
  let wasLive = false;
  let chatClearTimer = null;
  const CHAT_CLEAR_DELAY = 20 * 60 * 1000; // 20 minutes in milliseconds

  // Playlist fallback timer - starts auto-play 10 seconds after stream ends
  let playlistFallbackTimer = null;
  const PLAYLIST_FALLBACK_DELAY = 10 * 1000; // 10 seconds
  
  function clearChatMessages() {
    const chatMessages = document.getElementById('chatMessages');
    const fsChatMessages = document.getElementById('fsChatMessages');
    if (chatMessages) {
      chatMessages.innerHTML = '<div class="chat-system-message">Chat cleared</div>';
    }
    if (fsChatMessages) {
      fsChatMessages.innerHTML = '<div class="chat-system-message">Chat cleared</div>';
    }
    console.log('[Chat] Cleared chat messages 20 minutes after stream ended');
  }
  
  function scheduleChatClear() {
    // Cancel any existing timer
    if (chatClearTimer) {
      clearTimeout(chatClearTimer);
      chatClearTimer = null;
    }
    // Schedule chat clear in 20 minutes
    chatClearTimer = setTimeout(clearChatMessages, CHAT_CLEAR_DELAY);
    console.log('[Chat] Chat will be cleared in 20 minutes');
  }
  
  function cancelChatClear() {
    if (chatClearTimer) {
      clearTimeout(chatClearTimer);
      chatClearTimer = null;
      console.log('[Chat] Chat clear cancelled - new stream started');
    }
  }

  // Playlist fallback: auto-play when no DJ is streaming
  async function startPlaylistFallback() {
    const playlistManager = window.playlistManager;
    if (!playlistManager) {
      console.log('[Playlist] Manager not available');
      return;
    }

    // Check if already playing
    if (playlistManager.isPlaying && playlistManager.queue?.length > 0) {
      console.log('[Playlist] Already playing, resuming...');
      await playlistManager.resume?.();
      return;
    }

    // Try to start auto-play from history
    console.log('[Playlist] Starting auto-play from history...');
    const started = await playlistManager.startAutoPlay?.();
    if (started) {
      console.log('[Playlist] Auto-play started successfully');
      const offlineOverlay = document.getElementById('offlineOverlay');
      if (offlineOverlay) offlineOverlay.classList.add('hidden');
    } else {
      console.log('[Playlist] No tracks available for auto-play');
    }
  }

  function schedulePlaylistFallback() {
    // Cancel any existing timer
    cancelPlaylistFallback();
    // Schedule playlist fallback in 10 seconds
    playlistFallbackTimer = setTimeout(startPlaylistFallback, PLAYLIST_FALLBACK_DELAY);
    console.log('[Playlist] Will start auto-play in 10 seconds if no stream');
  }

  function cancelPlaylistFallback() {
    if (playlistFallbackTimer) {
      clearTimeout(playlistFallbackTimer);
      playlistFallbackTimer = null;
      console.log('[Playlist] Auto-play timer cancelled - stream active');
    }
  }

  async function pausePlaylistForStream() {
    const playlistManager = window.playlistManager;
    if (playlistManager) {
      console.log('[Playlist] Stopping for live stream');
      playlistManager.wasPausedForStream = playlistManager.isPlaying;
      // Completely stop and clear the playlist
      await playlistManager.pause?.();
      await playlistManager.clearQueue?.();
      // Hide the playlist player container
      const embedPlayer = document.getElementById('embedPlayer');
      if (embedPlayer) embedPlayer.classList.add('hidden');
      // Show video player for live stream
      const videoPlayer = document.getElementById('videoPlayer');
      if (videoPlayer) videoPlayer.classList.remove('hidden');
    }
  }

  function getWeekStart(date) {
    const d = new Date(date);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    d.setDate(diff);
    d.setHours(0, 0, 0, 0);
    return d;
  }
  
  function formatTime(dateStr) {
    const d = new Date(dateStr);
    return d.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
  }
  
  function formatDate(dateStr) {
    const d = new Date(dateStr);
    return d.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
  }
  
  // Auth state - SINGLE CHECK, no repeated calls
  onAuthStateChanged(auth, async (user) => {
    currentUser = user;
    if (user) {
      await checkUserStatus(user.uid);
    }
    loadSchedule();
  });

  // Subscribe to live-status Pusher channel for instant schedule updates
  function setupLiveStatusListener() {
    const config = window.PUSHER_CONFIG;
    if (!config?.key) {
      console.log('[LiveStatus] Pusher config not ready');
      return;
    }

    try {
      const statusPusher = new window.Pusher(config.key, {
        cluster: config.cluster || 'eu',
        forceTLS: true
      });

      const liveStatusChannel = statusPusher.subscribe('live-status');

      liveStatusChannel.bind('stream-started', (data) => {
        console.log('[LiveStatus] DJ went live:', data.djName);
        // Pause playlist when DJ goes live
        pausePlaylistForStream();
        // Trigger live-stream.js to fetch stream and load HLS player
        if (typeof window.checkLiveStatus === 'function') {
          window.checkLiveStatus();
        }
        // Refresh schedule immediately
        scheduleCache = null;
        loadSchedule(true);
      });

      liveStatusChannel.bind('stream-ended', (data) => {
        console.log('[LiveStatus] Stream ended:', data.djName);
        // Refresh schedule immediately to remove completed DJ
        scheduleCache = null;
        loadSchedule(true);
        // Resume playlist after 10 second delay
        setTimeout(() => {
          const playlistManager = window.playlistManager;
          if (playlistManager?.wasPausedForStream) {
            console.log('[Playlist] Resuming after stream ended (10s delay)');
            playlistManager.wasPausedForStream = false;
            playlistManager.play?.();
          }
        }, 10000);
      });

      console.log('[LiveStatus] Subscribed to live-status channel');

      // Subscribe to presence channel for viewer tracking (no Firebase needed!)
      const streamId = window.currentStreamId || 'playlist-global';
      const presenceChannelName = `presence-stream-${streamId}`;

      // Get user info for presence data - check multiple sources
      // 1. Current userInfo (if already loaded)
      // 2. Cached auth from localStorage (for faster initial load)
      // 3. Firebase currentUser
      // 4. Session ID as fallback
      let cachedAuth = null;
      try {
        const cached = localStorage.getItem('fw_auth_cache');
        if (cached) {
          cachedAuth = JSON.parse(cached);
          // Only use cache if less than 1 hour old
          if (cachedAuth.cachedAt && Date.now() - cachedAuth.cachedAt > 3600000) {
            cachedAuth = null;
          }
        }
      } catch (e) { /* ignore */ }

      const userId = currentUser?.uid || cachedAuth?.id || getOrCreateSessionId();
      const userName = userInfo?.name || cachedAuth?.name || currentUser?.displayName || 'Viewer';
      const userAvatar = userInfo?.avatar || cachedAuth?.avatarUrl || currentUser?.photoURL || '';

      console.log('[Presence] Subscribing as:', userName, 'with ID:', userId);

      // Create Pusher instance with presence auth
      const presencePusher = new window.Pusher(config.key, {
        cluster: config.cluster || 'eu',
        forceTLS: true,
        authEndpoint: '/api/pusher/auth',
        auth: {
          headers: {
            'x-user-id': userId,
            'x-user-name': userName,
            'x-user-avatar': userAvatar
          }
        }
      });

      // Store for potential re-subscription
      window.presencePusher = presencePusher;

      // Subscribe to presence channel - Pusher tracks members automatically!
      const presenceChannel = presencePusher.subscribe(presenceChannelName);
      window.presenceChannel = presenceChannel; // Store for later use

      // Update viewer count and online users list
      // Use window.presenceChannel so this works after re-subscription
      function updateOnlineUsers() {
        const channel = window.presenceChannel;
        const count = channel?.members?.count || 0;
        console.log('[Presence] Member count:', count);

        // Update count displays
        const viewerEl = document.getElementById('viewerCount');
        const fsViewers = document.getElementById('fsViewers');
        const chatViewers = document.getElementById('chatViewers');
        const onlineCount = document.getElementById('onlineUserCount');
        if (viewerEl) viewerEl.textContent = count;
        if (fsViewers) fsViewers.textContent = count;
        if (chatViewers) chatViewers.textContent = `${count} watching`;
        if (onlineCount) onlineCount.textContent = count;

        // Update online users list
        const usersList = document.getElementById('onlineUsersList');
        if (usersList && channel?.members) {
          usersList.innerHTML = '';
          if (count === 0) {
            usersList.innerHTML = '<p class="no-users-msg">No users online</p>';
          } else {
            channel.members.each((member) => {
              const userEl = document.createElement('div');
              userEl.className = 'online-user-item';
              userEl.dataset.userId = member.id;

              const avatar = member.info?.avatar;
              const name = member.info?.name || 'Viewer';

              if (avatar) {
                userEl.innerHTML = `<div class="online-user-avatar"><img src="${avatar}" alt="${name}" /></div><span class="online-user-name">${name}</span>`;
              } else {
                userEl.innerHTML = `<div class="online-user-avatar">${name.charAt(0).toUpperCase()}</div><span class="online-user-name">${name}</span>`;
              }

              usersList.appendChild(userEl);
            });
          }
        }
      }

      // Expose globally for re-subscription
      window.updateOnlineUsers = updateOnlineUsers;

      // Log connection state changes
      presencePusher.connection.bind('state_change', (states) => {
        console.log('[Presence] Connection state changed:', states.previous, '->', states.current);
      });

      presencePusher.connection.bind('error', (err) => {
        console.error('[Presence] Connection error:', err);
      });

      presenceChannel.bind('pusher:subscription_succeeded', (members) => {
        console.log('[Presence] Subscribed to channel:', presenceChannelName);
        console.log('[Presence] My user ID:', members.myID);
        console.log('[Presence] Member count:', members.count);
        console.log('[Presence] All member IDs:', Object.keys(members.members || {}));
        updateOnlineUsers();
      });

      presenceChannel.bind('pusher:subscription_error', (error) => {
        console.error('[Presence] Subscription error:', error);
        console.error('[Presence] Error details:', JSON.stringify(error));
      });

      presenceChannel.bind('pusher:member_added', (member) => {
        console.log('[Presence] Member joined:', member.id, member.info?.name);
        updateOnlineUsers();
      });

      presenceChannel.bind('pusher:member_removed', (member) => {
        console.log('[Presence] Member left:', member.id, member.info?.name);
        updateOnlineUsers();
      });

      // Also subscribe to regular channel for reactions/shoutouts
      const reactionChannelName = `stream-${streamId}`;
      const reactionChannel = statusPusher.subscribe(reactionChannelName);

      reactionChannel.bind('shoutout', (data) => {
        console.log('[Shoutout] Received from Pusher:', data);
        if (typeof window.handleIncomingShoutout === 'function') {
          window.handleIncomingShoutout(data);
        }
      });

      // NOTE: Reaction animations are handled by live-stream.js chatChannel.bind('reaction')
      // to avoid duplicate emoji animations - DO NOT add a handler here

      // Listen for like count updates from all reactions
      reactionChannel.bind('like-update', (data) => {
        console.log('[Reactions] Like count update from Pusher:', data);
        if (data.totalLikes > 0) {
          const likeCountEl = document.getElementById('likeCount');
          const fsLikes = document.getElementById('fsLikes');
          if (likeCountEl) likeCountEl.textContent = data.totalLikes;
          if (fsLikes) fsLikes.textContent = data.totalLikes;
        }
      });

      // Listen for viewer count updates from listeners endpoint (fallback)
      reactionChannel.bind('viewer-update', (data) => {
        console.log('[Viewers] Count update from Pusher:', data);
        if (data.count !== undefined) {
          const viewerEl = document.getElementById('viewerCount');
          const fsViewers = document.getElementById('fsViewers');
          const chatViewers = document.getElementById('chatViewers');
          if (viewerEl) viewerEl.textContent = data.count;
          if (fsViewers) fsViewers.textContent = data.count;
          if (chatViewers) chatViewers.textContent = `${data.count} watching`;
        }
      });

      console.log('[Presence] Subscribed to:', presenceChannelName);
      console.log('[Reactions] Subscribed to:', reactionChannelName);

    } catch (err) {
      console.warn('[LiveStatus] Failed to setup Pusher:', err);
    }
  }

  // Setup live status listener after page load
  setTimeout(setupLiveStatusListener, 1000);
  
  async function checkUserStatus(userId) {
    try {
      const response = await fetch(`/api/get-user-type?uid=${userId}`);
      const result = await response.json();
      
      if (result.success) {
        isLoggedIn = true;
        // Use Firebase Auth displayName first (same as Header.astro)
        const displayName = currentUser?.displayName || result.partnerDisplayName || result.name || 'User';
        userInfo = {
          id: userId,
          name: displayName,
          avatar: result.avatarUrl || currentUser?.photoURL || null,
          isDj: result.roles?.dj === true || result.roles?.artist === true,
          isAdmin: result.isAdmin || false,
          isApproved: result.isApproved || false,
          isPro: result.isPro || result.isAdmin || false
        };

        // Store Pro status globally for live-stream.js to access
        window.userIsPro = userInfo.isPro;
        
        // Update global user info for shoutouts and playlist
        window.currentUserInfo = {
          loggedIn: true,
          name: displayName,
          displayName: displayName,
          id: userId
        };

        // Cache auth state to localStorage for instant restore on page reload
        try {
          localStorage.setItem('fw_auth_cache', JSON.stringify({
            loggedIn: true,
            name: displayName,
            displayName: displayName,
            id: userId,
            avatarUrl: result.avatarUrl || currentUser?.photoURL || '',
            cachedAt: Date.now()
          }));
        } catch (e) { /* Ignore storage errors */ }

        // Re-subscribe to presence channel with correct user info
        // This ensures the user's name shows correctly in the online list
        if (window.presencePusher && window.presenceChannel) {
          const streamId = window.currentStreamId || 'playlist-global';
          const channelName = `presence-stream-${streamId}`;
          console.log('[Presence] Re-subscribing with correct user info:', displayName);

          // Unsubscribe and re-subscribe with correct auth headers
          window.presencePusher.unsubscribe(channelName);

          // Update auth headers
          window.presencePusher.config.auth = {
            headers: {
              'x-user-id': userId,
              'x-user-name': displayName,
              'x-user-avatar': result.avatarUrl || currentUser?.photoURL || ''
            }
          };

          // Re-subscribe
          const newChannel = window.presencePusher.subscribe(channelName);
          window.presenceChannel = newChannel;

          // Re-bind events
          newChannel.bind('pusher:subscription_succeeded', () => {
            console.log('[Presence] Re-subscribed with correct user info');
            if (typeof window.updateOnlineUsers === 'function') {
              window.updateOnlineUsers();
            }
          });
          newChannel.bind('pusher:member_added', () => {
            if (typeof window.updateOnlineUsers === 'function') {
              window.updateOnlineUsers();
            }
          });
          newChannel.bind('pusher:member_removed', () => {
            if (typeof window.updateOnlineUsers === 'function') {
              window.updateOnlineUsers();
            }
          });
        }

        // Dispatch event for components waiting for auth (like PlaylistModal)
        document.dispatchEvent(new CustomEvent('userAuthReady', {
          detail: { user: currentUser, userInfo: window.currentUserInfo }
        }));
        
        const djNameField = document.getElementById('bookingDjName');
        if (djNameField) {
          djNameField.value = displayName;
        }
        
        // Show chat form and playlist button for logged-in users
        document.getElementById('loginPrompt')?.classList.add('hidden');
        document.getElementById('chatForm')?.classList.remove('hidden');
        document.getElementById('playlistBtn')?.classList.remove('hidden');
        
        // Show DJ-only elements for approved DJs and admins
        if ((userInfo.isDj && userInfo.isApproved) || userInfo.isAdmin) {
          document.getElementById('djLobbyBtn')?.classList.remove('hidden');
          document.getElementById('takeoverSection')?.classList.remove('hidden');
          
          // Subscribe to incoming takeover requests
          subscribeToIncomingTakeover();
          setupTakeoverActions();
        }
      }
    } catch (e) {
      console.log('Could not check user status:', e);
    }
  }
  
  // Subscribe to incoming takeover requests (for streaming DJs) - Using Pusher
  async function subscribeToIncomingTakeover() {
    if (!currentUser || !userInfo?.isDj) return;
    
    // Wait for Pusher to be available (loaded by live-stream.js)
    const waitForPusher = () => new Promise((resolve) => {
      if (window.Pusher) return resolve();
      const check = setInterval(() => {
        if (window.Pusher) {
          clearInterval(check);
          resolve();
        }
      }, 100);
      // Timeout after 5 seconds
      setTimeout(() => { clearInterval(check); resolve(); }, 5000);
    });
    
    await waitForPusher();
    
    if (!window.Pusher) {
      console.warn('[Takeover] Pusher not available, falling back to polling');
      // Fallback: poll API every 10 seconds
      setInterval(async () => {
        try {
          const response = await fetch(`/api/dj-lobby/takeover?userId=${currentUser.uid}`);
          const result = await response.json();
          if (result.success && result.incoming?.status === 'pending') {
            showTakeoverNotification(result.incoming);
          } else {
            hideTakeoverNotification();
          }
        } catch (e) { console.warn('[Takeover] Poll error:', e); }
      }, 10000);
      return;
    }
    
    // Subscribe to private channel for takeover notifications
    const PUSHER_KEY = window.PUSHER_CONFIG?.key || '';
    const PUSHER_CLUSTER = window.PUSHER_CONFIG?.cluster || 'eu';
    
    const pusher = new window.Pusher(PUSHER_KEY, {
      cluster: PUSHER_CLUSTER,
      authEndpoint: '/api/dj-lobby/pusher-auth',
      auth: { params: { user_id: currentUser.uid } }
    });
    
    const privateChannel = pusher.subscribe(`private-dj-${currentUser.uid}`);
    
    privateChannel.bind('takeover-request', (data) => {
      console.log('[Takeover] Received request via Pusher:', data);
      showTakeoverNotification(data);
    });
    
    privateChannel.bind('takeover-cancelled', () => {
      hideTakeoverNotification();
    });
    
    console.log('[Takeover] Subscribed to Pusher channel');
  }
  
  function showTakeoverNotification(data) {
    const notification = document.getElementById('incomingTakeoverNotification');
    document.getElementById('incomingTakeoverName').textContent = data.requesterName || 'A DJ';
    document.getElementById('incomingTakeoverAvatar').src = data.requesterAvatar || '/place-holder.webp';
    notification.classList.remove('hidden');
    notification.dataset.requesterId = data.requesterId;
  }
  
  function hideTakeoverNotification() {
    document.getElementById('incomingTakeoverNotification').classList.add('hidden');
  }
  
  // Setup takeover action buttons
  function setupTakeoverActions() {
    document.getElementById('acceptIncomingTakeoverBtn')?.addEventListener('click', async () => {
      const notification = document.getElementById('incomingTakeoverNotification');
      const requesterId = notification.dataset.requesterId;
      
      if (!requesterId || !currentUser) return;
      
      try {
        const token = await currentUser.getIdToken();
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ action: 'getStreamKey', djId: currentUser.uid })
        });
        
        const result = await response.json();
        
        // Send stream key to requester
        await setDoc(doc(firestoreDb, 'djTakeoverRequests', `request_${requesterId}`), {
          status: 'approved',
          requesterId: requesterId,
          serverUrl: result.serverUrl || 'rtmp://rtmp.freshwax.co.uk/live',
          streamKey: result.streamKey || 'Contact admin for key',
          approvedAt: serverTimestamp()
        }, { merge: true });
        
        // Clear the request from my document
        await deleteDoc(doc(firestoreDb, 'djTakeoverRequests', currentUser.uid));
        
        notification.classList.add('hidden');
        alert('Takeover approved! Stream key has been shared.');
      } catch (e) {
        console.error('Accept takeover error:', e);
        alert('Failed to accept takeover');
      }
    });
    
    document.getElementById('declineIncomingTakeoverBtn')?.addEventListener('click', async () => {
      const notification = document.getElementById('incomingTakeoverNotification');
      const requesterId = notification.dataset.requesterId;
      
      if (!requesterId) return;
      
      try {
        // Update requester's document to show declined
        await setDoc(doc(firestoreDb, 'djTakeoverRequests', `request_${requesterId}`), {
          status: 'declined',
          declinedAt: serverTimestamp()
        }, { merge: true });
        
        // Remove from my document
        await deleteDoc(doc(firestoreDb, 'djTakeoverRequests', currentUser.uid));
        
        notification.classList.add('hidden');
      } catch (e) {
        console.error('Decline takeover error:', e);
      }
    });
  }
  
  // OPTIMIZED: Load schedule with caching to reduce API calls
  async function loadSchedule(forceRefresh = false) {
    const now = Date.now();
    
    // Use cache if valid (unless force refresh requested)
    if (!forceRefresh && scheduleCache && (now - scheduleCacheTime) < CACHE_DURATION) {
      allSlots = scheduleCache.slots;
      window.bookedSlots = allSlots; // Expose to regular script for booking form
      renderCalendar();
      renderTodaySchedule();
      updateLiveQueueBar(scheduleCache.currentLive, scheduleCache.upcoming);
      updateListenersList(scheduleCache.listeners || []);
      return;
    }
    
    try {
      const weekEnd = new Date(currentWeekStart);
      weekEnd.setDate(weekEnd.getDate() + 7);
      
      // Add cache buster for force refresh to bypass browser/CDN cache
      const cacheBuster = forceRefresh ? `&_t=${Date.now()}` : '';
      
      // Single API call that returns both schedule and live status
      const response = await fetch(`/api/livestream/slots?start=${currentWeekStart.toISOString()}&end=${weekEnd.toISOString()}${cacheBuster}`);
      const result = await response.json();
      
      if (result.success) {
        allSlots = result.slots || [];
        window.bookedSlots = allSlots; // Expose to regular script for booking form
        
        // Cache the result
        scheduleCache = {
          slots: allSlots,
          currentLive: result.currentLive || null,
          upcoming: result.upcoming || [],
          listeners: result.listeners || []
        };
        scheduleCacheTime = Date.now();
        
        renderCalendar();
        renderTodaySchedule();
        updateLiveQueueBar(result.currentLive, result.upcoming);
        updateListenersList(result.listeners || []);
        
        if (isLoggedIn) {
          checkMyUpcomingSlot();
        }
        
        console.log('[Schedule] Loaded', allSlots.length, 'slots, upcoming:', result.upcoming?.length || 0);
      }
    } catch (e) {
      console.error('Failed to load schedule:', e);
    }
  }
  
  // Update listeners display
  function updateListenersList(listeners) {
    const listenersList = document.getElementById('listenersList');
    const listenerCountBadge = document.getElementById('listenerCountBadge');
    
    if (listenerCountBadge) {
      listenerCountBadge.textContent = listeners.length;
      // Grey out badge if zero
      if (listeners.length === 0) {
        listenerCountBadge.style.background = '#9ca3af';
      } else {
        listenerCountBadge.style.background = '#dc2626';
      }
    }
    
    if (listenersList) {
      if (listeners.length > 0) {
        listenersList.innerHTML = listeners.map(listener => `
          <div class="listener-item">
            <img class="listener-avatar" src="${listener.avatar || '/place-holder.webp'}" alt="" onerror="this.src='/place-holder.webp'" />
            <span class="listener-name">${listener.name}</span>
          </div>
        `).join('');
      } else {
        listenersList.innerHTML = '<span class="empty-message">No one listening yet</span>';
      }
    }
  }
  
  // Session ID for anonymous viewer tracking
  function getOrCreateSessionId() {
    let sessionId = sessionStorage.getItem('viewerSessionId');
    if (!sessionId) {
      sessionId = 'anon_' + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);
      sessionStorage.setItem('viewerSessionId', sessionId);
    }
    return sessionId;
  }

  // Register view and trigger viewer count broadcast
  // This calls the listeners endpoint which broadcasts viewer-update via Pusher
  async function registerStreamView() {
    const streamId = window.currentStreamId || document.body.dataset.streamId || 'playlist-global';
    if (!streamId) return;

    try {
      // Register as viewer - this triggers a Pusher broadcast with current viewer count
      const resp = await fetch('/api/livestream/listeners', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'join',
          streamId,
          userId: currentUser?.uid || getOrCreateSessionId(),
          userName: userInfo?.name || 'Viewer'
        })
      });
      const data = await resp.json();
      console.log('[Viewers] Registered, active viewers:', data.activeViewers);

      // Update viewer count immediately from response
      if (data.activeViewers !== undefined) {
        const viewerEl = document.getElementById('viewerCount');
        const fsViewers = document.getElementById('fsViewers');
        const chatViewers = document.getElementById('chatViewers');
        if (viewerEl) viewerEl.textContent = data.activeViewers;
        if (fsViewers) fsViewers.textContent = data.activeViewers;
        if (chatViewers) chatViewers.textContent = `${data.activeViewers} watching`;
      }
    } catch (e) {
      console.warn('[Viewers] Registration failed:', e);
    }
  }

  // Heartbeat interval for viewer tracking
  let heartbeatInterval = null;

  // Register view on page load and start heartbeat
  function startListenerHeartbeat() {
    // Ensure we have a stream ID - default to playlist-global if none set
    if (!window.currentStreamId) {
      window.currentStreamId = 'playlist-global';
    }

    // Register immediately
    registerStreamView();

    // Send heartbeat every 60 seconds to keep viewer count accurate
    // This is less frequent than before (was 30s) to reduce Firebase writes
    heartbeatInterval = setInterval(async () => {
      const streamId = window.currentStreamId || 'playlist-global';
      try {
        await fetch('/api/livestream/listeners', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'heartbeat',
            streamId,
            userId: currentUser?.uid || getOrCreateSessionId(),
            userName: userInfo?.name || 'Viewer'
          })
        });
      } catch (e) { /* silent */ }
    }, 60000); // Every 60 seconds
  }

  // Clean up heartbeat on page unload
  function stopListenerHeartbeat() {
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
      heartbeatInterval = null;
    }
    // Send leave notification
    const streamId = window.currentStreamId || 'playlist-global';
    navigator.sendBeacon('/api/livestream/listeners', JSON.stringify({
      action: 'leave',
      streamId,
      userId: currentUser?.uid || getOrCreateSessionId()
    }));
  }

  // Start heartbeat for all viewers (logged in or anonymous)
  startListenerHeartbeat();

  // Clean up on page unload
  window.addEventListener('beforeunload', stopListenerHeartbeat);
  
  function checkMyUpcomingSlot() {
    if (!currentUser || !allSlots.length) return;
    
    const now = new Date();
    const mySlots = allSlots.filter(s => 
      s.djId === currentUser.uid && 
      new Date(s.startTime) > now &&
      ['scheduled', 'in_lobby', 'queued'].includes(s.status)
    );
    
    if (mySlots.length > 0) {
      myUpcomingSlot = mySlots[0];
      const startTime = new Date(myUpcomingSlot.startTime);
      const minsUntil = Math.floor((startTime - now) / 60000);
      
      // Show lobby panel if within 30 mins
      if (minsUntil <= 30 && myUpcomingSlot.status !== 'in_lobby') {
        showLobbyPanel(myUpcomingSlot);
      }
    }
  }
  
  function showLobbyPanel(slot) {
    const panel = document.getElementById('lobbyPanel');
    if (!panel) return;
    
    // Reset lobby state when entering
    resetLobbyState();
    
    panel.classList.remove('hidden');
    document.getElementById('lobbySlotTime').textContent = `${formatTime(slot.startTime)} - ${formatTime(slot.endTime)}`;
    document.getElementById('lobbyStreamKey').textContent = slot.streamKey || 'Loading...';
    
    updateLobbyCountdown(slot);
    
    // Check if someone is currently live and show takeover option
    checkForTakeoverOption(slot);
  }
  
  // Check if there's a live stream that can be taken over
  async function checkForTakeoverOption(mySlot) {
    const takeoverSection = document.getElementById('takeoverSection');
    if (!takeoverSection) return;
    
    // Only show takeover option for approved DJs
    if (!(userInfo?.isDj && userInfo?.isApproved) && !userInfo?.isAdmin) {
      takeoverSection.classList.add('hidden');
      return;
    }
    
    try {
      const response = await fetch('/api/livestream/slots');
      const result = await response.json();
      
      if (!result.success) return;
      
      // Find currently live slot
      const now = Date.now();
      const liveSlot = result.slots?.find(s => 
        s.status === 'live' && 
        new Date(s.endTime).getTime() > now &&
        s.djId !== currentUser?.uid // Not my own slot
      );
      
      if (liveSlot) {
        // Show takeover section
        takeoverSection.classList.remove('hidden');
        document.getElementById('takeoverDjName').textContent = liveSlot.djName;
        document.getElementById('takeoverDjAvatar').src = liveSlot.djAvatar || '/place-holder.webp';
        
        // Store live slot ID for takeover request
        takeoverSection.dataset.slotId = liveSlot.id;
        
        // Check if we already have a pending request
        if (liveSlot.takeoverRequest?.requesterId === currentUser?.uid && 
            liveSlot.takeoverRequest?.status === 'pending') {
          showTakeoverPending();
        }
      } else {
        takeoverSection.classList.add('hidden');
      }
    } catch (error) {
      console.error('Error checking for takeover option:', error);
    }
  }
  
  let takeoverPollInterval = null;
  
  function showTakeoverPending() {
    document.getElementById('requestTakeoverBtn')?.classList.add('hidden');
    document.getElementById('takeoverPending')?.classList.remove('hidden');
    document.getElementById('takeoverApproved')?.classList.add('hidden');
    
    // Start polling for approval
    startTakeoverPolling();
  }
  
  function hideTakeoverPending() {
    document.getElementById('requestTakeoverBtn')?.classList.remove('hidden');
    document.getElementById('takeoverPending')?.classList.add('hidden');
    document.getElementById('takeoverApproved')?.classList.add('hidden');
    
    // Stop polling
    stopTakeoverPolling();
  }
  
  function showTakeoverApproved(streamKey) {
    document.getElementById('requestTakeoverBtn')?.classList.add('hidden');
    document.getElementById('takeoverPending')?.classList.add('hidden');
    document.getElementById('takeoverApproved')?.classList.remove('hidden');
    document.getElementById('takeoverStreamKey').textContent = streamKey;
    
    // Stop polling
    stopTakeoverPolling();
  }
  
  function startTakeoverPolling() {
    if (takeoverPollInterval) return;
    
    takeoverPollInterval = setInterval(async () => {
      const takeoverSection = document.getElementById('takeoverSection');
      const slotId = takeoverSection?.dataset.slotId;
      
      if (!slotId || !currentUser) {
        stopTakeoverPolling();
        return;
      }
      
      try {
        // Check if takeover was approved
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'getStreamKey',
            slotId,
            djId: currentUser.uid
          })
        });
        
        const result = await response.json();
        
        if (result.success && result.streamKey) {
          // Takeover was approved! Show the key
          showTakeoverApproved(result.streamKey);
        }
      } catch (error) {
        console.error('Error polling takeover status:', error);
      }
    }, 3000); // Poll every 3 seconds
  }
  
  function stopTakeoverPolling() {
    if (takeoverPollInterval) {
      clearInterval(takeoverPollInterval);
      takeoverPollInterval = null;
    }
  }
  
  // Copy takeover key
  window.copyTakeoverKey = function() {
    const key = document.getElementById('takeoverStreamKey')?.textContent;
    if (key && key !== '-') {
      navigator.clipboard.writeText(key);
      showCopyFeedback('Stream key copied!');
    }
  };
  
  // Copy functions for lobby
  window.copyLobbyStreamKey = function() {
    const key = document.getElementById('lobbyStreamKey')?.textContent;
    if (key && key !== '-' && key !== 'Loading...') {
      navigator.clipboard.writeText(key);
      showCopyFeedback('Stream key copied!');
    }
  };
  
  window.copyRtmpUrl = function() {
    navigator.clipboard.writeText('rtmp://rtmp.freshwax.co.uk/live');
    showCopyFeedback('RTMP URL copied!');
  };
  
  function showCopyFeedback(msg) {
    const statusMsg = document.getElementById('lobbyStatusMsg');
    if (statusMsg) {
      statusMsg.textContent = msg;
      statusMsg.style.background = '#10b981';
      statusMsg.style.color = '#fff';
      statusMsg.classList.remove('hidden');
      setTimeout(() => statusMsg.classList.add('hidden'), 2000);
    }
  }
  
  // Request takeover button handler
  document.getElementById('requestTakeoverBtn')?.addEventListener('click', async () => {
    const takeoverSection = document.getElementById('takeoverSection');
    const slotId = takeoverSection?.dataset.slotId;
    
    if (!slotId || !currentUser) {
      alert('Please log in to request a takeover');
      return;
    }
    
    const btn = document.getElementById('requestTakeoverBtn');
    btn.disabled = true;
    btn.innerHTML = '<span>‚è≥ Sending request...</span>';
    
    try {
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'requestTakeover',
          slotId,
          requesterId: currentUser.uid,
          requesterName: userInfo?.name || userInfo?.displayName || 'DJ',
          requesterAvatar: userInfo?.avatarUrl || null
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        showTakeoverPending();
      } else {
        alert(result.error || 'Failed to send takeover request');
        btn.disabled = false;
        btn.innerHTML = '<span>üéß Request Takeover</span>';
      }
    } catch (error) {
      console.error('Error requesting takeover:', error);
      alert('Failed to send takeover request');
      btn.disabled = false;
      btn.innerHTML = '<span>üéß Request Takeover</span>';
    }
  });
  
  // Cancel takeover request button handler
  document.getElementById('cancelTakeoverBtn')?.addEventListener('click', async () => {
    const takeoverSection = document.getElementById('takeoverSection');
    const slotId = takeoverSection?.dataset.slotId;
    
    if (!slotId || !currentUser) return;
    
    // Stop polling immediately
    stopTakeoverPolling();
    
    try {
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancelTakeoverRequest',
          slotId,
          requesterId: currentUser.uid
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        hideTakeoverPending();
      } else {
        alert(result.error || 'Failed to cancel request');
        // Restart polling if cancel failed
        startTakeoverPolling();
      }
    } catch (error) {
      console.error('Error cancelling takeover:', error);
      startTakeoverPolling();
    }
  });
  
  // DJ Ready state
  let isDjReady = false;
  let slotExpired = false;
  const GRACE_PERIOD_SECONDS = 180; // 3 minutes
  
  function updateLobbyCountdown(slot) {
    const countdown = document.getElementById('lobbyCountdownBig');
    const countdownLabel = document.getElementById('lobbyCountdownLabel');
    const goLiveBtn = document.getElementById('goLiveBtn');
    const readyBtn = document.getElementById('readyBtn');
    const gracePeriod = document.getElementById('lobbyGracePeriod');
    const graceCountdown = document.getElementById('graceCountdown');
    const slotAvailable = document.getElementById('slotAvailableSection');
    
    const update = () => {
      const now = new Date();
      const start = new Date(slot.startTime);
      const secsUntilStart = Math.floor((start - now) / 1000);
      
      // Before start time
      if (secsUntilStart > 0) {
        gracePeriod?.classList.add('hidden');
        slotAvailable?.classList.add('hidden');
        
        const mins = Math.floor(secsUntilStart / 60);
        const s = secsUntilStart % 60;
        countdown.textContent = `${mins}:${s.toString().padStart(2, '0')}`;
        if (countdownLabel) countdownLabel.textContent = 'Time until live:';
        
        // Enable go live 2 mins before if ready
        if (isDjReady && secsUntilStart <= 120) {
          goLiveBtn.disabled = false;
        } else {
          goLiveBtn.disabled = true;
        }
        
        setTimeout(update, 1000);
        return;
      }
      
      // After start time - check grace period
      const secsLate = Math.abs(secsUntilStart);
      const graceRemaining = GRACE_PERIOD_SECONDS - secsLate;
      
      if (graceRemaining > 0 && !isDjReady && !slotExpired) {
        // In grace period - DJ is late but can still claim
        countdown.textContent = 'LATE';
        if (countdownLabel) countdownLabel.textContent = 'Your slot started!';
        gracePeriod?.classList.remove('hidden');
        slotAvailable?.classList.add('hidden');
        
        const gMins = Math.floor(graceRemaining / 60);
        const gSecs = graceRemaining % 60;
        if (graceCountdown) {
          graceCountdown.textContent = `${gMins}:${gSecs.toString().padStart(2, '0')}`;
        }
        
        // DJ can still press ready and go live
        goLiveBtn.disabled = !isDjReady;
        
        setTimeout(update, 1000);
        return;
      }
      
      if (isDjReady) {
        // DJ is ready - can go live
        countdown.textContent = 'NOW!';
        if (countdownLabel) countdownLabel.textContent = 'You\'re ready!';
        gracePeriod?.classList.add('hidden');
        slotAvailable?.classList.add('hidden');
        goLiveBtn.disabled = false;
        readyBtn?.classList.add('hidden');
        return;
      }
      
      // Grace period expired - slot is up for grabs
      if (!slotExpired) {
        slotExpired = true;
        handleSlotExpired(slot);
      }
      
      countdown.textContent = 'EXPIRED';
      if (countdownLabel) countdownLabel.textContent = 'Slot forfeited';
      gracePeriod?.classList.add('hidden');
      goLiveBtn.disabled = true;
      readyBtn?.classList.add('hidden');
      
      // Show slot available for others (but not for the late DJ)
      // The late DJ sees their slot is forfeited
    };
    
    update();
  }
  
  function handleSlotExpired(slot) {
    console.log('[Lobby] Slot expired for DJ:', slot.djName);
    
    // Notify server that slot is available for takeover
    notifySlotAvailable(slot.id);
  }
  
  async function notifySlotAvailable(slotId) {
    try {
      const token = await currentUser?.getIdToken();
      await fetch('/api/livestream/manage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'slot_expired',
          slotId,
          token
        })
      });
    } catch (err) {
      console.error('Failed to notify slot expiry:', err);
    }
  }
  
  function setDjReady() {
    isDjReady = true;
    
    const readyBtn = document.getElementById('readyBtn');
    const readyIndicator = document.getElementById('readyIndicator');
    const readyStatusText = document.getElementById('readyStatusText');
    const goLiveBtn = document.getElementById('goLiveBtn');
    const gracePeriod = document.getElementById('lobbyGracePeriod');
    
    if (readyBtn) {
      readyBtn.classList.add('is-ready');
      readyBtn.textContent = 'Ready!';
      readyBtn.disabled = true;
    }
    
    if (readyIndicator) {
      readyIndicator.classList.add('is-ready');
    }
    
    if (readyStatusText) {
      readyStatusText.textContent = 'Ready to go live';
    }
    
    // Hide grace period warning if it was showing
    gracePeriod?.classList.add('hidden');
    
    // Enable go live if start time has passed or is within 2 mins
    if (myUpcomingSlot) {
      const now = new Date();
      const start = new Date(myUpcomingSlot.startTime);
      const secsUntil = Math.floor((start - now) / 1000);
      
      if (secsUntil <= 120) {
        goLiveBtn.disabled = false;
      }
    }
    
    // Notify server that DJ is ready
    notifyDjReady();
  }
  
  async function notifyDjReady() {
    if (!myUpcomingSlot || !currentUser) return;
    
    try {
      const token = await currentUser.getIdToken();
      await fetch('/api/livestream/manage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'dj_ready',
          slotId: myUpcomingSlot.id,
          token
        })
      });
      console.log('[Lobby] DJ marked as ready');
    } catch (err) {
      console.error('Failed to notify ready status:', err);
    }
  }
  
  // Ready button click handler
  document.getElementById('readyBtn')?.addEventListener('click', setDjReady);
  
  // Reset ready state when entering lobby
  function resetLobbyState() {
    isDjReady = false;
    slotExpired = false;
    
    const readyBtn = document.getElementById('readyBtn');
    const readyIndicator = document.getElementById('readyIndicator');
    const readyStatusText = document.getElementById('readyStatusText');
    
    if (readyBtn) {
      readyBtn.classList.remove('is-ready', 'hidden');
      readyBtn.textContent = '‚úì Ready';
      readyBtn.disabled = false;
    }
    
    if (readyIndicator) {
      readyIndicator.classList.remove('is-ready');
    }
    
    if (readyStatusText) {
      readyStatusText.textContent = 'Not Ready';
    }
    
    document.getElementById('lobbyGracePeriod')?.classList.add('hidden');
    document.getElementById('slotAvailableSection')?.classList.add('hidden');
  }
  
  function renderCalendar() {
    const grid = document.getElementById('calendarGrid');
    if (!grid) return;
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    let html = '';
    for (let i = 0; i < 7; i++) {
      const date = new Date(currentWeekStart);
      date.setDate(date.getDate() + i);
      
      const isToday = date.getTime() === today.getTime();
      const dateStr = date.toISOString().split('T')[0];
      
      const daySlots = allSlots.filter(s => s.startTime.startsWith(dateStr));
      
      html += `<div class="cal-day${isToday ? ' today' : ''}">
        <div class="cal-day-header">
          <span class="cal-day-name">${dayNames[i]}</span>
          <span class="cal-day-num">${date.getDate()}</span>
        </div>
        <div class="cal-slots">`;
      
      daySlots.slice(0, 3).forEach(slot => {
        const isMySlot = currentUser && slot.djId === currentUser.uid;
        const isLive = slot.status === 'live';
        html += `<div class="cal-slot${isMySlot ? ' my-slot' : ''}${isLive ? ' live' : ''}"><span class="cal-time">${formatTime(slot.startTime)}</span> <span class="cal-dj">${slot.djName}</span></div>`;
      });
      
      if (daySlots.length > 3) {
        html += `<div class="cal-slot">+${daySlots.length - 3} more</div>`;
      }
      
      html += '</div></div>';
    }
    
    grid.innerHTML = html;
    
    // Update week label
    const weekLabel = document.getElementById('weekLabel');
    if (weekLabel) {
      const endDate = new Date(currentWeekStart);
      endDate.setDate(endDate.getDate() + 6);
      weekLabel.textContent = `${formatDate(currentWeekStart.toISOString())} - ${formatDate(endDate.toISOString())}`;
    }
  }
  
  function renderTodaySchedule() {
    const list = document.getElementById('scheduleList');
    if (!list) return;

    const now = new Date();
    const today = now.toISOString().split('T')[0];

    // Filter to today's slots that are current or future (not completed/cancelled shows)
    let todaySlots = allSlots.filter(s => {
      if (!s.startTime.startsWith(today)) return false;
      if (s.status === 'cancelled' || s.status === 'completed') return false;

      // Hide expired slots (endTime has passed) unless currently live
      const endTime = new Date(s.endTime);
      if (endTime < now && s.status !== 'live') return false;

      // Show if live, scheduled, in_lobby, or queued
      return ['live', 'scheduled', 'in_lobby', 'queued'].includes(s.status);
    });

    // Include current live relay stream if not already in slots list
    // Check both scheduleCache and live-stream.js global state for relay streams
    const currentLive = scheduleCache?.currentLive || window.liveStreamState?.currentStream;
    if (currentLive && currentLive.isRelay && !todaySlots.find(s => s.id === currentLive.id || s.id === currentLive.slotId)) {
      todaySlots.unshift({
        id: currentLive.id || currentLive.slotId,
        djName: currentLive.djName,
        title: currentLive.title,
        startTime: currentLive.startTime || currentLive.startedAt,
        endTime: currentLive.endTime,
        status: 'live',
        isRelay: true
      });
    }

    // Sort by start time
    todaySlots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));

    if (todaySlots.length === 0) {
      list.innerHTML = '<p class="empty-message">No upcoming shows today</p>';
      return;
    }
    
    list.innerHTML = todaySlots.map(slot => {
      const isMySlot = currentUser && slot.djId === currentUser.uid;
      const isLive = slot.status === 'live';
      const isRelay = slot.isRelay === true;
      const durationMins = Math.round((new Date(slot.endTime) - new Date(slot.startTime)) / 60000);

      // Format duration nicely: "1 hour", "2 hours", "1.5 hours", or "30 mins"
      let durationText;
      if (durationMins >= 60) {
        const hours = durationMins / 60;
        if (hours === Math.floor(hours)) {
          durationText = hours === 1 ? '1 hour' : `${hours} hours`;
        } else {
          durationText = `${hours.toFixed(1)} hours`;
        }
      } else {
        durationText = `${durationMins} mins`;
      }

      // Format status text
      let statusText = slot.status;
      if (slot.status === 'in_lobby') statusText = 'In Lobby';
      else if (slot.status === 'queued') statusText = 'Queued';
      else if (slot.status === 'scheduled') statusText = 'Scheduled';
      else if (slot.status === 'live') statusText = 'LIVE';

      // For relay streams, show title as main name (not DJ name)
      const displayName = isRelay ? (slot.title || 'Relay Stream') : slot.djName;
      const showTitle = !isRelay && slot.title && slot.title !== slot.djName;

      return `<div class="schedule-item${isMySlot ? ' my-slot' : ''}${isLive ? ' live' : ''}${isRelay ? ' relay' : ''}">
        ${isLive ? '<span class="live-headphone-icon">üéß</span>' : ''}
        <div class="schedule-dj-info">
          <div class="schedule-dj-header">
            <h4>${displayName}</h4>
          </div>
          ${showTitle ? `<span class="schedule-title">${slot.title}</span>` : ''}
          <div class="schedule-times">
            <span class="schedule-time-range">${formatTime(slot.startTime)} - ${formatTime(slot.endTime)}</span>
          </div>
        </div>
        ${isMySlot && (slot.status === 'scheduled' || slot.status === 'queued') ? `<button class="cancel-slot-btn" onclick="cancelSlot('${slot.id}')">√ó</button>` : ''}
      </div>`;
    }).join('');
  }

  // Expose for live-stream.js to call when relay stream detected
  window.renderTodaySchedule = renderTodaySchedule;

  function updateLiveQueueBar(currentLive, upcoming) {
    const liveStatusCard = document.getElementById('liveStatusCard');
    const liveIndicator = document.getElementById('liveIndicator');
    const liveIndicatorText = document.getElementById('liveIndicatorText');
    const liveDjAvatarCard = document.getElementById('liveDjAvatarCard');
    const liveDjNameCard = document.getElementById('liveDjNameCard');
    const liveDjEndsCard = document.getElementById('liveDjEndsCard');
    const queueListCard = document.getElementById('queueListCard');

    const streamInfoBar = document.getElementById('streamInfoBar');
    const liveBadge = document.getElementById('liveBadge');
    const liveStatusText = document.getElementById('liveStatusText');
    const streamTitle = document.getElementById('streamTitle');
    const djAvatar = document.getElementById('djAvatar');

    const offlineOverlay = document.getElementById('offlineOverlay');
    const countdownOverlay = document.getElementById('countdownOverlay');
    const playBtn = document.getElementById('playBtn');

    // Clear loading state on first data received
    liveBadge?.classList.remove('is-loading');
    offlineOverlay?.classList.remove('is-loading');
    const offlineIconText = document.getElementById('offlineIconText');
    const offlineMainText = document.getElementById('offlineMainText');
    const offlineSubText = document.getElementById('offlineSubText');
    
    // Track live status changes for chat clear timer and playlist fallback
    // If live-stream.js already detected an active stream, don't override with slots API data
    // This handles audio-only/BUTT streams where slots API returns currentLive: null
    if (!currentLive && window.isLiveStreamActive) {
      console.log('[Schedule] Skipping offline state - live-stream.js detected active stream');
      return;
    }

    const isLiveNow = !!currentLive;
    if (wasLive && !isLiveNow) {
      // Stream just ended - schedule chat clear and playlist fallback
      scheduleChatClear();
      schedulePlaylistFallback();
    } else if (!wasLive && isLiveNow) {
      // Stream just started - cancel timers and pause playlist
      cancelChatClear();
      cancelPlaylistFallback();
      pausePlaylistForStream();
      window.isLiveStreamActive = true;
    }
    wasLive = isLiveNow;
    
    if (currentLive) {
      // Set the stream ID for viewer tracking
      window.currentStreamId = currentLive.slotId || currentLive.id || 'live-stream';

      liveStatusCard?.classList.add('is-live');
      liveIndicator?.classList.add('is-live');
      if (liveIndicatorText) liveIndicatorText.textContent = 'NOW LIVE';

      // Use logged-in user's avatar if they are the DJ streaming (same source as header)
      // Otherwise fall back to the avatar stored in the slot data
      // For relay streams, always use placeholder
      const isCurrentUserDj = currentUser?.uid && currentLive.djId === currentUser.uid;
      const avatarToUse = currentLive.isRelay
        ? '/place-holder.webp'
        : (isCurrentUserDj && userInfo?.avatar ? userInfo.avatar : (currentLive.djAvatar || '/place-holder.webp'));

      if (liveDjAvatarCard) liveDjAvatarCard.src = avatarToUse;
      // For relay streams, show title instead of DJ name
      if (liveDjNameCard) liveDjNameCard.textContent = currentLive.isRelay ? (currentLive.title || 'Relay Stream') : currentLive.djName;
      if (liveDjEndsCard) liveDjEndsCard.textContent = `Ends ${formatTime(currentLive.endTime)}`;

      streamInfoBar?.classList.add('is-live');
      liveBadge?.classList.add('is-live');
      // Grey out playlist button when livestream is active
      const playlistBtn = document.getElementById('playlistBtn');
      if (playlistBtn) playlistBtn.classList.add('livestream-active');
      // Hide status text when live and show "On Air"
      if (liveStatusText) liveStatusText.classList.add('hidden');
      const onAirText = document.getElementById('onAirText');
      if (onAirText) onAirText.classList.remove('hidden');
      if (streamTitle) streamTitle.innerHTML = '<span class="title-live">LIVE</span> <span class="title-session">SESSION</span>';
      if (djAvatar) djAvatar.src = avatarToUse;

      // Update controls DJ info bar
      const controlsDjName = document.getElementById('controlsDjName');
      const controlsSetTitle = document.getElementById('controlsSetTitle');
      const djInfoBar = document.querySelector('.dj-info-bar');
      // For relay streams, show title (now playing) instead of DJ name, in red
      if (controlsDjName) {
        if (currentLive.isRelay && currentLive.title) {
          controlsDjName.innerHTML = `<span style="color: #ef4444;">${currentLive.title}</span>`;
        } else {
          controlsDjName.textContent = currentLive.djName || 'DJ';
        }
      }
      if (controlsSetTitle) controlsSetTitle.textContent = currentLive.title || 'Live Set';
      if (djInfoBar) djInfoBar.classList.add('is-live');

      offlineOverlay?.classList.add('hidden');
      countdownOverlay?.classList.add('hidden');
      if (playBtn) playBtn.disabled = false;

      // Activate share button when live
      const shareBtn = document.getElementById('shareBtn');
      if (shareBtn) {
        shareBtn.classList.add('live-active');
      }

      // Update share preview
      if (window.updateSharePreview) {
        window.updateSharePreview(currentLive.djName, avatarToUse, currentLive.crew);
      }
    } else {
      liveStatusCard?.classList.remove('is-live');
      liveIndicator?.classList.remove('is-live');
      if (liveIndicatorText) liveIndicatorText.textContent = 'OFFLINE';
      if (liveDjAvatarCard) liveDjAvatarCard.src = '/place-holder.webp';
      if (liveDjNameCard) liveDjNameCard.textContent = 'No one streaming';
      if (liveDjEndsCard) liveDjEndsCard.textContent = 'Check back soon';
      
      streamInfoBar?.classList.remove('is-live');
      liveBadge?.classList.remove('is-live');
      // Re-enable playlist button when offline
      const playlistBtnOff = document.getElementById('playlistBtn');
      if (playlistBtnOff) playlistBtnOff.classList.remove('livestream-active');
      // Show "OFFLINE" and hide "On Air"
      if (liveStatusText) {
        liveStatusText.textContent = 'OFFLINE';
        liveStatusText.classList.remove('hidden');
      }
      const onAirTextOff = document.getElementById('onAirText');
      if (onAirTextOff) onAirTextOff.classList.add('hidden');
      if (streamTitle) streamTitle.innerHTML = '<span class="title-live">LIVE</span> <span class="title-session">SESSION</span>';
      if (djAvatar) djAvatar.src = '/place-holder.webp';
      
      // Update controls DJ info bar to offline state (only if playlist isn't playing)
      const controlsDjName = document.getElementById('controlsDjName');
      const controlsSetTitle = document.getElementById('controlsSetTitle');
      const djInfoBar = document.querySelector('.dj-info-bar');
      const playlistIsPlaying = window.playlistManager?.isPlaying;
      if (!playlistIsPlaying) {
        if (controlsDjName) controlsDjName.textContent = '--';
        if (controlsSetTitle) controlsSetTitle.textContent = 'Waiting for stream...';
      }
      if (djInfoBar) djInfoBar.classList.remove('is-live');

      // Only disable play button if playlist is NOT active
      // This prevents the button from being greyed out during tab switching when playlist is playing
      if (playBtn && !window.isPlaylistActive && !playlistIsPlaying) {
        playBtn.disabled = true;
      }

      // Deactivate share button when offline
      const shareBtn = document.getElementById('shareBtn');
      if (shareBtn) {
        shareBtn.classList.remove('live-active');
      }
      
      // Mark stream as inactive
      window.isLiveStreamActive = false;

      // Check for countdown
      const inLobby = upcoming?.filter(s => s.status === 'in_lobby') || [];
      if (inLobby.length > 0) {
        showCountdown(inLobby[0]);
      } else {
        // No countdown - try to start playlist, or show offline overlay
        countdownOverlay?.classList.add('hidden');

        // Check if playlist is playing or can auto-start
        const playlistManager = window.playlistManager;
        if (playlistManager?.isPlaying && playlistManager?.queue?.length > 0) {
          // Playlist is already playing - hide offline overlay
          offlineOverlay?.classList.add('hidden');
        } else if (!playlistFallbackTimer) {
          // No timer running and not playing - schedule fallback
          // (uses a short delay on initial load to avoid race conditions)
          schedulePlaylistFallback();
        }

        // Show offline overlay if playlist isn't covering it
        if (!playlistManager?.isPlaying) {
          offlineOverlay?.classList.remove('hidden');
          // Update offline overlay text from loading state
          if (offlineIconText) offlineIconText.textContent = 'OFFLINE';
          if (offlineMainText) offlineMainText.textContent = 'No one is streaming right now';
          if (offlineSubText) offlineSubText.textContent = 'The playlist will start in a moment';
        }
      }
    }
    
    // Update queue - show all upcoming slots (scheduled, queued, in_lobby)
    const upcomingSlots = upcoming?.filter(s => 
      ['scheduled', 'queued', 'in_lobby'].includes(s.status)
    ).sort((a, b) => new Date(a.startTime) - new Date(b.startTime)) || [];
    
    if (queueListCard) {
      if (upcomingSlots.length > 0) {
        queueListCard.innerHTML = upcomingSlots.slice(0, 5).map(slot => {
          const statusBadge = slot.status === 'in_lobby' ? 
            '<span class="status-badge lobby">LOBBY</span>' : 
            slot.status === 'queued' ?
            '<span class="status-badge queued">QUEUED</span>' :
            '';
          return `<div class="queue-item">
            <span>${slot.djName}${statusBadge}</span>
            <span class="queue-time">${formatTime(slot.startTime)}</span>
          </div>`;
        }).join('');
      } else {
        queueListCard.innerHTML = '<span class="empty-message">No upcoming DJs</span>';
      }
    }
  }
  
  let countdownInterval = null;
  
  function showCountdown(nextDj) {
    const offlineOverlay = document.getElementById('offlineOverlay');
    const countdownOverlay = document.getElementById('countdownOverlay');
    const countdownDjAvatar = document.getElementById('countdownDjAvatar');
    const countdownDjName = document.getElementById('countdownDjName');

    offlineOverlay?.classList.add('hidden');
    countdownOverlay?.classList.remove('hidden');

    // Use logged-in user's avatar if they are the next DJ (same source as header)
    const isCurrentUserNextDj = currentUser?.uid && nextDj.djId === currentUser.uid;
    const countdownAvatarUrl = isCurrentUserNextDj && userInfo?.avatar
      ? userInfo.avatar
      : (nextDj.djAvatar || '/place-holder.webp');

    if (countdownDjAvatar) countdownDjAvatar.src = countdownAvatarUrl;
    if (countdownDjName) countdownDjName.textContent = nextDj.djName;
    
    if (countdownInterval) clearInterval(countdownInterval);
    
    const startTime = new Date(nextDj.startTime);
    
    countdownInterval = setInterval(() => {
      const now = new Date();
      const secs = Math.floor((startTime - now) / 1000);
      
      if (secs <= 0) {
        clearInterval(countdownInterval);
        scheduleCache = null;
        loadSchedule(true); // Force refresh when DJ should go live
        return;
      }
      
      const mins = Math.floor(secs / 60);
      const s = secs % 60;
      
      const countdownTime = document.getElementById('countdownTime');
      if (countdownTime) countdownTime.textContent = `${mins}:${s.toString().padStart(2, '0')}`;
      
      const progress = document.getElementById('countdownProgress');
      if (progress) progress.style.width = `${(secs / 60) * 100}%`;
    }, 1000);
  }
  
  // Calendar navigation
  document.getElementById('prevWeek')?.addEventListener('click', () => {
    currentWeekStart.setDate(currentWeekStart.getDate() - 7);
    scheduleCache = null; // Invalidate cache for new week
    loadSchedule();
  });
  
  document.getElementById('nextWeek')?.addEventListener('click', () => {
    currentWeekStart.setDate(currentWeekStart.getDate() + 7);
    scheduleCache = null;
    loadSchedule();
  });
  
  // Booking form submit - needs to be in module for currentUser access
  document.getElementById('bookingForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const submitBtn = document.getElementById('submitBooking');
    const errorDiv = document.getElementById('bookingError');
    
    // Check if logged in first
    if (!currentUser) {
      errorDiv.textContent = 'Please sign in to book a slot';
      errorDiv.classList.remove('hidden');
      
      // Show login link
      setTimeout(() => {
        window.location.href = '/login?redirect=/live';
      }, 1500);
      return;
    }
    
    const djName = document.getElementById('bookingDjName').value.trim();
    const crew = document.getElementById('bookingCrew')?.value.trim() || '';
    const description = document.getElementById('bookingDescription')?.value.trim() || '';
    const duration = document.querySelector('input[name="duration"]:checked')?.value || '60';
    
    // Check if queue mode
    const isQueueMode = document.getElementById('bookingTypeQueue')?.classList.contains('active');
    
    if (!djName) {
      errorDiv.textContent = 'Please enter your DJ name';
      errorDiv.classList.remove('hidden');
      return;
    }
    
    if (!isQueueMode) {
      const date = document.getElementById('bookingDate').value;
      const time = document.getElementById('bookingTime').value;
      
      if (!date || !time) {
        errorDiv.textContent = 'Please select a date and time';
        errorDiv.classList.remove('hidden');
        return;
      }
    }
    
    submitBtn.disabled = true;
    submitBtn.textContent = isQueueMode ? 'Joining Queue...' : 'Booking...';
    errorDiv.classList.add('hidden');

    try {
      // Fetch latest avatar URL before booking
      let freshAvatarUrl = userInfo?.avatar || null;
      try {
        const userTypeRes = await fetch(`/api/get-user-type?uid=${currentUser.uid}`);
        const userTypeData = await userTypeRes.json();
        if (userTypeData.success && userTypeData.avatarUrl) {
          freshAvatarUrl = userTypeData.avatarUrl;
          // Update cached userInfo
          if (userInfo) userInfo.avatar = freshAvatarUrl;
        }
      } catch (e) {
        console.log('[Booking] Could not fetch fresh avatar:', e);
      }

      const token = await currentUser.getIdToken();

      let requestBody;

      if (isQueueMode) {
        // Queue mode - play after next DJ
        requestBody = {
          action: 'queue',
          djId: currentUser.uid,
          djName,
          djAvatar: freshAvatarUrl,
          crew: crew || null,
          representing: null,
          description: description || null,
          duration: parseInt(duration),
          token
        };
      } else {
        // Schedule mode - specific date/time
        const date = document.getElementById('bookingDate').value;
        const time = document.getElementById('bookingTime').value;
        const startTime = new Date(`${date}T${time}`).toISOString();

        requestBody = {
          action: 'book',
          djId: currentUser.uid,
          djName,
          djAvatar: freshAvatarUrl,
          crew: crew || null,
          representing: null,
          description: description || null,
          startTime,
          duration: parseInt(duration),
          token
        };
      }
      
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });
      
      const result = await response.json();
      
      if (result.success) {
        document.getElementById('bookingForm')?.classList.add('hidden');
        document.getElementById('streamKeyDisplay').textContent = result.streamKey;
        document.getElementById('bookingSuccess')?.classList.remove('hidden');
        
        // Force refresh to show new booking immediately
        // Small delay to ensure server has fully processed the booking
        scheduleCache = null;
        await new Promise(resolve => setTimeout(resolve, 500));
        await loadSchedule(true);
      } else {
        errorDiv.textContent = result.error || 'Failed to book slot';
        errorDiv.classList.remove('hidden');
      }
    } catch (err) {
      errorDiv.textContent = 'Network error. Please try again.';
      errorDiv.classList.remove('hidden');
    }
    
    submitBtn.disabled = false;
    submitBtn.textContent = 'Book Slot';
  });
  
  // Copy stream key
  document.getElementById('copyStreamKey')?.addEventListener('click', () => {
    const key = document.getElementById('streamKeyDisplay')?.textContent;
    if (key) {
      navigator.clipboard.writeText(key);
      document.getElementById('copyStreamKey').textContent = 'Copied!';
      setTimeout(() => {
        document.getElementById('copyStreamKey').textContent = 'Copy';
      }, 2000);
    }
  });
  
  // Go Live Now submit handler
  document.getElementById('submitGoLiveNow')?.addEventListener('click', async () => {
    const submitBtn = document.getElementById('submitGoLiveNow');
    const errorDiv = document.getElementById('goLiveNowError');
    
    if (!currentUser) {
      errorDiv.textContent = 'Please sign in to go live';
      errorDiv.classList.remove('hidden');
      setTimeout(() => {
        window.location.href = '/login?redirect=/live';
      }, 1500);
      return;
    }
    
    const djName = document.getElementById('goLiveNowDjName')?.value.trim();
    const crew = document.getElementById('goLiveNowCrew')?.value.trim() || '';
    const description = document.getElementById('goLiveNowDescription')?.value.trim() || '';
    
    if (!djName) {
      errorDiv.textContent = 'Please enter your DJ name';
      errorDiv.classList.remove('hidden');
      return;
    }
    
    submitBtn.disabled = true;
    submitBtn.textContent = 'Going Live...';
    errorDiv.classList.add('hidden');

    try {
      // Fetch latest avatar URL before going live
      let freshAvatarUrl = userInfo?.avatar || null;
      try {
        const userTypeRes = await fetch(`/api/get-user-type?uid=${currentUser.uid}`);
        const userTypeData = await userTypeRes.json();
        if (userTypeData.success && userTypeData.avatarUrl) {
          freshAvatarUrl = userTypeData.avatarUrl;
          // Update cached userInfo
          if (userInfo) userInfo.avatar = freshAvatarUrl;
        }
      } catch (e) {
        console.log('[Go Live] Could not fetch fresh avatar:', e);
      }

      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'go_live_now',
          djId: currentUser.uid,
          djName,
          djAvatar: freshAvatarUrl,
          crew: crew || null,
          representing: null,
          description: description || null,
          token
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // Close the modal
        document.getElementById('goLiveNowModal')?.classList.add('hidden');
        
        // Show lobby panel with stream info
        const lobbyPanel = document.getElementById('lobbyPanel');
        const lobbyStreamKey = document.getElementById('lobbyStreamKey');
        const lobbySlotTime = document.getElementById('lobbySlotTime');
        const lobbyCountdownBig = document.getElementById('lobbyCountdownBig');
        const goLiveBtn = document.getElementById('goLiveBtn');
        const endStreamBtn = document.getElementById('endStreamBtn');
        
        if (lobbyPanel) lobbyPanel.classList.remove('hidden');
        if (lobbyStreamKey) lobbyStreamKey.textContent = result.streamKey;
        if (lobbySlotTime) lobbySlotTime.textContent = `Now - ${result.endTimeFormatted || 'Live'}`;
        if (lobbyCountdownBig) lobbyCountdownBig.textContent = 'LIVE NOW';
        if (goLiveBtn) {
          goLiveBtn.textContent = 'You are LIVE!';
          goLiveBtn.disabled = true;
          goLiveBtn.classList.add('is-live');
        }
        if (endStreamBtn) {
          endStreamBtn.classList.remove('hidden');
        }
        
        // Store current slot info for later
        window.currentLiveSlot = result.slot;
        
        // Force refresh to show live status immediately
        scheduleCache = null;
        await loadSchedule(true);
      } else {
        errorDiv.textContent = result.error || 'Failed to go live';
        errorDiv.classList.remove('hidden');
      }
    } catch (err) {
      errorDiv.textContent = 'Network error. Please try again.';
      errorDiv.classList.remove('hidden');
    }
    
    submitBtn.disabled = false;
    submitBtn.textContent = 'Go Live Now';
  });
  
  // Cancel slot
  window.cancelSlot = async (slotId) => {
    if (!confirm('Cancel this slot?')) return;
    
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancel',
          slotId,
          djId: currentUser.uid,
          token
        })
      });
      
      const result = await response.json();
      if (result.success) {
        scheduleCache = null;
        await loadSchedule(true);
      } else {
        alert(result.error || 'Failed to cancel');
      }
    } catch (err) {
      alert('Network error');
    }
  };
  
  // Lobby buttons
  document.getElementById('goLiveBtn')?.addEventListener('click', async () => {
    if (!myUpcomingSlot) return;
    
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/manage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'go_live',
          slotId: myUpcomingSlot.id,
          token
        })
      });
      
      const result = await response.json();
      if (result.success) {
        scheduleCache = null;
        await loadSchedule(true);
      }
    } catch (err) {
      console.error('Failed to go live:', err);
    }
  });
  
  document.getElementById('leaveLobbyBtn')?.addEventListener('click', () => {
    document.getElementById('lobbyPanel')?.classList.add('hidden');
  });
  
  // Claim available slot handler
  document.getElementById('claimSlotBtn')?.addEventListener('click', async () => {
    const claimBtn = document.getElementById('claimSlotBtn');
    if (!claimBtn) return;
    
    claimBtn.disabled = true;
    claimBtn.textContent = '‚è≥ Claiming...';
    
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/manage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'claim_slot',
          token
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // Successfully claimed - update UI
        document.getElementById('slotAvailableSection')?.classList.add('hidden');
        document.getElementById('lobbyStreamKey').textContent = result.streamKey || 'Ready!';
        
        // Reset and show ready state
        isDjReady = true;
        setDjReady();
        
        alert('Slot claimed! You can now go live.');
        
        // Refresh schedule
        scheduleCache = null;
        await loadSchedule(true);
      } else {
        alert(result.error || 'Failed to claim slot - someone else may have claimed it first.');
        claimBtn.disabled = false;
        claimBtn.textContent = 'üéß Claim This Slot';
      }
    } catch (err) {
      console.error('Failed to claim slot:', err);
      alert('Network error. Please try again.');
      claimBtn.disabled = false;
      claimBtn.textContent = 'üéß Claim This Slot';
    }
  });
  
  // Poll for available slots (for DJs not currently in the late slot)
  let availableSlotPollInterval = null;
  
  function startAvailableSlotPolling() {
    if (availableSlotPollInterval) return;
    
    availableSlotPollInterval = setInterval(async () => {
      // Only poll if user is a DJ and lobby panel is visible
      if (!userInfo?.isDj || document.getElementById('lobbyPanel')?.classList.contains('hidden')) {
        return;
      }
      
      try {
        const response = await fetch('/api/livestream/slots?checkAvailable=true');
        const result = await response.json();
        
        if (result.availableSlot) {
          // There's an available slot - show claim option
          const slotAvailable = document.getElementById('slotAvailableSection');
          const mySlotId = myUpcomingSlot?.id;
          
          // Don't show to the DJ who forfeited their own slot
          if (result.availableSlot.id !== mySlotId) {
            slotAvailable?.classList.remove('hidden');
          }
        }
      } catch (err) {
        console.error('Error polling for available slots:', err);
      }
    }, 5000); // Poll every 5 seconds
  }
  
  function stopAvailableSlotPolling() {
    if (availableSlotPollInterval) {
      clearInterval(availableSlotPollInterval);
      availableSlotPollInterval = null;
    }
  }
  
  // Start polling when page loads for DJs
  if (userInfo?.isDj) {
    startAvailableSlotPolling();
  }
  
  // End Stream button handler
  document.getElementById('endStreamBtn')?.addEventListener('click', async () => {
    if (!confirm('Are you sure you want to end your stream?')) return;
    
    const endBtn = document.getElementById('endStreamBtn');
    if (endBtn) {
      endBtn.disabled = true;
      endBtn.textContent = '‚è≥ Ending...';
    }
    
    try {
      const slotId = window.currentLiveSlot?.id;
      if (!slotId) {
        alert('No active stream found');
        return;
      }
      
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'endStream',
          slotId: slotId,
          djId: currentUser.uid,
          token
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // Hide lobby panel
        document.getElementById('lobbyPanel')?.classList.add('hidden');
        
        // Reset buttons
        const goLiveBtn = document.getElementById('goLiveBtn');
        if (goLiveBtn) {
          goLiveBtn.textContent = 'Go Live';
          goLiveBtn.disabled = true;
          goLiveBtn.classList.remove('is-live');
        }
        if (endBtn) {
          endBtn.classList.add('hidden');
          endBtn.disabled = false;
          endBtn.textContent = '‚èπÔ∏è End Stream';
        }
        
        // Clear current slot
        window.currentLiveSlot = null;
        
        // Refresh schedule
        scheduleCache = null;
        await loadSchedule(true);
        
        alert('Stream ended successfully!');
      } else {
        alert(result.error || 'Failed to end stream');
        if (endBtn) {
          endBtn.disabled = false;
          endBtn.textContent = '‚èπÔ∏è End Stream';
        }
      }
    } catch (err) {
      console.error('Failed to end stream:', err);
      alert('Network error. Please try again.');
      if (endBtn) {
        endBtn.disabled = false;
        endBtn.textContent = '‚èπÔ∏è End Stream';
      }
    }
  });
  
  // Smart polling with visibility API to reduce Firebase reads
  let refreshInterval = null;
  const REFRESH_INTERVAL = 900000; // 15 minutes when visible
  const QUICK_REFRESH = 90000; // 1.5 minutes for live status during active streams (was 60s)
  
  function startRefreshInterval() {
    if (refreshInterval) clearInterval(refreshInterval);
    
    // Use shorter interval if someone is live (for real-time feel)
    const isLive = document.getElementById('liveBadge')?.classList.contains('is-live');
    const interval = isLive ? QUICK_REFRESH : REFRESH_INTERVAL;
    
    refreshInterval = setInterval(() => {
      if (!document.hidden) {
        scheduleCache = null;
        loadSchedule();
      }
    }, interval);
  }
  
  // Pause polling when tab is hidden, resume when visible
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // Tab hidden - stop polling to save reads
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    } else {
      // Tab visible again - force refresh to get latest data
      scheduleCache = null;
      loadSchedule(true);
      startRefreshInterval();
    }
  });
  
  // Listen for schedule updates from booking modal
  window.addEventListener('schedule-updated', () => {
    console.log('[Schedule] Booking update detected, refreshing lineup...');
    scheduleCache = null;
    loadSchedule(true);
  });
  
  // ============================================
  // MOBILE TAB NAVIGATION
  // ============================================
  const mobileTabs = document.querySelectorAll('.mobile-tab');
  const scheduleColumn = document.querySelector('.schedule-column');
  const playerColumn = document.querySelector('.player-column');
  const chatColumn = document.querySelector('.chat-column');
  
  function switchMobileTab(tabName) {
    // Update tab buttons
    mobileTabs.forEach(tab => {
      tab.classList.toggle('active', tab.dataset.tab === tabName);
    });
    
    // Update sections
    scheduleColumn?.classList.toggle('mobile-active', tabName === 'schedule');
    playerColumn?.classList.toggle('mobile-active', tabName === 'player');
    chatColumn?.classList.toggle('mobile-active', tabName === 'chat');
    
    // Clear chat badge when viewing chat
    if (tabName === 'chat') {
      const chatBadge = document.querySelector('.mobile-tab[data-tab="chat"] .tab-badge');
      if (chatBadge) chatBadge.remove();
    }
    
    // Scroll to top of content
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
  
  // Tab click handlers
  mobileTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      switchMobileTab(tab.dataset.tab);
    });
  });
  
  // Set initial state
  if (window.innerWidth <= 900) {
    playerColumn?.classList.add('mobile-active');
  }
  
  // Add chat notification badge when new message arrives
  let lastChatCount = 0;
  function addChatBadge() {
    const chatTab = document.querySelector('.mobile-tab[data-tab="chat"]');
    if (!chatTab || chatTab.classList.contains('active')) return;
    
    let badge = chatTab.querySelector('.tab-badge');
    if (!badge) {
      badge = document.createElement('span');
      badge.className = 'tab-badge';
      badge.textContent = '1';
      chatTab.appendChild(badge);
    } else {
      const count = parseInt(badge.textContent) + 1;
      badge.textContent = count > 9 ? '9+' : count;
    }
  }
  
  // Expose for chat system to call
  window.notifyNewChatMessage = addChatBadge;
  
  // Start initial polling
  startRefreshInterval();
  
  // ============================================
  // MOBILE MINI PLAYER
  // ============================================
  const miniPlayer = document.getElementById('miniPlayer');
  const miniPlayBtn = document.getElementById('miniPlayBtn');
  const miniExpandBtn = document.getElementById('miniExpandBtn');
  const miniPlayIcon = document.getElementById('miniPlayIcon');
  const miniPauseIcon = document.getElementById('miniPauseIcon');
  const miniDjName = document.getElementById('miniDjName');
  const miniDjAvatar = document.getElementById('miniDjAvatar');
  const miniLedStrip = document.getElementById('miniLedStrip');
  const playerContainer = document.getElementById('playerContainer');
  
  let miniPlayerVisible = false;
  let lastScrollY = 0;
  
  // Show/hide mini player based on scroll position
  function updateMiniPlayer() {
    if (!playerContainer || !miniPlayer) return;
    
    const rect = playerContainer.getBoundingClientRect();
    const shouldShow = rect.bottom < 0 && window.innerWidth <= 768;
    
    if (shouldShow && !miniPlayerVisible) {
      miniPlayer.classList.remove('hidden');
      setTimeout(() => miniPlayer.classList.add('visible'), 10);
      miniPlayerVisible = true;
    } else if (!shouldShow && miniPlayerVisible) {
      miniPlayer.classList.remove('visible');
      setTimeout(() => miniPlayer.classList.add('hidden'), 300);
      miniPlayerVisible = false;
    }
  }
  
  // Sync mini player state with main player
  function syncMiniPlayer() {
    const playBtn = document.getElementById('playBtn');
    const djName = document.getElementById('djName');
    const djAvatar = document.getElementById('djAvatar');
    
    if (playBtn && miniPlayBtn) {
      const isPlaying = playBtn.classList.contains('playing');
      if (isPlaying) {
        miniPlayIcon?.classList.add('hidden');
        miniPauseIcon?.classList.remove('hidden');
      } else {
        miniPlayIcon?.classList.remove('hidden');
        miniPauseIcon?.classList.add('hidden');
      }
    }
    
    if (djName && miniDjName) {
      miniDjName.textContent = djName.textContent;
    }
    
    if (djAvatar && miniDjAvatar) {
      miniDjAvatar.src = djAvatar.src;
    }
  }
  
  // Mini player play/pause
  miniPlayBtn?.addEventListener('click', () => {
    const playBtn = document.getElementById('playBtn');
    playBtn?.click();
    syncMiniPlayer();
  });
  
  // Expand back to full player
  miniExpandBtn?.addEventListener('click', () => {
    playerContainer?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  });
  
  // Update mini LED strip (simplified visualization)
  function updateMiniLeds(level) {
    if (!miniLedStrip) return;
    const leds = miniLedStrip.querySelectorAll('.mini-led');
    const activeLeds = Math.floor(level * leds.length);
    leds.forEach((led, i) => {
      led.classList.toggle('active', i < activeLeds);
    });
  }
  
  // Throttled scroll handler
  let scrollTimeout;
  window.addEventListener('scroll', () => {
    if (scrollTimeout) return;
    scrollTimeout = setTimeout(() => {
      updateMiniPlayer();
      scrollTimeout = null;
    }, 100);
  }, { passive: true });
  
  // Observe play state changes
  const playBtn = document.getElementById('playBtn');
  if (playBtn) {
    const observer = new MutationObserver(syncMiniPlayer);
    observer.observe(playBtn, { attributes: true, attributeFilter: ['class'] });
  }
  
  // ============================================
  // KEYBOARD SHORTCUTS
  // ============================================
  document.addEventListener('keydown', (e) => {
    // Don't trigger if typing in an input
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch(e.code) {
      case 'Space':
        e.preventDefault();
        document.getElementById('playBtn')?.click();
        break;
      case 'KeyM':
        // Toggle mute
        const slider = document.getElementById('volumeSlider');
        if (slider) {
          slider.value = slider.value > 0 ? 0 : 80;
          slider.dispatchEvent(new Event('input'));
        }
        break;
      case 'ArrowUp':
        e.preventDefault();
        adjustVolume(10);
        break;
      case 'ArrowDown':
        e.preventDefault();
        adjustVolume(-10);
        break;
      case 'KeyF':
        // Fullscreen
        document.getElementById('fullscreenBtn')?.click();
        break;
    }
  });
  
  function adjustVolume(delta) {
    const slider = document.getElementById('volumeSlider');
    if (slider) {
      let newVal = parseInt(slider.value) + delta;
      newVal = Math.max(0, Math.min(100, newVal));
      slider.value = newVal;
      slider.dispatchEvent(new Event('input'));
      showVolumeHint(newVal);
    }
  }
  
  function showVolumeHint(vol) {
    let hint = document.getElementById('volumeHint');
    if (!hint) {
      hint = document.createElement('div');
      hint.id = 'volumeHint';
      hint.className = 'swipe-hint';
      document.body.appendChild(hint);
    }
    hint.textContent = `Volume: ${vol}%`;
    hint.classList.add('visible');
    setTimeout(() => hint.classList.remove('visible'), 1000);
  }
  
  // ============================================
  // TOUCH GESTURES FOR MOBILE
  // ============================================
  let touchStartY = 0;
  let touchStartX = 0;
  
  playerContainer?.addEventListener('touchstart', (e) => {
    touchStartY = e.touches[0].clientY;
    touchStartX = e.touches[0].clientX;
  }, { passive: true });
  
  playerContainer?.addEventListener('touchend', (e) => {
    const touchEndY = e.changedTouches[0].clientY;
    const touchEndX = e.changedTouches[0].clientX;
    const deltaY = touchStartY - touchEndY;
    const deltaX = touchEndX - touchStartX;
    
    // Vertical swipe for volume (if more vertical than horizontal)
    if (Math.abs(deltaY) > 50 && Math.abs(deltaY) > Math.abs(deltaX)) {
      const volumeChange = deltaY > 0 ? 10 : -10;
      adjustVolume(volumeChange);
    }
    
    // Double tap to like
    // (handled by native dblclick)
  }, { passive: true });

  // Double tap to trigger reaction
  let lastTap = 0;
  playerContainer?.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTap < 300) {
      // Double tap!
      const likeBtn = document.getElementById('likeBtn');
      likeBtn?.click();
    }
    lastTap = now;
  }, { passive: true });

  // Now Playing Save Button - Add current track to personal playlist
  const nowPlayingSaveBtn = document.getElementById('nowPlayingSaveBtn');
  const djInfoBar = document.querySelector('.dj-info-bar');
  let currentPlaylistTrack = null;

  // Listen for playlist updates to show/hide the save button and track current song
  window.addEventListener('playlistUpdate', (e) => {
    const detail = e.detail;
    const isPlaylistPlaying = detail.isPlaying && detail.queue && detail.queue.length > 0;
    const controlsLabel = document.getElementById('controlsLabel');
    const controlsDjName = document.getElementById('controlsDjName');
    const npTrackTitle = document.getElementById('npTrackTitle');
    const bottomDurationBox = document.getElementById('bottomDurationBox');
    const bottomDurationLabel = document.getElementById('bottomDurationLabel');
    const streamGenre = document.getElementById('streamGenre');

    if (isPlaylistPlaying) {
      // Add playlist-mode class to show the save button
      djInfoBar?.classList.add('playlist-mode');

      // Store current track for saving
      const currentIndex = detail.currentIndex || 0;
      currentPlaylistTrack = detail.queue[currentIndex];

      // Update label and show track title only - keep it simple
      if (controlsLabel) controlsLabel.textContent = 'NOW PLAYING';
      if (controlsDjName && currentPlaylistTrack) {
        controlsDjName.textContent = currentPlaylistTrack.title || '';
      }
      if (npTrackTitle) npTrackTitle.textContent = '';

      // Show duration box with "LEFT" label, hide genre in playlist mode
      if (bottomDurationBox) bottomDurationBox.style.display = 'flex';
      if (bottomDurationLabel) bottomDurationLabel.textContent = 'LEFT';
      if (streamGenre) streamGenre.style.display = 'none';

      // Update button state - check if track is already in personal playlist
      if (nowPlayingSaveBtn && currentPlaylistTrack) {
        const personalPlaylist = detail.personalPlaylist || [];
        const isInPlaylist = personalPlaylist.some(item => item.url === currentPlaylistTrack.url);
        nowPlayingSaveBtn.classList.toggle('saved', isInPlaylist);
        nowPlayingSaveBtn.title = isInPlaylist ? 'Already in My Playlist' : 'Save to My Playlist';
      }
    } else {
      djInfoBar?.classList.remove('playlist-mode');
      currentPlaylistTrack = null;
      if (controlsLabel) controlsLabel.textContent = 'NOW PLAYING';
      if (npTrackTitle) npTrackTitle.textContent = '';
      // Don't overwrite controlsDjName if live stream is active (preserves relay red text)
      if (controlsDjName && !window.isLiveStreamActive) controlsDjName.textContent = '--';
      if (bottomDurationBox) bottomDurationBox.style.display = 'none';
      if (streamGenre) streamGenre.style.display = '';
    }
  });

  // Handle save button click
  nowPlayingSaveBtn?.addEventListener('click', async () => {
    if (!currentPlaylistTrack) return;

    // Check if already saved
    if (nowPlayingSaveBtn.classList.contains('saved')) {
      return; // Already saved
    }

    try {
      // Get the playlist manager and add to personal playlist
      const manager = window.playlistManager;
      if (manager) {
        // Pass the URL string, not the whole object
        const result = await manager.addToPersonalPlaylist(currentPlaylistTrack.url);
        if (result.success) {
          nowPlayingSaveBtn.classList.add('saved');
          nowPlayingSaveBtn.title = 'Already in My Playlist';
        }
      } else {
        console.warn('[NowPlaying] Playlist manager not available');
      }
    } catch (err) {
      console.error('[NowPlaying] Error saving track:', err);
    }
  });
</script>

<script type="module" src="/live-stream.js?v=20260104-playbtn-fix"></script>

<script>
  // Auto-hide header on live page
  (function initAutoHideHeader() {
    const header = document.getElementById('freshwax-header');
    if (!header) return;

    // Set real viewport height as CSS variable (handles mobile browser chrome)
    function setRealVH() {
      const vh = window.innerHeight;
      document.documentElement.style.setProperty('--real-vh', `${vh}px`);
    }
    setRealVH();
    window.addEventListener('resize', setRealVH);
    window.addEventListener('orientationchange', () => setTimeout(setRealVH, 100));

    // Create hover trigger zone at the very top of the page
    let hoverZone = document.querySelector('.header-hover-zone');
    if (!hoverZone) {
      hoverZone = document.createElement('div');
      hoverZone.className = 'header-hover-zone';
      document.body.appendChild(hoverZone);
    }

    // Add auto-hide class to header
    header.classList.add('header-auto-hide');
    document.body.classList.add('header-hidden');

    // Show header when hovering near the top
    hoverZone.addEventListener('mouseenter', () => {
      header.classList.add('header-visible');
    });

    // Keep header visible while mouse is over it
    header.addEventListener('mouseenter', () => {
      header.classList.add('header-visible');
    });

    // Hide header when mouse leaves both the trigger zone and header
    header.addEventListener('mouseleave', (e) => {
      // Check if mouse moved to the hover zone
      const rect = hoverZone.getBoundingClientRect();
      if (e.clientY > rect.bottom) {
        header.classList.remove('header-visible');
      }
    });

    hoverZone.addEventListener('mouseleave', (e) => {
      // Check if mouse moved to the header
      const headerRect = header.getBoundingClientRect();
      if (e.clientY > headerRect.bottom || e.clientY < headerRect.top) {
        // Give a small delay to allow mouse to move to header
        setTimeout(() => {
          if (!header.matches(':hover')) {
            header.classList.remove('header-visible');
          }
        }, 100);
      }
    });

    // Also show header when scrolled to very top
    let lastScrollY = window.scrollY;
    window.addEventListener('scroll', () => {
      if (window.scrollY === 0 && lastScrollY > 0) {
        // Just scrolled to top - briefly show header
        header.classList.add('header-visible');
        setTimeout(() => {
          if (!header.matches(':hover') && !hoverZone.matches(':hover')) {
            header.classList.remove('header-visible');
          }
        }, 2000);
      }
      lastScrollY = window.scrollY;
    }, { passive: true });

    // Clean up on page navigation (View Transitions)
    document.addEventListener('astro:before-swap', () => {
      header.classList.remove('header-auto-hide', 'header-visible');
      document.body.classList.remove('header-hidden');
      hoverZone?.remove();
    });
  })();
</script>
