---
// src/pages/account/dj-lobby.astro
// DJ-only lobby with stream preview, private chat, streaming instructions, and takeover system
import '../../styles/dj-lobby.css';
export const prerender = false;
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DJ Lobby - Fresh Wax</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Auth Gate -->
  <div id="authGate" class="auth-gate">
    <div class="auth-content">
      <div class="spinner"></div>
      <p>Checking DJ access...</p>
    </div>
  </div>
  
  <!-- Access Denied -->
  <div id="accessDenied" class="access-denied hidden">
    <div class="denied-content">
      <div class="denied-icon">üîí</div>
      <h1>DJ Access Only</h1>
      <p>This area is restricted to approved DJs.</p>
      <a href="/live" class="back-btn">Back to Live</a>
    </div>
  </div>
  
  <!-- Not Eligible - Needs mix with likes -->
  <div id="notEligible" class="not-eligible hidden">
    <div class="not-eligible-content">
      <div class="not-eligible-icon">üéß</div>
      <h1>ALMOST <span class="red">THERE</span></h1>
      <p id="eligibilityMessage">You need to build your reputation before accessing the DJ Lobby.</p>
      
      <div class="eligibility-requirements">
        <h3>To Access DJ Lobby, You Need:</h3>
        <div class="requirement-list">
          <div id="reqMixes" class="requirement">
            <span class="req-icon">‚ùå</span>
            <span class="req-text">At least 1 DJ mix uploaded</span>
          </div>
          <div id="reqLikes" class="requirement">
            <span class="req-icon">‚ùå</span>
            <span class="req-text">At least 10 likes on one of your mixes</span>
          </div>
        </div>
        
        <div id="progressInfo" class="progress-info hidden">
          <p>Your best mix: <span id="bestMixLikes">0</span>/10 likes</p>
          <div class="progress-bar">
            <div id="likesProgress" class="progress-fill" style="width: 0%"></div>
          </div>
        </div>
      </div>
      
      <div class="eligibility-actions">
        <a href="/upload-mix" class="action-btn primary">Upload a DJ Mix ‚Üí</a>
        <a href="/dj-mixes" class="action-btn secondary">View DJ Mixes</a>
        <a href="/live" class="action-btn secondary">Back to Live</a>
      </div>
      
      <!-- Bypass Request Section -->
      <div id="bypassRequestSection" class="bypass-request-section">
        <div class="bypass-or-divider">
          <span>OR</span>
        </div>
        
        <!-- Request Form State -->
        <div id="bypassRequestForm" class="bypass-form-card">
          <div class="bypass-header">
            <span class="bypass-icon">‚ö°</span>
            <div>
              <h4>Need access now?</h4>
              <p>Request bypass access - an admin will review and approve.</p>
            </div>
          </div>
          <div class="bypass-form-inner">
            <textarea id="bypassReason" placeholder="Why do you need immediate access? (optional)" rows="2" maxlength="200"></textarea>
            <button id="submitBypassRequest" class="bypass-request-btn">
              üé´ Request Bypass Access
            </button>
          </div>
        </div>
        
        <!-- Pending State -->
        <div id="bypassPending" class="bypass-status-card pending hidden">
          <div class="status-header">
            <span class="status-icon">‚è≥</span>
            <div>
              <h4>Request Pending</h4>
              <p>Your bypass request has been submitted. You'll get access once an admin approves it.</p>
            </div>
          </div>
          <button id="cancelBypassRequest" class="cancel-bypass-btn">Cancel Request</button>
        </div>
        
        <!-- Approved State -->
        <div id="bypassApproved" class="bypass-status-card approved hidden">
          <div class="status-header">
            <span class="status-icon">‚úÖ</span>
            <div>
              <h4>Bypass Approved!</h4>
              <p>Your request has been approved. Click below to enter the lobby.</p>
            </div>
          </div>
          <button id="continueWithBypass" class="continue-bypass-btn">Enter DJ Lobby ‚Üí</button>
        </div>
        
        <!-- Denied State -->
        <div id="bypassDenied" class="bypass-status-card denied hidden">
          <div class="status-header">
            <span class="status-icon">‚ùå</span>
            <div>
              <h4>Request Denied</h4>
              <p id="bypassDenialReason">Your request was not approved at this time.</p>
            </div>
          </div>
          <button id="resubmitBypassRequest" class="resubmit-bypass-btn">Submit New Request</button>
        </div>
      </div>
      
      <div class="eligibility-why">
        <h4>Why this requirement?</h4>
        <p>This helps ensure our livestreams feature genuine DJs who play jungle and drum & bass music. Upload a quality mix, get your fans to show some love, and you'll be in the lobby in no time! üîä</p>
      </div>
    </div>
  </div>
  
  <!-- Main Lobby -->
  <div id="mainLobby" class="lobby-container hidden">
    <header class="lobby-header">
      <div class="header-left">
        <a href="/live" class="back-link">
          <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
            <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
          </svg>
          Back to Live
        </a>
      </div>
      <div class="header-center">
        <h1>DJ <span class="red">LOBBY</span></h1>
        <p>Private space for Fresh Wax DJs</p>
      </div>
      <div class="header-right">
        <div class="user-info">
          <div class="header-avatar-container">
            <img id="headerAvatar" src="/place-holder.webp" alt="" class="header-avatar" />
            <div id="headerAvatarLetter" class="header-avatar-letter hidden">?</div>
          </div>
          <span id="headerName" class="header-name">Loading...</span>
        </div>
        <button id="signOutBtn" class="sign-out-btn">Sign Out</button>
      </div>
    </header>
    
    <div class="lobby-layout">
      <!-- Far Left Column: Stream Key -->
      <div class="key-column">
        <!-- Stream Control Card -->
        <div class="stream-control-card">
          <a href="/account/go-live" id="goLiveBtn" class="go-live-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
              <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
            </svg>
            Go Live
          </a>
          <div class="control-divider"></div>
          <button id="lobbyEndStreamBtn" class="lobby-end-stream-btn disabled" disabled>
            <span class="end-icon">‚èπ</span>
            <span class="end-text">End Stream</span>
          </button>
          <p id="endStreamStatus" class="end-stream-status">No active stream</p>
        </div>
        
        <!-- Takeover Section -->
        <div class="takeover-section" id="takeoverBox">
          <div class="section-header">
            <h3>üîÑ Stream Takeover</h3>
          </div>
          
          <div id="takeoverRequest" class="takeover-content hidden">
            <p>Request to take over from <strong id="takeoverFromName">DJ</strong></p>
            <button id="requestTakeoverBtn" class="takeover-btn">Request Takeover</button>
            <p id="takeoverPending" class="takeover-pending hidden">‚è≥ Waiting for response... <span id="takeoverCountdown"></span></p>
            <p id="takeoverAttemptsLeft" class="takeover-attempts">3 requests remaining this session</p>
            <p id="takeoverLimitReached" class="takeover-limit hidden">‚ö†Ô∏è No requests remaining this session</p>
          </div>
          
          <div id="incomingTakeover" class="incoming-takeover hidden">
            <div class="incoming-badge">‚ö° TAKEOVER REQUEST</div>
            <div class="incoming-dj">
              <img id="incomingDjAvatar" src="/place-holder.webp" alt="" />
              <div>
                <strong id="incomingDjName">DJ Name</strong>
                <span>wants to take over</span>
              </div>
            </div>
            <div class="incoming-actions">
              <button id="acceptTakeoverBtn" class="accept-btn">‚úì Accept</button>
              <button id="declineTakeoverBtn" class="decline-btn">‚úï Decline</button>
            </div>
          </div>
          
          <div id="takeoverApproved" class="takeover-approved hidden">
            <div class="approved-badge">‚úì APPROVED</div>
            <p>Copy these into OBS:</p>
            <div class="takeover-creds">
              <div class="cred-row">
                <label>Server</label>
                <div class="cred-value">
                  <code id="takeoverServerUrl">-</code>
                  <button class="copy-btn" data-copy="takeoverServerUrl">Copy</button>
                </div>
              </div>
              <div class="cred-row">
                <label>Key</label>
                <div class="cred-value">
                  <code id="takeoverStreamKey">-</code>
                  <button class="copy-btn" data-copy="takeoverStreamKey">Copy</button>
                </div>
              </div>
            </div>
          </div>
          
          <div id="noStreamTakeover" class="no-stream-msg">
            <p>No active stream to take over.</p>
          </div>
        </div>
        
        <!-- Streaming Setup Link -->
        <div class="setup-link-section">
          <a href="/account/streaming-setup" class="setup-link-btn">
            <span class="setup-icon">üìñ</span>
            <span class="setup-text">Streaming Setup Guide</span>
            <span class="setup-arrow">‚Üí</span>
          </a>
        </div>
      </div>
      
      <!-- Middle Column: Preview Only -->
      <div class="main-column">
        <!-- Current Stream Preview -->
        <div class="preview-section">
          <div class="preview-header">
            <h2>Current Stream</h2>
            <div class="stream-status" id="streamStatus">
              <span class="status-dot offline"></span>
              <span id="statusText">No one streaming</span>
            </div>
          </div>
          
          <div class="preview-player" id="previewPlayer">
            <div id="offlineState" class="offline-state">
              <div class="offline-icon">üì°</div>
              <h3>No Live Stream</h3>
              <p>Be the first to go live!</p>
            </div>
            
            <div id="videoPreview" class="video-preview hidden">
              <video id="hlsVideo" playsinline></video>
            </div>
            
            <div id="audioPreview" class="audio-preview hidden">
              <div class="audio-visualizer">
                <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                <div class="viz-bar"></div><div class="viz-bar"></div>
              </div>
              <img id="streamCover" src="/place-holder.webp" alt="Stream" class="stream-cover" />
              <audio id="audioElement" crossorigin="anonymous"></audio>
            </div>
            
            <!-- Time Remaining Overlay -->
            <div id="timeRemaining" class="time-remaining hidden">
              <span class="time-label">Time Remaining</span>
              <span id="timeLeft" class="time-value">--:--</span>
            </div>
          </div>
          
          <div class="player-controls">
            <button id="playPauseBtn" class="control-btn">
              <svg id="playIcon" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                <path d="M8 5v14l11-7z"/>
              </svg>
              <svg id="pauseIcon" class="hidden" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
              </svg>
            </button>
            
            <div class="volume-control">
              <button id="muteBtn" class="control-btn small">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                  <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                </svg>
              </button>
              <input type="range" id="volumeSlider" min="0" max="100" value="80" />
            </div>
            
            <div class="stream-info-display">
              <img id="currentDjAvatar" src="/place-holder.webp" alt="" class="current-dj-avatar" />
              <div class="current-dj-details">
                <span id="currentDjName" class="dj-name">-</span>
                <span id="currentStreamTitle" class="stream-title">No stream</span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Stream Key Section (under video player) -->
        <div class="stream-key-section">
          <div class="section-header">
            <h3>üîë Your Stream Key</h3>
            <span id="keyStatus" class="key-status">Checking...</span>
          </div>
          
          <div id="keyNotAvailable" class="key-not-available">
            <div class="lock-icon">üîí</div>
            <p>Your stream key will be available <strong>15 minutes</strong> before your scheduled slot.</p>
            <p id="nextSlotInfo" class="next-slot-info">You have no upcoming slots booked.</p>
            <a href="/account/go-live" class="book-slot-link">Book a Slot ‚Üí</a>
          </div>
          
          <div id="keyAvailable" class="key-available hidden">
            <div class="key-header">
              <span class="unlocked-icon">üîì</span>
              <div>
                <strong id="slotTimeDisplay">Your slot: --:-- - --:--</strong>
                <span id="countdownToSlot" class="countdown-text"></span>
              </div>
            </div>
            
            <div class="stream-credentials">
              <div class="cred-row">
                <label>RTMP Server URL</label>
                <div class="cred-value">
                  <code id="rtmpUrl">rtmp://stream.freshwax.co.uk/live</code>
                  <button class="copy-btn" data-copy="rtmpUrl">Copy</button>
                </div>
              </div>
              <div class="cred-row">
                <label>Stream Key</label>
                <div class="cred-value">
                  <code id="myStreamKey">-</code>
                  <button class="copy-btn" data-copy="myStreamKey">Copy</button>
                </div>
              </div>
            </div>
            
            <div class="ready-section">
              <p>Ready to go? Set yourself as ready so the stream transitions smoothly.</p>
              <button id="setReadyBtn" class="ready-btn">
                <span id="readyBtnText">‚úì I'm Ready</span>
              </button>
              <p id="readyStatus" class="ready-status hidden">‚úì You're set as ready. Stream will transition automatically when current DJ finishes.</p>
            </div>
          </div>
          
          <!-- Currently Live Controls -->
          <div id="myStreamControls" class="my-stream-controls hidden">
            <div class="live-badge">üî¥ YOU ARE LIVE</div>
            <div class="live-stats">
              <span id="myStreamDuration">Duration: 00:00</span>
            </div>
            <button id="endStreamBtn" class="end-stream-btn">End Stream</button>
          </div>
        </div>
      </div>
      
      <!-- Right Column: Chat + DJs Online side by side -->
      <div class="right-column">
        <!-- Chat Section -->
        <div class="chat-section">
          <div class="chat-header">
            <h2>üí¨ DJ Chat</h2>
            <div class="chat-header-actions">
              <span class="chat-hint">Private</span>
              <button id="openDmBtn" class="dm-btn">DM</button>
            </div>
          </div>
          
          <div class="chat-messages" id="chatMessages">
            <div class="chat-welcome">
              <p>Welcome to the DJ Lobby! üëã</p>
              <p class="hint">Chat with other DJs, coordinate sets, and hang out.</p>
            </div>
          </div>
          
          <div class="chat-input-section">
            <div class="chat-input-wrapper">
              <input type="text" id="chatInput" placeholder="Message other DJs..." maxlength="500" autocomplete="off" />
              <button id="sendBtn" type="button">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                  <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                </svg>
              </button>
            </div>
          </div>
        </div>
        
        <!-- DJs Online Box -->
        <div class="djs-online-box">
          <div class="box-header">
            <h3>üéß DJs in Lobby</h3>
            <span class="online-count"><span id="onlineDjCount">0</span> online</span>
          </div>
          <div id="djsList" class="djs-list">
            <p class="empty-state">No DJs online yet</p>
          </div>
        </div>
      </div>
    </div>
    
    <footer class="lobby-footer">
      <span>Fresh Wax</span>
      <span class="footer-dot">‚Ä¢</span>
      <span>DJ Lobby</span>
    </footer>
    
    <!-- DM Modal -->
    <div id="dmModal" class="dm-modal hidden">
      <div class="dm-modal-overlay"></div>
      <div class="dm-modal-content">
        <div class="dm-modal-header">
          <h2>üì© Direct Message</h2>
          <button id="closeDmBtn" class="close-dm-btn">‚úï</button>
        </div>
        
        <!-- DJ Selection View -->
        <div id="dmSelectView" class="dm-view">
          <p class="dm-select-hint">Select a DJ to message privately:</p>
          <div id="dmDjList" class="dm-dj-list">
            <p class="empty-state">No other DJs online</p>
          </div>
          <div class="dm-notice">
            <span class="notice-icon">‚ö†Ô∏è</span>
            <span>Messages are not stored and will be deleted when this chat closes.</span>
          </div>
        </div>
        
        <!-- Chat View -->
        <div id="dmChatView" class="dm-view hidden">
          <div class="dm-chat-header">
            <button id="dmBackBtn" class="dm-back-btn">‚Üê Back</button>
            <div class="dm-chat-with">
              <span id="dmChatWithName">DJ Name</span>
            </div>
          </div>
          <div class="dm-messages" id="dmMessages">
            <div class="dm-welcome">
              <p>Start a private conversation</p>
              <p class="hint">Only you and this DJ can see these messages.</p>
            </div>
          </div>
          <div class="dm-input-section">
            <div class="dm-input-wrapper">
              <input type="text" id="dmInput" placeholder="Type a message..." maxlength="500" autocomplete="off" />
              <button id="dmSendBtn" type="button">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                  <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="dm-notice small">
            <span class="notice-icon">‚ö†Ô∏è</span>
            <span>This chat is temporary and not stored.</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- DM Notification -->
    <div id="dmNotification" class="dm-notification hidden">
      <div class="dm-notif-content">
        <span class="dm-notif-icon">üí¨</span>
        <span id="dmNotifText">New DM from DJ Name</span>
        <button id="dmNotifOpenBtn" class="dm-notif-open">Open</button>
        <button id="dmNotifDismissBtn" class="dm-notif-dismiss">‚úï</button>
      </div>
    </div>
  </div>


<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
  import { getAuth, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
  import { getFirestore, collection, query, orderBy, limit, addDoc, serverTimestamp, doc, setDoc, deleteDoc, getDocs, getDoc, where } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';
  
  // Pusher-based real-time features (replaces Firebase onSnapshot)
  import { 
    initDjLobbyPusher, 
    sendChatMessage, 
    requestTakeover, 
    approveTakeover, 
    declineTakeover,
    openDmConversation,
    sendDm,
    cleanup as cleanupPusher,
    getOnlineDjs
  } from '/dj-lobby-pusher.js';
  
  const app = initializeApp({
    apiKey: "AIzaSyBiZGsWdvA9ESm3OsUpZ-VQpwqMjMpBY6g",
    authDomain: "freshwax-store.firebaseapp.com",
    projectId: "freshwax-store"
  });
  
  const auth = getAuth(app);
  const db = getFirestore(app);
  
  let currentUser = null;
  let userInfo = null;
  let currentStream = null;
  let mySlot = null;
  let presenceRef = null;
  let streamStartTime = null;
  let streamEndTime = null;
  
  // Takeover limiting - max 3 attempts per session
  let takeoverAttempts = 0;
  const MAX_TAKEOVER_ATTEMPTS = 3;
  let takeoverTimeout = null;
  let takeoverPending = false;
  
  // DM System
  let dmTargetDj = null;
  let dmMessages = [];
  let dmUnsubscribe = null;
  let onlineDjsCache = [];
  let authInitialized = false;
  
  // Auth timeout - if auth check takes too long, offer refresh
  let authTimeout = setTimeout(() => {
    if (!authInitialized) {
      console.log('[DJLobby] Auth timeout - no response after 8 seconds');
      const authGate = document.getElementById('authGate');
      if (authGate) {
        authGate.innerHTML = `
          <div class="auth-content">
            <div class="not-eligible-icon">‚è≥</div>
            <h2 style="margin: 1rem 0 0.5rem; color: #fff;">Taking too long?</h2>
            <p style="color: #aaa; margin-bottom: 1.5rem;">Authentication is taking longer than expected.</p>
            <button onclick="location.reload()" class="action-btn primary">Refresh Page</button>
            <a href="/live" class="action-btn secondary" style="margin-top: 0.75rem; display: inline-block;">Back to Live</a>
          </div>
        `;
      }
    }
  }, 8000);
  
  onAuthStateChanged(auth, async (user) => {
    authInitialized = true;
    clearTimeout(authTimeout);
    if (!user) {
      window.location.href = '/login?redirect=/account/dj-lobby';
      return;
    }
    currentUser = user;
    
    // Set a timeout for the access check itself
    const accessCheckTimeout = setTimeout(() => {
      console.log('[DJLobby] Access check timeout - no response after 15 seconds');
      const authGate = document.getElementById('authGate');
      if (authGate && !authGate.classList.contains('hidden')) {
        authGate.innerHTML = `
          <div class="auth-content">
            <div class="not-eligible-icon">‚ö†Ô∏è</div>
            <h2 style="margin: 1rem 0 0.5rem; color: #fff;">Connection Issue</h2>
            <p style="color: #aaa; margin-bottom: 1.5rem;">Unable to verify DJ access. Please check your connection and try again.</p>
            <button onclick="location.reload()" class="action-btn primary">Try Again</button>
            <a href="/live" class="action-btn secondary" style="margin-top: 0.75rem; display: inline-block;">Back to Live</a>
          </div>
        `;
      }
    }, 15000);
    
    await checkDjAccess(user.uid);
    clearTimeout(accessCheckTimeout);
  });
  
  async function checkDjAccess(userId) {
    try {
      console.log('[DJ Lobby] Checking access for:', userId);
      
      // Helper function with timeout
      const fetchWithTimeout = async (url, timeout = 10000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          return response;
        } catch (e) {
          clearTimeout(timeoutId);
          throw e;
        }
      };
      
      // Check user type first
      let response;
      try {
        response = await fetchWithTimeout(`/api/get-user-type?uid=${userId}`);
      } catch (e) {
        console.error('[DJ Lobby] get-user-type fetch failed:', e);
        showAccessDenied();
        return;
      }
      
      if (!response.ok) {
        console.error('[DJ Lobby] get-user-type returned', response.status);
        showAccessDenied();
        return;
      }
      
      const result = await response.json();
      console.log('[DJ Lobby] User type result:', result);
      
      if (!result.success) { 
        console.error('[DJ Lobby] get-user-type failed:', result.error);
        showAccessDenied(); 
        return; 
      }
      
      const isAdmin = result.isAdmin === true;
      // Use Firebase Auth displayName (same as Header.astro) - this is the public name
      const displayName = currentUser.displayName || result.partnerDisplayName || result.name || 'DJ';
      
      userInfo = {
        id: userId,
        name: displayName,
        firstName: displayName.split(' ')[0] || 'D',
        avatar: result.avatarUrl || currentUser.photoURL || null,
        isAdmin: isAdmin
      };
      
      console.log('[DJ Lobby] User info set:', { displayName, firebaseDisplayName: currentUser.displayName, apiPartnerDisplayName: result.partnerDisplayName });
      
      // Check eligibility (must have mix with 10+ likes OR have bypass approval)
      console.log('[DJ Lobby] Checking eligibility...');
      let eligibilityResponse;
      try {
        eligibilityResponse = await fetchWithTimeout(`/api/check-dj-eligibility?userId=${userId}`);
      } catch (e) {
        console.error('[DJ Lobby] check-dj-eligibility fetch failed:', e);
        showNotEligible({ reason: 'error', message: 'Could not verify eligibility. Please try again.' });
        return;
      }
      
      if (!eligibilityResponse.ok) {
        console.error('[DJ Lobby] check-dj-eligibility returned', eligibilityResponse.status);
        showNotEligible({ reason: 'error', message: 'Could not verify eligibility. Please try again.' });
        return;
      }
      
      const eligibility = await eligibilityResponse.json();
      console.log('[DJ Lobby] Eligibility result:', eligibility);
      
      if (!eligibility.success) {
        console.error('[DJ Lobby] Eligibility check failed:', eligibility.error);
        showNotEligible({ reason: 'error', message: 'Could not verify eligibility. Please try again.' });
        return;
      }
      
      if (!eligibility.eligible && !isAdmin) {
        console.log('[DJ Lobby] User not eligible, showing requirements');
        showNotEligible(eligibility);
        return;
      }
      
      console.log('[DJ Lobby] Access granted, showing lobby');
      showLobby();
      initLobby();
    } catch (e) {
      console.error('[DJ Lobby] Access check failed:', e);
      showAccessDenied();
    }
  }
  
  function showNotEligible(eligibility) {
    document.getElementById('authGate').classList.add('hidden');
    document.getElementById('accessDenied').classList.add('hidden');
    document.getElementById('notEligible').classList.remove('hidden');
    
    const icon = document.querySelector('.not-eligible-icon');
    const title = document.querySelector('.not-eligible-content h1');
    const requirements = document.querySelector('.eligibility-requirements');
    const actions = document.querySelector('.eligibility-actions');
    const whySection = document.querySelector('.eligibility-why');
    
    // Handle banned status
    if (eligibility.reason === 'banned') {
      icon.textContent = 'üö´';
      title.innerHTML = 'ACCESS <span class="red">SUSPENDED</span>';
      document.getElementById('eligibilityMessage').textContent = eligibility.message || 'Your account has been suspended from streaming.';
      requirements.innerHTML = `
        <div class="banned-notice">
          <p>Your streaming privileges have been suspended.</p>
          ${eligibility.bannedReason ? `<p class="ban-reason">Reason: ${eligibility.bannedReason}</p>` : ''}
          <p class="contact-info">If you believe this is a mistake, please contact us.</p>
        </div>
      `;
      actions.innerHTML = `
        <a href="/contact" class="action-btn primary">Contact Support</a>
        <a href="/live" class="action-btn secondary">Back to Live</a>
      `;
      whySection.classList.add('hidden');
      document.getElementById('bypassRequestSection')?.classList.add('hidden');
      return;
    }
    
    // Handle on-hold status
    if (eligibility.reason === 'on_hold') {
      icon.textContent = '‚è∏Ô∏è';
      title.innerHTML = 'ON <span class="red">HOLD</span>';
      document.getElementById('eligibilityMessage').textContent = eligibility.message || 'Your streaming access is temporarily on hold.';
      requirements.innerHTML = `
        <div class="hold-notice">
          <p>Your streaming access is temporarily restricted.</p>
          ${eligibility.holdReason ? `<p class="hold-reason">Reason: ${eligibility.holdReason}</p>` : ''}
          <p class="contact-info">Please contact us if you have questions.</p>
        </div>
      `;
      actions.innerHTML = `
        <a href="/contact" class="action-btn primary">Contact Support</a>
        <a href="/live" class="action-btn secondary">Back to Live</a>
      `;
      whySection.classList.add('hidden');
      document.getElementById('bypassRequestSection')?.classList.add('hidden');
      return;
    }
    
    // Default eligibility check (mixes/likes)
    icon.textContent = 'üéß';
    title.innerHTML = 'ALMOST <span class="red">THERE</span>';
    document.getElementById('eligibilityMessage').textContent = eligibility.message || 'You need to build your reputation before accessing the DJ Lobby.';
    
    // Update requirements
    const reqMixes = document.getElementById('reqMixes');
    const reqLikes = document.getElementById('reqLikes');
    
    if (reqMixes && eligibility.mixCount > 0) {
      reqMixes.classList.add('met');
      reqMixes.querySelector('.req-icon').textContent = '‚úÖ';
    }
    
    if (reqLikes && eligibility.qualifyingMixes > 0) {
      reqLikes.classList.add('met');
      reqLikes.querySelector('.req-icon').textContent = '‚úÖ';
    }
    
    // Show progress if they have mixes but need likes
    if (eligibility.reason === 'insufficient_likes' && eligibility.bestMixLikes !== undefined) {
      const progressInfo = document.getElementById('progressInfo');
      if (progressInfo) {
        progressInfo.classList.remove('hidden');
        document.getElementById('bestMixLikes').textContent = eligibility.bestMixLikes;
        const progress = Math.min(100, (eligibility.bestMixLikes / eligibility.requiredLikes) * 100);
        document.getElementById('likesProgress').style.width = progress + '%';
      }
    }
    
    whySection.classList.remove('hidden');
    
    // Check and show bypass request status
    checkBypassStatus(eligibility);
    startBypassPolling();
  }
  
  // ==========================================
  // BYPASS REQUEST FUNCTIONALITY
  // ==========================================
  
  let currentBypassStatus = null;
  let bypassPollInterval = null;
  
  async function checkBypassStatus(eligibility) {
    if (!userInfo?.uid) return;
    
    try {
      const response = await fetch(`/api/admin/bypass-requests?action=status&userId=${userInfo.uid}`);
      const result = await response.json();
      
      if (result.success) {
        currentBypassStatus = { ...result, ...eligibility };
        updateBypassUI(result);
      }
    } catch (error) {
      console.error('[Bypass] Error checking status:', error);
    }
  }
  
  function updateBypassUI(status) {
    const form = document.getElementById('bypassRequestForm');
    const pending = document.getElementById('bypassPending');
    const approved = document.getElementById('bypassApproved');
    const denied = document.getElementById('bypassDenied');
    
    form?.classList.add('hidden');
    pending?.classList.add('hidden');
    approved?.classList.add('hidden');
    denied?.classList.add('hidden');
    
    if (!status.hasRequest) {
      form?.classList.remove('hidden');
    } else if (status.request?.status === 'pending') {
      pending?.classList.remove('hidden');
    } else if (status.request?.status === 'approved') {
      approved?.classList.remove('hidden');
    } else if (status.request?.status === 'denied') {
      denied?.classList.remove('hidden');
      if (status.request?.denialReason) {
        const reasonEl = document.getElementById('bypassDenialReason');
        if (reasonEl) reasonEl.textContent = `Your request was not approved: ${status.request.denialReason}`;
      }
    }
  }
  
  function startBypassPolling() {
    if (bypassPollInterval) return;
    bypassPollInterval = setInterval(async () => {
      if (currentBypassStatus?.request?.status === 'pending') {
        await checkBypassStatus(currentBypassStatus);
        if (currentBypassStatus?.request?.status === 'approved') {
          stopBypassPolling();
        }
      }
    }, 30000);
  }
  
  function stopBypassPolling() {
    if (bypassPollInterval) {
      clearInterval(bypassPollInterval);
      bypassPollInterval = null;
    }
  }
  
  // Submit bypass request
  document.getElementById('submitBypassRequest')?.addEventListener('click', async () => {
    const btn = document.getElementById('submitBypassRequest');
    const reason = document.getElementById('bypassReason')?.value?.trim() || '';
    
    if (!userInfo?.uid) {
      alert('Please sign in first');
      return;
    }
    
    btn.disabled = true;
    btn.textContent = 'Submitting...';
    
    try {
      const response = await fetch('/api/admin/bypass-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'request',
          userId: userInfo.uid,
          djName: userInfo.name || userInfo.email?.split('@')[0],
          email: userInfo.email,
          reason: reason || null,
          mixCount: currentBypassStatus?.mixCount || 0,
          bestMixLikes: currentBypassStatus?.bestMixLikes || 0
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        await checkBypassStatus(currentBypassStatus || {});
      } else {
        alert(result.error || 'Failed to submit request');
        btn.disabled = false;
        btn.textContent = 'üé´ Request Bypass Access';
      }
    } catch (error) {
      console.error('[Bypass] Submit error:', error);
      alert('Failed to submit request. Please try again.');
      btn.disabled = false;
      btn.textContent = 'üé´ Request Bypass Access';
    }
  });
  
  // Cancel bypass request
  document.getElementById('cancelBypassRequest')?.addEventListener('click', async () => {
    if (!confirm('Cancel your bypass request?')) return;
    
    try {
      const response = await fetch('/api/admin/bypass-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancel',
          userId: userInfo.uid,
          adminKey: 'fresh-wax-admin-2024'
        })
      });
      
      const result = await response.json();
      if (result.success) {
        await checkBypassStatus(currentBypassStatus || {});
      } else {
        alert(result.error || 'Failed to cancel request');
      }
    } catch (error) {
      console.error('[Bypass] Cancel error:', error);
    }
  });
  
  // Continue with bypass (after approval)
  document.getElementById('continueWithBypass')?.addEventListener('click', () => {
    location.reload();
  });
  
  // Resubmit after denial
  document.getElementById('resubmitBypassRequest')?.addEventListener('click', async () => {
    try {
      await fetch('/api/admin/bypass-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancel',
          userId: userInfo.uid,
          adminKey: 'fresh-wax-admin-2024'
        })
      });
      await checkBypassStatus(currentBypassStatus || {});
    } catch (error) {
      console.error('[Bypass] Resubmit error:', error);
    }
  });

  function showAccessDenied() {
    document.getElementById('authGate').classList.add('hidden');
    document.getElementById('accessDenied').classList.remove('hidden');
  }
  
  function showLobby() {
    document.getElementById('authGate').classList.add('hidden');
    document.getElementById('mainLobby').classList.remove('hidden');
    
    // Populate header with user info
    document.getElementById('headerName').textContent = userInfo.name;
    
    // Handle avatar with letter fallback
    const avatarImg = document.getElementById('headerAvatar');
    const avatarLetter = document.getElementById('headerAvatarLetter');
    
    if (userInfo.avatar && userInfo.avatar !== '/place-holder.webp') {
      // Try to load the image
      avatarImg.onload = () => {
        avatarImg.classList.remove('hidden');
        avatarLetter.classList.add('hidden');
      };
      avatarImg.onerror = () => {
        // Image failed, show letter
        avatarImg.classList.add('hidden');
        avatarLetter.classList.remove('hidden');
        avatarLetter.textContent = getAvatarLetter(userInfo.name, userInfo.firstName);
      };
      avatarImg.src = userInfo.avatar;
    } else {
      // No avatar URL, show letter
      avatarImg.classList.add('hidden');
      avatarLetter.classList.remove('hidden');
      avatarLetter.textContent = getAvatarLetter(userInfo.name, userInfo.firstName);
    }
  }
  
  function getAvatarLetter(displayName, firstName) {
    // Try display name first, then firstName
    const name = displayName || firstName || 'D';
    return name.charAt(0).toUpperCase();
  }
  
  async function initLobby() {
    // Load initial data from API
    await loadStreamStatus();
    await checkAndCleanupChat();
    await loadMySlot();
    
    // Initialize Pusher-based real-time features (replaces Firebase onSnapshot)
    // This handles: presence, chat, takeover, DMs
    await initDjLobbyPusher(currentUser, userInfo);
    
    // Setup UI event listeners
    setupEventListeners();
    
    // Polling for non-realtime data
    setInterval(loadStreamStatus, 10000);
    setInterval(updateTimeRemaining, 1000);
    setInterval(checkStreamKeyAvailability, 30000);
  }
  
  // Page cleanup - called when leaving
  function setupPageCleanup() {
    window.addEventListener('beforeunload', async () => {
      try {
        await cleanupPusher();
      } catch(e) {
        console.error('Cleanup error:', e);
      }
    });
  }
  
  // Call setup after initLobby
  setupPageCleanup();
  
  // Check if chat should be cleaned up (2 hours since last stream ended and no one is live)
  async function checkAndCleanupChat() {
    try {
      // Get chat settings doc - this may fail due to permissions, that's ok
      const settingsRef = doc(db, 'djLobbySettings', 'chatCleanup');
      const settingsSnap = await getDoc(settingsRef);
      
      if (!settingsSnap.exists()) return; // No settings, skip cleanup
      
      const settings = settingsSnap.data();
      const lastStreamEndTime = settings.lastStreamEndTime?.toMillis() || 0;
      const now = Date.now();
      const twoHoursMs = 2 * 60 * 60 * 1000; // 2 hours in milliseconds
      
      // If no one is currently streaming AND 2 hours have passed since last stream ended
      if (!currentStream && lastStreamEndTime > 0 && (now - lastStreamEndTime) > twoHoursMs) {
        console.log('Chat cleanup: 2+ hours since last stream, clearing chat history...');
        
        // Delete all DJ lobby chat messages
        const chatSnapshot = await getDocs(collection(db, 'djLobbyChat'));
        const deletePromises = [];
        chatSnapshot.forEach(document => {
          deletePromises.push(deleteDoc(doc(db, 'djLobbyChat', document.id)));
        });
        await Promise.all(deletePromises);
        
        // Reset the lastStreamEndTime so we don't keep deleting
        await setDoc(settingsRef, { 
          lastStreamEndTime: null,
          lastCleanup: serverTimestamp()
        }, { merge: true });
        
        console.log('Chat cleanup complete');
      }
    } catch (e) {
      // Permissions error is expected if rules don't allow reading djLobbySettings
      // This is non-critical, just skip cleanup silently
      if (e.code !== 'permission-denied') {
        console.warn('Chat cleanup skipped:', e.message);
      }
    }
  }
  
  // Call this when a stream ends to record the time
  async function recordStreamEnd() {
    try {
      const settingsRef = doc(db, 'djLobbySettings', 'chatCleanup');
      await setDoc(settingsRef, { 
        lastStreamEndTime: serverTimestamp()
      }, { merge: true });
    } catch (e) {
      console.error('Record stream end error:', e);
    }
  }
  
  // REPLACED BY PUSHER MODULE - presence events now handled via Pusher channel
  // function subscribeToOnlineDjs() { ... }
  
  function updateOnlineDjsList(djs) {
    document.getElementById('onlineDjCount').textContent = djs.length;
    
    const list = document.getElementById('djsList');
    if (djs.length === 0) {
      list.innerHTML = '<p class="empty-state">No DJs online yet</p>';
      return;
    }
    
    list.innerHTML = djs.map(dj => {
      const isLive = currentStream && currentStream.djId === dj.odamiMa;
      const isMe = dj.odamiMa === currentUser?.uid;
      const isReady = dj.isReady === true;
      const avatarLetter = dj.avatarLetter || (dj.name ? dj.name.charAt(0).toUpperCase() : 'D');
      const hasAvatar = dj.avatar && dj.avatar !== '/place-holder.webp';
      
      return `
        <div class="dj-item ${isLive ? 'is-live' : ''} ${isReady && !isLive ? 'is-ready' : ''}">
          ${hasAvatar 
            ? `<img src="${dj.avatar}" alt="" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="dj-avatar-letter" style="display:none;">${avatarLetter}</span>`
            : `<span class="dj-avatar-letter">${avatarLetter}</span>`
          }
          <span>${dj.name}${isMe ? ' (you)' : ''}</span>
        </div>
      `;
    }).join('');
  }
  
  async function loadStreamStatus() {
    try {
      const response = await fetch('/api/livestream/status');
      const result = await response.json();
      
      const statusDot = document.querySelector('.status-dot');
      const statusText = document.getElementById('statusText');
      const offlineState = document.getElementById('offlineState');
      const videoPreview = document.getElementById('videoPreview');
      const audioPreview = document.getElementById('audioPreview');
      const timeRemaining = document.getElementById('timeRemaining');
      const myControls = document.getElementById('myStreamControls');
      const takeoverRequest = document.getElementById('takeoverRequest');
      const noStreamTakeover = document.getElementById('noStreamTakeover');
      
      if (result.success && result.isLive && result.primaryStream) {
        currentStream = result.primaryStream;
        
        statusDot.classList.remove('offline');
        statusDot.classList.add('live');
        statusText.textContent = `${currentStream.djName} is LIVE`;
        
        offlineState.classList.add('hidden');
        timeRemaining.classList.remove('hidden');
        
        // Parse stream times
        if (currentStream.startedAt) {
          streamStartTime = new Date(currentStream.startedAt);
        }
        if (currentStream.endTime) {
          streamEndTime = new Date(currentStream.endTime);
        } else if (currentStream.duration) {
          streamEndTime = new Date(streamStartTime.getTime() + currentStream.duration * 60000);
        }
        
        document.getElementById('currentDjName').textContent = currentStream.djName || 'DJ';
        document.getElementById('currentStreamTitle').textContent = currentStream.title || 'Live Stream';
        if (currentStream.djAvatar) {
          document.getElementById('currentDjAvatar').src = currentStream.djAvatar;
        }
        
        if (currentStream.streamType === 'audio' || currentStream.streamUrl?.includes('8000')) {
          audioPreview.classList.remove('hidden');
          videoPreview.classList.add('hidden');
          if (currentStream.djAvatar) document.getElementById('streamCover').src = currentStream.djAvatar;
        } else {
          videoPreview.classList.remove('hidden');
          audioPreview.classList.add('hidden');
        }
        
        if (currentStream.djId === currentUser?.uid) {
          myControls.classList.remove('hidden');
          takeoverRequest.classList.add('hidden');
          noStreamTakeover.classList.add('hidden');
          
          // Enable end stream button for current streamer
          updateEndStreamButton(true, true);
        } else {
          myControls.classList.add('hidden');
          takeoverRequest.classList.remove('hidden');
          noStreamTakeover.classList.add('hidden');
          document.getElementById('takeoverFromName').textContent = currentStream.djName || 'current DJ';
          
          // Disable end stream button - not your stream
          updateEndStreamButton(true, false);
        }
        
        // Disable Go Live button when someone is streaming
        document.getElementById('goLiveBtn').classList.add('disabled');
      } else {
        currentStream = null;
        streamStartTime = null;
        streamEndTime = null;
        statusDot.classList.add('offline');
        statusDot.classList.remove('live');
        statusText.textContent = 'No one streaming';
        offlineState.classList.remove('hidden');
        videoPreview.classList.add('hidden');
        audioPreview.classList.add('hidden');
        timeRemaining.classList.add('hidden');
        myControls.classList.add('hidden');
        takeoverRequest.classList.add('hidden');
        noStreamTakeover.classList.remove('hidden');
        
        document.getElementById('currentDjName').textContent = '-';
        document.getElementById('currentStreamTitle').textContent = 'No stream';
        document.getElementById('currentDjAvatar').src = '/place-holder.webp';
        
        // Disable end stream button - no active stream
        updateEndStreamButton(false, false);
        
        // Enable Go Live button when no one is streaming
        document.getElementById('goLiveBtn').classList.remove('disabled');
      }
    } catch (e) {
      console.error('Stream status error:', e);
    }
  }
  
  function updateTimeRemaining() {
    const timeLeft = document.getElementById('timeLeft');
    
    if (!streamEndTime) {
      timeLeft.textContent = '--:--';
      return;
    }
    
    const now = new Date();
    const diff = streamEndTime - now;
    
    if (diff <= 0) {
      timeLeft.textContent = '00:00';
      timeLeft.style.color = '#dc2626';
      return;
    }
    
    const mins = Math.floor(diff / 60000);
    const secs = Math.floor((diff % 60000) / 1000);
    timeLeft.textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    
    if (mins < 5) {
      timeLeft.style.color = '#dc2626';
    } else {
      timeLeft.style.color = '#fff';
    }
  }
  
  async function loadMySlot() {
    try {
      const now = new Date();
      const end = new Date(now.getTime() + 24 * 60 * 60 * 1000);
      
      const response = await fetch(`/api/livestream/slots?start=${now.toISOString()}&end=${end.toISOString()}&djId=${currentUser.uid}`);
      const result = await response.json();
      
      if (result.success && result.slots && result.slots.length > 0) {
        // Sort by startTime to get the earliest upcoming slot
        const sortedSlots = result.slots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
        mySlot = sortedSlots[0];
        checkStreamKeyAvailability();
      } else {
        mySlot = null;
        showKeyNotAvailable();
      }
    } catch (e) {
      console.error('Load slot error:', e);
    }
  }
  
  // Format duration in days, hours, minutes
  function formatDuration(totalMinutes) {
    if (totalMinutes <= 0) return '0 minutes';
    
    const days = Math.floor(totalMinutes / 1440);
    const hours = Math.floor((totalMinutes % 1440) / 60);
    const mins = totalMinutes % 60;
    
    const parts = [];
    if (days > 0) parts.push(`${days} day${days !== 1 ? 's' : ''}`);
    if (hours > 0) parts.push(`${hours} hour${hours !== 1 ? 's' : ''}`);
    if (mins > 0 || parts.length === 0) parts.push(`${mins} minute${mins !== 1 ? 's' : ''}`);
    
    return parts.join(', ');
  }
  
  function checkStreamKeyAvailability() {
    const keyStatus = document.getElementById('keyStatus');
    const keyNotAvailable = document.getElementById('keyNotAvailable');
    const keyAvailable = document.getElementById('keyAvailable');
    
    if (!mySlot) {
      keyStatus.textContent = 'No slot';
      keyStatus.className = 'key-status locked';
      showKeyNotAvailable();
      return;
    }
    
    const now = new Date();
    const slotStart = new Date(mySlot.startTime);
    const slotEnd = new Date(mySlot.endTime);
    const unlockTime = new Date(slotStart.getTime() - 15 * 60 * 1000);
    
    document.getElementById('nextSlotInfo').textContent = 
      `Your next slot: ${slotStart.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })} - ${slotEnd.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })}`;
    
    if (now >= unlockTime) {
      keyStatus.textContent = 'Available';
      keyStatus.className = 'key-status unlocked';
      keyNotAvailable.classList.add('hidden');
      keyAvailable.classList.remove('hidden');
      
      document.getElementById('slotTimeDisplay').textContent = 
        `Your slot: ${slotStart.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })} - ${slotEnd.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })}`;
      
      const minsUntil = Math.ceil((slotStart - now) / 60000);
      if (minsUntil > 0) {
        document.getElementById('countdownToSlot').textContent = `Starts in ${formatDuration(minsUntil)}`;
      } else {
        document.getElementById('countdownToSlot').textContent = `Your slot is NOW!`;
      }
      
      document.getElementById('myStreamKey').textContent = mySlot.streamKey || 'Loading...';
      
      if (!mySlot.streamKey) {
        fetchStreamKey();
      }
    } else {
      keyStatus.textContent = 'Locked';
      keyStatus.className = 'key-status locked';
      showKeyNotAvailable();
      
      const minsUntilUnlock = Math.ceil((unlockTime - now) / 60000);
      document.getElementById('nextSlotInfo').innerHTML = 
        `Your next slot: ${slotStart.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })}<br>
         <span style="color: #dc2626;">Key unlocks in ${formatDuration(minsUntilUnlock)}</span>`;
    }
  }
  
  function showKeyNotAvailable() {
    document.getElementById('keyNotAvailable').classList.remove('hidden');
    document.getElementById('keyAvailable').classList.add('hidden');
  }
  
  async function fetchStreamKey() {
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify({ action: 'getStreamKey', slotId: mySlot.id, djId: currentUser.uid })
      });
      
      const result = await response.json();
      if (result.success && result.streamKey) {
        document.getElementById('myStreamKey').textContent = result.streamKey;
        mySlot.streamKey = result.streamKey;
      }
    } catch (e) {
      console.error('Fetch key error:', e);
    }
  }
  
  // REPLACED BY PUSHER MODULE - takeover events now handled via private Pusher channel
  // function subscribeToTakeover() { ... }
  
  function showIncomingTakeover(data) {
    const div = document.getElementById('incomingTakeover');
    document.getElementById('incomingDjName').textContent = data.requesterName || 'A DJ';
    document.getElementById('incomingDjAvatar').src = data.requesterAvatar || '/place-holder.webp';
    div.classList.remove('hidden');
    div.dataset.requesterId = data.requesterId;
  }
  
  function hideIncomingTakeover() {
    document.getElementById('incomingTakeover').classList.add('hidden');
  }
  
  function showTakeoverApproved(data) {
    const div = document.getElementById('takeoverApproved');
    document.getElementById('takeoverServerUrl').textContent = data.serverUrl || 'rtmp://stream.freshwax.co.uk/live';
    document.getElementById('takeoverStreamKey').textContent = data.streamKey || '-';
    div.classList.remove('hidden');
    document.getElementById('takeoverRequest').classList.add('hidden');
    document.getElementById('noStreamTakeover').classList.add('hidden');
  }
  
  // REPLACED BY PUSHER MODULE - chat messages now handled via Pusher channel
  // function subscribeToChat() { ... }
  
  function renderMessages(messages) {
    const container = document.getElementById('chatMessages');
    
    if (messages.length === 0) {
      container.innerHTML = `
        <div class="chat-welcome">
          <p>Welcome to the DJ Lobby! üëã</p>
          <p class="hint">Chat with other DJs, coordinate sets, and hang out.</p>
        </div>
      `;
      return;
    }
    
    container.innerHTML = messages.map(msg => {
      const time = msg.createdAt?.toDate ? 
        msg.createdAt.toDate().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : '';
      
      return `
        <div class="chat-message">
          <div class="chat-message-content">
            <div class="chat-message-header">
              <span class="chat-message-name">${escapeHtml(msg.name || 'DJ')}</span>
              <span class="chat-message-time">${time}</span>
            </div>
            <div class="chat-message-text">${escapeHtml(msg.text)}</div>
          </div>
        </div>
      `;
    }).join('');
    
    container.scrollTop = container.scrollHeight;
  }
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // ============================================
  // DM SYSTEM
  // ============================================
  
  function getDmChannelId(uid1, uid2) {
    // Create consistent channel ID regardless of who initiates
    return [uid1, uid2].sort().join('_');
  }
  
  function openDmModal() {
    document.getElementById('dmModal').classList.remove('hidden');
    document.getElementById('dmSelectView').classList.remove('hidden');
    document.getElementById('dmChatView').classList.add('hidden');
    populateDmDjList();
  }
  
  function closeDmModal() {
    document.getElementById('dmModal').classList.add('hidden');
    
    // Clean up DM messages from Firestore
    if (dmTargetDj && currentUser) {
      cleanupDmMessages();
    }
    
    // Unsubscribe from DM listener
    if (dmUnsubscribe) {
      dmUnsubscribe();
      dmUnsubscribe = null;
    }
    
    // Reset state
    dmTargetDj = null;
    dmMessages = [];
    document.getElementById('dmMessages').innerHTML = `
      <div class="dm-welcome">
        <p>Start a private conversation</p>
        <p class="hint">Only you and this DJ can see these messages.</p>
      </div>
    `;
  }
  
  function populateDmDjList() {
    const list = document.getElementById('dmDjList');
    const otherDjs = onlineDjsCache.filter(dj => dj.odamiMa !== currentUser?.uid);
    
    if (otherDjs.length === 0) {
      list.innerHTML = '<p class="empty-state">No other DJs online</p>';
      return;
    }
    
    list.innerHTML = otherDjs.map(dj => {
      const avatarLetter = dj.avatarLetter || (dj.name ? dj.name.charAt(0).toUpperCase() : 'D');
      const hasAvatar = dj.avatar && dj.avatar !== '/place-holder.webp';
      const isLive = currentStream && currentStream.djId === dj.odamiMa;
      
      return `
        <div class="dm-dj-item" data-dj-id="${dj.odamiMa}" data-dj-name="${escapeHtml(dj.name || 'DJ')}" data-dj-avatar="${dj.avatar || ''}" data-dj-letter="${avatarLetter}">
          ${hasAvatar 
            ? `<img src="${dj.avatar}" alt="" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="dm-dj-avatar-letter" style="display:none;">${avatarLetter}</span>`
            : `<span class="dm-dj-avatar-letter">${avatarLetter}</span>`
          }
          <div class="dm-dj-info">
            <div class="dm-dj-name">${escapeHtml(dj.name || 'DJ')}</div>
            <div class="dm-dj-status">${isLive ? 'üî¥ Live now' : 'Online'}</div>
          </div>
        </div>
      `;
    }).join('');
    
    // Add click handlers
    list.querySelectorAll('.dm-dj-item').forEach(item => {
      item.addEventListener('click', () => {
        const djId = item.dataset.djId;
        const djName = item.dataset.djName;
        const djAvatar = item.dataset.djAvatar;
        const djLetter = item.dataset.djLetter;
        selectDmTarget(djId, djName, djAvatar, djLetter);
      });
    });
  }
  
  function selectDmTarget(djId, djName, djAvatar, djLetter) {
    // Use Pusher module to handle DM conversation
    openDmConversation({ id: djId, name: djName, avatar: djAvatar, letter: djLetter });
    
    // Update local reference for UI
    dmTargetDj = { id: djId, name: djName, avatar: djAvatar, letter: djLetter };
    
    // Switch to chat view
    document.getElementById('dmSelectView').classList.add('hidden');
    document.getElementById('dmChatView').classList.remove('hidden');
    document.getElementById('dmChatWithName').textContent = djName;
  }
  
  function goBackToDmList() {
    // Use Pusher module to close DM
    closeDmModal();
    
    dmTargetDj = null;
    
    // Switch to selection view
    document.getElementById('dmChatView').classList.add('hidden');
    document.getElementById('dmSelectView').classList.remove('hidden');
    populateDmDjList();
  }
  
  // REPLACED BY PUSHER MODULE - DM messages now handled via Pusher channel
  // function subscribeToDmChannel() { ... }
  
  // REPLACED BY PUSHER MODULE - DM rendering now handled by dj-lobby-pusher.js
  // function renderDmMessages() { ... }
  
  function renderDmMessages() {
    const container = document.getElementById('dmMessages');
    
    if (dmMessages.length === 0) {
      container.innerHTML = `
        <div class="dm-welcome">
          <p>Start a private conversation</p>
          <p class="hint">Only you and this DJ can see these messages.</p>
        </div>
      `;
      return;
    }
    
    container.innerHTML = dmMessages.map(msg => {
      const isSent = msg.senderId === currentUser?.uid;
      const time = msg.createdAt?.toDate ? 
        msg.createdAt.toDate().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : '';
      
      return `
        <div class="dm-message ${isSent ? 'sent' : ''}">
          <div class="dm-message-content">
            <div class="dm-message-name">${isSent ? 'You' : escapeHtml(msg.senderName || 'DJ')}</div>
            <div class="dm-message-text">${escapeHtml(msg.text)}</div>
            <div class="dm-message-time">${time}</div>
          </div>
        </div>
      `;
    }).join('');
    
    container.scrollTop = container.scrollHeight;
  }
  
  async function sendDmMessage() {
    const input = document.getElementById('dmInput');
    const text = input.value.trim();
    if (!text) return;
    
    input.value = '';
    
    try {
      // Use Pusher module to send DM (handles API + Pusher broadcast)
      await sendDm(text);
    } catch (e) {
      console.error('DM send error:', e);
      input.value = text;
    }
  }
  
  async function cleanupDmMessages() {
    if (!dmTargetDj || !currentUser) return;
    
    try {
      const channelId = getDmChannelId(currentUser.uid, dmTargetDj.id);
      
      // Delete all messages in the channel
      const messagesRef = collection(db, 'djDirectMessages', channelId, 'messages');
      const snapshot = await getDocs(messagesRef);
      
      const deletePromises = [];
      snapshot.forEach(document => {
        deletePromises.push(deleteDoc(doc(db, 'djDirectMessages', channelId, 'messages', document.id)));
      });
      
      await Promise.all(deletePromises);
      
      // Delete channel doc
      await deleteDoc(doc(db, 'djDirectMessages', channelId));
      
    } catch (e) {
      console.error('DM cleanup error:', e);
    }
  }
  
  // REPLACED BY PUSHER MODULE - DM notifications now handled via private Pusher channel
  // function subscribeToIncomingDms() { ... }
  
  function showDmNotification(senderId, senderName, message) {
    const notif = document.getElementById('dmNotification');
    const text = document.getElementById('dmNotifText');
    
    text.textContent = `New DM from ${senderName}`;
    notif.dataset.senderId = senderId;
    notif.dataset.senderName = senderName;
    notif.classList.remove('hidden');
    
    // Auto-hide after 10 seconds
    setTimeout(() => {
      notif.classList.add('hidden');
    }, 10000);
  }
  
  function openDmFromNotification() {
    const notif = document.getElementById('dmNotification');
    const senderId = notif.dataset.senderId;
    const senderName = notif.dataset.senderName;
    
    notif.classList.add('hidden');
    
    // Find the sender in online DJs cache
    const senderDj = onlineDjsCache.find(dj => dj.odamiMa === senderId);
    if (senderDj) {
      openDmModal();
      const avatarLetter = senderDj.avatarLetter || (senderDj.name ? senderDj.name.charAt(0).toUpperCase() : 'D');
      selectDmTarget(senderId, senderDj.name || senderName, senderDj.avatar || '', avatarLetter);
    } else {
      // DJ went offline, just open modal
      openDmModal();
    }
  }

  async function sendMessage() {
    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    if (!text) return;
    
    input.value = '';
    
    try {
      // Use Pusher module's sendChatMessage (handles API + Pusher broadcast)
      await sendChatMessage(text);
    } catch (e) {
      console.error('Send error:', e);
      input.value = text;
    }
  }
  
  function updateEndStreamButton(isLive, isMyStream) {
    const btn = document.getElementById('lobbyEndStreamBtn');
    const status = document.getElementById('endStreamStatus');
    const canEnd = isMyStream || userInfo?.isAdmin;
    
    if (isLive && canEnd) {
      btn.classList.remove('disabled');
      btn.disabled = false;
      btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
      if (isMyStream) {
        status.textContent = 'You are currently live';
        status.classList.add('live');
      } else {
        status.textContent = `Admin: End ${currentStream?.djName || 'DJ'}'s stream`;
        status.classList.add('live');
      }
    } else if (isLive) {
      btn.classList.add('disabled');
      btn.disabled = true;
      btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
      status.textContent = `${currentStream?.djName || 'Another DJ'} is streaming`;
      status.classList.remove('live');
    } else {
      btn.classList.add('disabled');
      btn.disabled = true;
      btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
      status.textContent = 'No active stream';
      status.classList.remove('live');
    }
  }
  
  function updateTakeoverAttemptsUI() {
    const attemptsLeft = MAX_TAKEOVER_ATTEMPTS - takeoverAttempts;
    const attemptsEl = document.getElementById('takeoverAttemptsLeft');
    const limitEl = document.getElementById('takeoverLimitReached');
    const btn = document.getElementById('requestTakeoverBtn');
    
    if (attemptsLeft <= 0) {
      attemptsEl.classList.add('hidden');
      limitEl.classList.remove('hidden');
      btn.classList.add('disabled');
      btn.disabled = true;
    } else {
      attemptsEl.classList.remove('hidden');
      limitEl.classList.add('hidden');
      attemptsEl.textContent = `${attemptsLeft} request${attemptsLeft !== 1 ? 's' : ''} remaining this session`;
      if (!takeoverPending) {
        btn.classList.remove('disabled');
        btn.disabled = false;
      }
    }
  }
  
  function clearTakeoverTimeout() {
    if (takeoverTimeout) {
      clearInterval(takeoverTimeout);
      takeoverTimeout = null;
    }
    takeoverPending = false;
  }
  
  function setupEventListeners() {
    // DM Modal
    document.getElementById('openDmBtn').addEventListener('click', openDmModal);
    document.getElementById('closeDmBtn').addEventListener('click', closeDmModal);
    document.querySelector('.dm-modal-overlay').addEventListener('click', closeDmModal);
    document.getElementById('dmBackBtn').addEventListener('click', goBackToDmList);
    
    document.getElementById('dmSendBtn').addEventListener('click', sendDmMessage);
    document.getElementById('dmInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendDmMessage();
    });
    
    // DM Notification
    document.getElementById('dmNotifOpenBtn').addEventListener('click', openDmFromNotification);
    document.getElementById('dmNotifDismissBtn').addEventListener('click', () => {
      document.getElementById('dmNotification').classList.add('hidden');
    });
    
    // Sign out
    document.getElementById('signOutBtn').addEventListener('click', async () => {
      try {
        if (presenceRef) {
          await deleteDoc(presenceRef);
        }
        await signOut(auth);
        window.location.href = '/live';
      } catch (e) {
        console.error('Sign out error:', e);
        window.location.href = '/live';
      }
    });
    
    // Lobby End Stream button
    document.getElementById('lobbyEndStreamBtn').addEventListener('click', async () => {
      const btn = document.getElementById('lobbyEndStreamBtn');
      if (btn.classList.contains('disabled')) return;
      
      if (!confirm('Are you sure you want to end your stream?')) return;
      
      try {
        btn.disabled = true;
        btn.innerHTML = '<span class="end-icon">‚è≥</span><span class="end-text">Ending...</span>';
        
        // Use current stream's DJ ID (for admin ending someone else's stream)
        const targetDjId = currentStream?.djId || currentUser.uid;
        
        const token = await currentUser.getIdToken();
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            action: 'endStream',
            djId: targetDjId,
            isAdmin: userInfo?.isAdmin || false
          })
        });
        
        const result = await response.json();
        if (result.success) {
          updateEndStreamButton(false, false);
          await recordStreamEnd(); // Record when stream ended for chat cleanup
          await loadStreamStatus();
        } else {
          alert('Failed to end stream: ' + (result.error || 'Unknown error'));
          btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
          btn.disabled = false;
        }
      } catch (e) {
        console.error('End stream error:', e);
        alert('Failed to end stream');
        btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
        btn.disabled = false;
      }
    });
    
    // Chat
    document.getElementById('sendBtn').addEventListener('click', sendMessage);
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });
    
    // Play/Pause
    document.getElementById('playPauseBtn').addEventListener('click', () => {
      const audio = document.getElementById('audioElement');
      const playIcon = document.getElementById('playIcon');
      const pauseIcon = document.getElementById('pauseIcon');
      
      if (!audio.src && currentStream?.streamUrl) {
        audio.src = currentStream.streamUrl;
        audio.play();
      } else if (audio.paused) {
        audio.play();
      } else {
        audio.pause();
      }
      
      playIcon.classList.toggle('hidden', !audio.paused);
      pauseIcon.classList.toggle('hidden', audio.paused);
    });
    
    // Volume
    document.getElementById('volumeSlider').addEventListener('input', (e) => {
      document.getElementById('audioElement').volume = e.target.value / 100;
    });
    
    document.getElementById('muteBtn').addEventListener('click', () => {
      const audio = document.getElementById('audioElement');
      audio.muted = !audio.muted;
      document.getElementById('volumeSlider').value = audio.muted ? 0 : audio.volume * 100;
    });
    
    // Ready button - use presence API instead of Firestore
    document.getElementById('setReadyBtn')?.addEventListener('click', async () => {
      if (!currentUser) return;
      
      try {
        const response = await fetch('/api/dj-lobby/presence', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'heartbeat',
            userId: currentUser.uid,
            isReady: true
          })
        });
        
        if (response.ok) {
          document.getElementById('setReadyBtn').classList.add('is-ready');
          document.getElementById('readyBtnText').textContent = '‚úì Ready!';
          document.getElementById('readyStatus').classList.remove('hidden');
        } else {
          console.error('Ready error: API returned', response.status);
        }
      } catch (e) {
        console.error('Ready error:', e);
      }
    });
    
    // Takeover
    document.getElementById('requestTakeoverBtn')?.addEventListener('click', async () => {
      if (!currentStream || !currentUser) return;
      if (takeoverPending) return;
      
      // Check if limit reached
      if (takeoverAttempts >= MAX_TAKEOVER_ATTEMPTS) {
        return;
      }
      
      try {
        // Increment attempts
        takeoverAttempts++;
        takeoverPending = true;
        updateTakeoverAttemptsUI();
        
        await setDoc(doc(db, 'djTakeoverRequests', currentStream.djId), {
          requesterId: currentUser.uid,
          requesterName: userInfo.name,
          requesterAvatar: userInfo.avatar,
          targetDjId: currentStream.djId,
          targetDjName: currentStream.djName,
          status: 'pending',
          createdAt: serverTimestamp()
        });
        
        await setDoc(doc(db, 'djTakeoverRequests', `request_${currentUser.uid}`), {
          requesterId: currentUser.uid,
          targetDjId: currentStream.djId,
          status: 'pending',
          createdAt: serverTimestamp()
        });
        
        document.getElementById('requestTakeoverBtn').classList.add('hidden');
        document.getElementById('takeoverPending').classList.remove('hidden');
        
        // Start 20-second timeout countdown
        let countdown = 20;
        const countdownEl = document.getElementById('takeoverCountdown');
        countdownEl.textContent = `(${countdown}s)`;
        
        takeoverTimeout = setInterval(() => {
          countdown--;
          countdownEl.textContent = `(${countdown}s)`;
          
          if (countdown <= 0) {
            clearInterval(takeoverTimeout);
            takeoverTimeout = null;
            takeoverPending = false;
            
            // Reset UI - timeout expired
            document.getElementById('takeoverPending').classList.add('hidden');
            
            // Check if more attempts available
            if (takeoverAttempts < MAX_TAKEOVER_ATTEMPTS) {
              document.getElementById('requestTakeoverBtn').classList.remove('hidden');
              document.getElementById('requestTakeoverBtn').classList.remove('disabled');
            }
            
            updateTakeoverAttemptsUI();
            
            // Clean up the pending request
            deleteDoc(doc(db, 'djTakeoverRequests', currentStream.djId)).catch(() => {});
            deleteDoc(doc(db, 'djTakeoverRequests', `request_${currentUser.uid}`)).catch(() => {});
          }
        }, 1000);
        
      } catch (e) {
        console.error('Takeover error:', e);
        alert('Failed to send takeover request');
        takeoverPending = false;
      }
    });
    
    document.getElementById('acceptTakeoverBtn')?.addEventListener('click', async () => {
      const div = document.getElementById('incomingTakeover');
      const requesterId = div.dataset.requesterId;
      if (!requesterId || !currentUser) return;
      
      try {
        const token = await currentUser.getIdToken();
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ action: 'getStreamKey', djId: currentUser.uid })
        });
        
        const result = await response.json();
        
        await setDoc(doc(db, 'djTakeoverRequests', `request_${requesterId}`), {
          status: 'approved',
          requesterId: requesterId,
          serverUrl: result.serverUrl || 'rtmp://stream.freshwax.co.uk/live',
          streamKey: result.streamKey || 'Contact admin',
          approvedAt: serverTimestamp()
        }, { merge: true });
        
        await deleteDoc(doc(db, 'djTakeoverRequests', currentUser.uid));
        hideIncomingTakeover();
        alert('Takeover approved!');
      } catch (e) {
        console.error('Accept error:', e);
      }
    });
    
    document.getElementById('declineTakeoverBtn')?.addEventListener('click', async () => {
      const div = document.getElementById('incomingTakeover');
      const requesterId = div.dataset.requesterId;
      if (!requesterId) return;
      
      try {
        await setDoc(doc(db, 'djTakeoverRequests', `request_${requesterId}`), {
          status: 'declined',
          declinedAt: serverTimestamp()
        }, { merge: true });
        
        await deleteDoc(doc(db, 'djTakeoverRequests', currentUser.uid));
        hideIncomingTakeover();
      } catch (e) {
        console.error('Decline error:', e);
      }
    });
    
    // End stream
    document.getElementById('endStreamBtn')?.addEventListener('click', async () => {
      if (!confirm('End your stream?')) return;
      
      try {
        const token = await currentUser.getIdToken();
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ action: 'endStream', djId: currentUser.uid })
        });
        
        const result = await response.json();
        if (result.success) {
          alert('Stream ended');
          loadStreamStatus();
        } else {
          alert(result.error || 'Failed');
        }
      } catch (e) {
        console.error('End error:', e);
      }
    });
    
    // Copy buttons
    document.querySelectorAll('.copy-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const code = document.getElementById(btn.dataset.copy);
        if (code) {
          navigator.clipboard.writeText(code.textContent);
          btn.textContent = 'Copied!';
          setTimeout(() => { btn.textContent = 'Copy'; }, 2000);
        }
      });
    });
  }
</script>
</body>
</html>
