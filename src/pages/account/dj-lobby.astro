---
// src/pages/account/dj-lobby.astro
// DJ-only lobby with stream preview, private chat, streaming instructions, and takeover system
import '../../styles/dj-lobby.css';
import LiveChat from '../../components/live/LiveChat.astro';
export const prerender = false;

// Pusher config for client-side (PUBLIC_ prefixed vars are safe to expose)
const pusherConfig = {
  key: import.meta.env.PUBLIC_PUSHER_KEY || '',
  cluster: import.meta.env.PUBLIC_PUSHER_CLUSTER || 'eu'
};

// Firebase config for client-side
const firebaseConfig = {
  apiKey: import.meta.env.PUBLIC_FIREBASE_API_KEY || 'AIzaSyBiZGsWdvA9ESm3OsUpZ-VQpwqMjMpBY6g',
  authDomain: "freshwax-store.firebaseapp.com",
  projectId: "freshwax-store",
  storageBucket: "freshwax-store.firebasestorage.app",
  messagingSenderId: "675435782973",
  appId: "1:675435782973:web:e8459c2ec4a5f6d683db54"
};

// HLS URL for preview player - always use production stream URL
const hlsBaseUrl = 'https://stream.freshwax.co.uk';

// Get admin key from environment (server-side only) for bypass requests
const runtime = (Astro.locals as any).runtime;
const ADMIN_KEY = runtime?.env?.ADMIN_KEY || '';
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DJ Lobby - Fresh Wax</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- HLS.js for video playback -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>

  <!-- Configuration - must be set before scripts load -->
  <script define:vars={{ pusherConfig, hlsBaseUrl, ADMIN_KEY, firebaseConfig }}>
    window.PUSHER_CONFIG = pusherConfig;
    window.HLS_BASE_URL = hlsBaseUrl;
    window.ADMIN_KEY = ADMIN_KEY;
    window.FIREBASE_CONFIG = firebaseConfig;
  </script>
</head>
<body class="dj-lobby-page">
  <!-- Auth Gate -->
  <div id="authGate" class="auth-gate">
    <div class="auth-content">
      <div class="loading-dots wave">
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
      </div>
      <p>Checking DJ access</p>
    </div>
  </div>
  
  <!-- Access Denied -->
  <div id="accessDenied" class="access-denied hidden">
    <div class="denied-content">
      <div class="denied-icon">üîí</div>
      <h1>DJ Access Only</h1>
      <p>This area is restricted to approved DJs.</p>
      <a href="/live" class="back-btn">Back to Live</a>
    </div>
  </div>
  
  <!-- Not Eligible - Needs mix with likes -->
  <div id="notEligible" class="not-eligible hidden">
    <div class="not-eligible-content">
      <div class="not-eligible-icon">üéß</div>
      <h1>ALMOST <span class="red">THERE</span></h1>
      <p id="eligibilityMessage">You need to build your reputation before accessing the DJ Lobby.</p>
      
      <!-- Two-column layout: Requirements on left, Access options on right -->
      <div class="eligibility-layout">
        <!-- Left column: Requirements -->
        <div class="eligibility-left">
          <div class="eligibility-requirements">
            <h3>To Access DJ Lobby, You Need:</h3>
            <div class="requirement-list">
              <div id="reqMixes" class="requirement">
                <span class="req-icon">‚ùå</span>
                <span class="req-text">At least 1 DJ mix uploaded</span>
              </div>
              <div id="reqLikes" class="requirement">
                <span class="req-icon">‚ùå</span>
                <span class="req-text">At least 10 likes on one of your mixes</span>
              </div>
            </div>

            <div id="progressInfo" class="progress-info">
              <p>Your best mix: <span id="bestMixLikes">0</span>/10 likes</p>
              <div class="progress-bar">
                <div id="likesProgress" class="progress-fill" style="width: 0%"></div>
              </div>
            </div>
          </div>

          <div class="eligibility-actions">
            <a href="/upload-mix" class="action-btn primary">Upload a Mix ‚Üí</a>
            <a href="/dj-mixes" class="action-btn secondary">View DJ Mixes</a>
            <a href="/live" class="action-btn secondary">Back to Live</a>
          </div>
        </div>

        <!-- Right column: Access options -->
        <div class="eligibility-right">
          <!-- Bypass Request Section -->
          <div id="bypassRequestSection" class="bypass-request-section">
            <!-- Request Form State -->
            <div id="bypassRequestForm" class="bypass-form-card">
              <div class="bypass-header">
                <span class="bypass-icon">‚ö°</span>
                <div>
                  <h4>Need access now?</h4>
                  <p>Request bypass access - an admin will review and approve.</p>
                </div>
              </div>
              <div class="bypass-form-inner">
                <textarea id="bypassReason" placeholder="Why do you need immediate access? (optional)" rows="2" maxlength="200"></textarea>
                <button id="submitBypassRequest" class="bypass-request-btn">
                  üé´ Request Bypass Access
                </button>
              </div>
            </div>

            <!-- Pending State -->
            <div id="bypassPending" class="bypass-status-card pending hidden">
              <div class="status-header">
                <span class="status-icon">‚è≥</span>
                <div>
                  <h4>Request Pending</h4>
                  <p>Your bypass request has been submitted. You'll get access once an admin approves it.</p>
                </div>
              </div>
              <button id="cancelBypassRequest" class="cancel-bypass-btn">Cancel Request</button>
            </div>

            <!-- Approved State -->
            <div id="bypassApproved" class="bypass-status-card approved hidden">
              <div class="status-header">
                <span class="status-icon">‚úÖ</span>
                <div>
                  <h4>Bypass Approved!</h4>
                  <p>Your request has been approved. Click below to enter the lobby.</p>
                </div>
              </div>
              <button id="continueWithBypass" class="continue-bypass-btn">Enter DJ Lobby ‚Üí</button>
            </div>

            <!-- Denied State -->
            <div id="bypassDenied" class="bypass-status-card denied hidden">
              <div class="status-header">
                <span class="status-icon">‚ùå</span>
                <div>
                  <h4>Request Denied</h4>
                  <p id="bypassDenialReason">Your request was not approved at this time.</p>
                </div>
              </div>
              <button id="resubmitBypassRequest" class="resubmit-bypass-btn">Submit New Request</button>
            </div>
          </div>

          <!-- Quick Access Key Section -->
          <div id="quickAccessSection" class="quick-access-section">
            <div class="quick-access-card">
              <div class="quick-access-header">
                <span class="quick-access-icon">üîë</span>
                <div>
                  <h4>Have an access code?</h4>
                  <p>Enter a quick access code to gain instant DJ lobby access.</p>
                </div>
              </div>
              <div class="quick-access-form">
                <input type="text" id="quickAccessCodeInput" placeholder="Enter access code" maxlength="10" autocomplete="off" />
                <button id="redeemAccessCodeBtn" class="redeem-code-btn">
                  <span class="btn-text">Redeem Code</span>
                  <span class="btn-spinner hidden">‚è≥</span>
                </button>
              </div>
              <p id="quickAccessError" class="quick-access-error hidden"></p>
              <p id="quickAccessSuccess" class="quick-access-success hidden"></p>
            </div>
          </div>
        </div>
      </div>

      <div class="eligibility-why">
        <h4>Why this requirement?</h4>
        <p>This helps ensure our livestreams feature genuine DJs who play jungle and drum & bass music. Upload a quality mix, get your fans to show some love, and you'll be in the lobby in no time! üîä</p>
      </div>
    </div>
  </div>
  
  <!-- Main Lobby -->
  <div id="mainLobby" class="lobby-container hidden">
    <header class="lobby-header">
      <div class="header-left">
        <div class="user-info">
          <div class="header-avatar-container">
            <img id="headerAvatar" src="/place-holder.webp" alt="" class="header-avatar" />
            <div id="headerAvatarLetter" class="header-avatar-letter hidden">?</div>
          </div>
          <span id="headerName" class="header-name">Loading...</span>
        </div>
      </div>
      <div class="header-center">
        <h1>DJ <span class="red">LOBBY</span></h1>
        <p>Private space for Fresh Wax DJs</p>
      </div>
      <div class="header-right">
        <div id="headerTimeRemaining" class="header-time-remaining hidden">
          <span id="headerTimeLeft" class="header-time-value">--:--</span>
          <span class="header-time-label">remaining</span>
        </div>
        <a href="/live" class="back-link">
          <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
            <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
          </svg>
          Back to Live
        </a>
        <button id="signOutBtn" class="sign-out-btn">Sign Out</button>
      </div>
    </header>
    
    <div class="lobby-layout">
      <!-- Far Left Column: Stream Key -->
      <div class="key-column">
        <!-- Stream Control Card -->
        <div class="stream-control-card">
          <button id="setReadyBtn" class="go-live-btn glow">
            <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
              <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
            </svg>
            <span id="readyBtnText">I'm Ready!</span>
          </button>
          <!-- GO LIVE button - shown after I'm Ready is pressed -->
          <button id="goLiveBtn" class="go-live-btn go-live-final hidden">
            <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
              <circle cx="12" cy="12" r="8" fill="#dc2626"/>
              <circle cx="12" cy="12" r="4" fill="#fff"/>
            </svg>
            <span id="goLiveBtnText">GO LIVE!</span>
          </button>
          <div class="control-divider"></div>
          <button id="lobbyEndStreamBtn" class="lobby-end-stream-btn disabled" disabled>
            <span class="end-icon">‚èπ</span>
            <span class="end-text">End Stream</span>
          </button>
          <p id="endStreamStatus" class="end-stream-status">No active stream</p>
        </div>
        
        <!-- Takeover Section -->
        <div class="takeover-section" id="takeoverBox">
          <div class="section-header">
            <h3>üîÑ Stream Takeover</h3>
          </div>
          
          <div id="takeoverRequest" class="takeover-content hidden">
            <p>Request to take over from <strong id="takeoverFromName">DJ</strong></p>
            <button id="requestTakeoverBtn" class="takeover-btn">Request Takeover</button>
            <p id="takeoverPending" class="takeover-pending hidden">‚è≥ Waiting for response... <span id="takeoverCountdown"></span></p>
            <p id="takeoverAttemptsLeft" class="takeover-attempts">3 requests remaining this session</p>
            <p id="takeoverLimitReached" class="takeover-limit hidden">‚ö†Ô∏è No requests remaining this session</p>
          </div>
          
          <div id="incomingTakeover" class="incoming-takeover hidden">
            <div class="incoming-badge">‚ö° TAKEOVER REQUEST</div>
            <div class="incoming-dj">
              <img id="incomingDjAvatar" src="/place-holder.webp" alt="" />
              <div>
                <strong id="incomingDjName">DJ Name</strong>
                <span>wants to take over</span>
              </div>
            </div>
            <div class="incoming-actions">
              <button id="acceptTakeoverBtn" class="accept-btn">‚úì Accept</button>
              <button id="declineTakeoverBtn" class="decline-btn">‚úï Decline</button>
            </div>
          </div>
          
          <div id="takeoverApproved" class="takeover-approved hidden">
            <div class="approved-badge">‚úì APPROVED</div>
            <p>Copy these into OBS:</p>
            <div class="takeover-creds">
              <div class="cred-row">
                <label>Server</label>
                <div class="cred-value">
                  <code id="takeoverServerUrl">-</code>
                  <button class="copy-btn" data-copy="takeoverServerUrl">Copy</button>
                </div>
              </div>
              <div class="cred-row">
                <label>Key</label>
                <div class="cred-value">
                  <code id="takeoverStreamKey">-</code>
                  <button class="copy-btn" data-copy="takeoverStreamKey">Copy</button>
                </div>
              </div>
            </div>
          </div>
          
          <div id="noStreamTakeover" class="no-stream-msg">
            <p>No active stream to take over.</p>
          </div>
        </div>

        <!-- Streaming Setup Link -->
        <div class="setup-link-section">
          <a href="/account/streaming-setup" class="setup-link-btn">
            <span class="setup-text">Streaming Setup</span>
            <span class="setup-arrow">‚Üí</span>
          </a>
        </div>

        <!-- DJs Online Box -->
        <div class="djs-online-box">
          <div class="box-header">
            <h3>üéß DJs in Lobby <span class="online-count-inline" id="onlineDjCount">0</span></h3>
            <button id="openDmBtn" class="dm-btn">DM</button>
          </div>
          <div id="djsList" class="djs-list">
            <p class="empty-state">No DJs online yet</p>
          </div>
        </div>
      </div>
      
      <!-- Middle Column: Preview Only -->
      <div class="main-column">
        <!-- Split Video Players -->
        <div class="preview-section">
          <div class="split-players three-col">
            <!-- Left: Your Preview (DJ's own test stream) -->
            <div class="player-panel obs-panel">
              <div class="panel-header">
                <span class="panel-title">Your Preview</span>
                <div class="connection-indicators">
                  <div class="indicator" id="serverIndicator" title="Server Connection">
                    <span class="indicator-dot disconnected" id="serverDot"></span>
                    <span class="indicator-label">Server</span>
                  </div>
                  <div class="indicator source-toggle active" id="obsIndicator" title="OBS Stream - Click to select">
                    <span class="indicator-dot disconnected" id="obsDot"></span>
                    <span class="indicator-label">OBS</span>
                  </div>
                  <div class="indicator source-toggle" id="buttIndicator" title="BUTT Audio Stream - Click to select">
                    <span class="indicator-dot disconnected" id="buttDot"></span>
                    <span class="indicator-label">BUTT</span>
                  </div>
                </div>
              </div>
              <div class="player-wrapper" id="obsPlayerWrapper">
                <div id="obsOfflineState" class="offline-state">
                  <div class="offline-icon">üì∫</div>
                  <h3>Waiting for Stream</h3>
                  <p>Start OBS and your stream will appear here</p>
                </div>
                <div id="obsVideoPreview" class="video-preview hidden">
                  <video id="obsVideo" playsinline autoplay muted></video>
                </div>
                <!-- BUTT Audio-Only Placeholder -->
                <div id="buttAudioPreview" class="butt-audio-preview hidden">
                  <div class="butt-placeholder">
                    <div class="butt-branding"><span class="fresh">Fresh</span><span class="wax">Wax</span></div>
                    <div class="butt-spectrum" id="buttSpectrum">
                      <canvas id="buttWaveformCanvas" width="280" height="100"></canvas>
                    </div>
                    <div class="butt-info">
                      <div class="butt-dj-row">
                        <svg class="butt-headphones" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <path d="M3 18v-6a9 9 0 0 1 18 0v6"/>
                          <path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3v5z"/>
                          <path d="M3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3v5z"/>
                        </svg>
                        <span class="butt-dj-name" id="buttDjName">DJ Name</span>
                      </div>
                      <span class="butt-stream-title" id="buttStreamTitle"></span>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Center: Realtime Stats -->
            <div class="center-stats-panel">
              <div class="center-stat">
                <span class="center-stat-value" id="centerViewers">0</span>
                <span class="center-stat-label">Viewers</span>
              </div>
              <div class="center-stat">
                <span class="center-stat-value" id="centerBitrate">--</span>
                <span class="center-stat-label">Bitrate</span>
              </div>
              <div class="center-stat">
                <span class="center-stat-value" id="centerResolution">--</span>
                <span class="center-stat-label">Resolution</span>
              </div>
              <div class="center-stat">
                <span class="center-stat-value" id="centerFps">--</span>
                <span class="center-stat-label">FPS</span>
              </div>
              <div class="center-stat">
                <span class="center-stat-value" id="centerLatency">--</span>
                <span class="center-stat-label">Latency</span>
              </div>
              <div class="center-stat">
                <span class="center-stat-value" id="centerUptime">--</span>
                <span class="center-stat-label">Uptime</span>
              </div>
            </div>

            <!-- Right: Live Stream (Current Broadcast) -->
            <div class="player-panel live-panel">
              <div class="panel-header">
                <span class="panel-title">Live Stream</span>
                <div class="stream-status" id="streamStatus">
                  <span class="status-dot offline"></span>
                  <span id="statusText">No one streaming</span>
                </div>
                <div class="relay-indicators hidden" id="relayIndicators">
                  <div class="indicator" id="youtubeIndicator" title="YouTube Relay">
                    <span class="indicator-dot disconnected" id="youtubeDot"></span>
                    <span class="indicator-label">YT</span>
                  </div>
                  <div class="indicator" id="twitchIndicator" title="Twitch Relay">
                    <span class="indicator-dot disconnected" id="twitchDot"></span>
                    <span class="indicator-label">TW</span>
                  </div>
                </div>
              </div>
              <div class="player-wrapper preview-player" id="previewPlayer">
                <div id="offlineState" class="offline-state">
                  <div class="offline-icon">üì°</div>
                  <h3>No Live Stream</h3>
                  <p>Be the first to go live!</p>
                </div>

                <div id="videoPreview" class="video-preview hidden">
                  <video id="hlsVideo" playsinline autoplay></video>
                </div>

                <div id="audioPreview" class="audio-preview hidden">
                  <div class="audio-visualizer">
                    <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                    <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                    <div class="viz-bar"></div><div class="viz-bar"></div>
                  </div>
                  <img id="streamCover" src="/place-holder.webp" alt="Stream" class="stream-cover" />
                  <audio id="audioElement" crossorigin="anonymous" autoplay></audio>
                </div>

                <!-- Time Remaining (now shown in header) -->
                <div id="timeRemaining" class="time-remaining hidden" style="display:none;">
                  <span class="time-label">Time Remaining</span>
                  <span id="timeLeft" class="time-value">--:--</span>
                </div>

              </div>
            </div>
          </div>

          <!-- Audio Controls Bar (Below Players) - LED indicators with audio toggle -->
          <div class="audio-controls-bar">
            <!-- OBS Preview Meter -->
            <div class="control-group obs-controls" id="obsControls">
              <div class="meter-label">PREVIEW</div>
              <div class="led-meter" id="obsStereoMeter">
                <div class="led-row left" id="obsLeftLeds">
                  <span class="led led-red"></span>
                  <span class="led led-red"></span>
                  <span class="led led-orange"></span>
                  <span class="led led-orange"></span>
                  <span class="led led-yellow"></span>
                  <span class="led led-yellow"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                </div>
                <div class="led-center"></div>
                <div class="led-row right" id="obsRightLeds">
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-yellow"></span>
                  <span class="led led-yellow"></span>
                  <span class="led led-orange"></span>
                  <span class="led led-orange"></span>
                  <span class="led led-red"></span>
                  <span class="led led-red"></span>
                </div>
              </div>
            </div>

            <!-- Audio Toggle Button -->
            <button type="button" class="audio-toggle-btn" id="audioToggleBtn" title="Switch Audio Source">
              <span class="toggle-arrow left-arrow active">‚óÄ</span>
              <span class="toggle-label">AUDIO</span>
              <span class="toggle-arrow right-arrow">‚ñ∂</span>
            </button>

            <!-- Live Stream Meter -->
            <div class="control-group live-controls" id="liveControls">
              <div class="meter-label">LIVE OUTPUT</div>
              <div class="led-meter" id="liveStereoMeter">
                <div class="led-row left" id="liveLeftLeds">
                  <span class="led led-red"></span>
                  <span class="led led-red"></span>
                  <span class="led led-orange"></span>
                  <span class="led led-orange"></span>
                  <span class="led led-yellow"></span>
                  <span class="led led-yellow"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                </div>
                <div class="led-center"></div>
                <div class="led-row right" id="liveRightLeds">
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-green"></span>
                  <span class="led led-yellow"></span>
                  <span class="led led-yellow"></span>
                  <span class="led led-orange"></span>
                  <span class="led led-orange"></span>
                  <span class="led led-red"></span>
                  <span class="led led-red"></span>
                </div>
              </div>
            </div>
          </div>

          <!-- Professional Broadcast Audio Panel (visible only when streaming) -->
          <div class="broadcast-audio-panel hidden" id="broadcastAudioPanel">
            <div class="panel-header">
              <span class="panel-title">BROADCAST AUDIO</span>
              <div class="panel-controls">
                <button type="button" class="panel-btn" id="audioSourceToggle" title="Toggle Source">
                  <span class="source-label">PREVIEW</span>
                </button>
                <button type="button" class="panel-btn" id="calibrateBtn" title="Calibrate Meters">CAL</button>
                <button type="button" class="panel-btn" id="panelMinimize" title="Minimize">‚àí</button>
              </div>
            </div>
            <!-- Calibration Panel (hidden by default) -->
            <div id="calibrationPanel" class="calibration-panel hidden">
              <div class="cal-row">
                <label>Gain Offset (dB):</label>
                <input type="range" id="calGainOffset" min="-12" max="12" value="0" step="0.5">
                <span id="calGainValue">0 dB</span>
              </div>
              <div class="cal-row">
                <label>Reference Level:</label>
                <select id="calRefLevel">
                  <option value="-23">-23 LUFS (EBU R128)</option>
                  <option value="-24">-24 LUFS (ATSC A/85)</option>
                  <option value="-16">-16 LUFS (Streaming)</option>
                  <option value="-14">-14 LUFS (Podcast)</option>
                </select>
              </div>
              <div class="cal-row">
                <button type="button" class="panel-btn" id="calReset">Reset</button>
                <button type="button" class="panel-btn" id="calClose">Close</button>
              </div>
            </div>

            <div class="meters-container" id="metersContainer">
              <!-- LEFT: Mute Button + LUFS -->
              <div class="meter-column left-column">
                <div class="mute-section">
                  <button type="button" class="mute-btn-panel" id="obsMuteBtn" title="Toggle Preview Audio">
                    <svg class="muted-icon" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                      <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
                    </svg>
                    <svg class="unmuted-icon hidden" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                      <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                    <span class="mute-label">PRV</span>
                  </button>
                </div>
                <div class="lufs-container">
                  <div class="lufs-header">LOUDNESS</div>
                  <div class="lufs-content">
                    <div class="lufs-main">
                      <div class="lufs-value" id="lufsIntegrated">-23.0</div>
                      <div class="lufs-unit">LUFS</div>
                    </div>
                    <div class="lufs-secondary">
                      <div class="lufs-item">
                        <span class="lufs-label">SHORT</span>
                        <span class="lufs-val" id="lufsShort">-23.0</span>
                      </div>
                      <div class="lufs-item">
                        <span class="lufs-label">MOM</span>
                        <span class="lufs-val" id="lufsMomentary">-23.0</span>
                      </div>
                      <div class="lufs-item">
                        <span class="lufs-label">RANGE</span>
                        <span class="lufs-val" id="lufsRange">0.0 LU</span>
                      </div>
                    </div>
                  </div>
                  <div class="lufs-bar-track">
                    <div class="lufs-bar-fill" id="lufsBarFill"></div>
                    <div class="lufs-target-marker" style="left: 38.5%;" title="-23 LUFS Target"></div>
                  </div>
                </div>
              </div>

              <!-- CENTER: True Peak | VU Meters | PPM (horizontal layout) -->
              <div class="meter-column center-column">
                <div class="center-meters-row">
                  <!-- True Peak (Left of VU) -->
                  <div class="meter-section peak-section">
                    <div class="section-label">TRUE PEAK</div>
                    <div class="peak-meters">
                      <div class="vertical-meter">
                        <div class="meter-channel-label">L</div>
                        <div class="meter-track">
                          <div class="meter-segments" id="truePeakL">
                            <div class="segment seg-red"></div>
                            <div class="segment seg-red"></div>
                            <div class="segment seg-orange"></div>
                            <div class="segment seg-orange"></div>
                            <div class="segment seg-yellow"></div>
                            <div class="segment seg-yellow"></div>
                            <div class="segment seg-green"></div>
                            <div class="segment seg-green"></div>
                            <div class="segment seg-green"></div>
                            <div class="segment seg-green"></div>
                            <div class="segment seg-green-dark"></div>
                            <div class="segment seg-green-dark"></div>
                          </div>
                          <div class="peak-hold" id="truePeakHoldL"></div>
                        </div>
                        <div class="meter-value" id="truePeakValL">-‚àû</div>
                      </div>
                      <div class="vertical-meter">
                        <div class="meter-channel-label">R</div>
                        <div class="meter-track">
                          <div class="meter-segments" id="truePeakR">
                            <div class="segment seg-red"></div>
                            <div class="segment seg-red"></div>
                            <div class="segment seg-orange"></div>
                            <div class="segment seg-orange"></div>
                            <div class="segment seg-yellow"></div>
                            <div class="segment seg-yellow"></div>
                            <div class="segment seg-green"></div>
                            <div class="segment seg-green"></div>
                            <div class="segment seg-green"></div>
                            <div class="segment seg-green"></div>
                            <div class="segment seg-green-dark"></div>
                            <div class="segment seg-green-dark"></div>
                          </div>
                          <div class="peak-hold" id="truePeakHoldR"></div>
                        </div>
                        <div class="meter-value" id="truePeakValR">-‚àû</div>
                      </div>
                    </div>
                  </div>

                  <!-- VU Meters (Center - Large) -->
                  <div class="vu-meters">
                    <div class="vu-meter" id="vuMeterL">
                      <div class="vu-display">
                        <div class="vu-scale-arc">
                          <svg viewBox="0 0 120 70" class="vu-svg">
                            <path d="M 10 60 A 50 50 0 0 1 110 60" fill="none" stroke="#333" stroke-width="2"/>
                            <path d="M 85 25 A 50 50 0 0 1 110 60" fill="none" stroke="#dc2626" stroke-width="4"/>
                            <text x="12" y="55" class="vu-text">-20</text>
                            <text x="28" y="38" class="vu-text">-10</text>
                            <text x="48" y="28" class="vu-text">-7</text>
                            <text x="58" y="24" class="vu-text">-5</text>
                            <text x="70" y="24" class="vu-text">-3</text>
                            <text x="82" y="28" class="vu-text vu-zero">0</text>
                            <text x="95" y="38" class="vu-text vu-red">+1</text>
                            <text x="105" y="55" class="vu-text vu-red">+3</text>
                          </svg>
                          <div class="vu-needle" id="vuNeedleL"></div>
                          <div class="vu-needle-pivot"></div>
                        </div>
                      </div>
                      <div class="vu-label">L</div>
                    </div>
                    <div class="vu-meter" id="vuMeterR">
                      <div class="vu-display">
                        <div class="vu-scale-arc">
                          <svg viewBox="0 0 120 70" class="vu-svg">
                            <path d="M 10 60 A 50 50 0 0 1 110 60" fill="none" stroke="#333" stroke-width="2"/>
                            <path d="M 85 25 A 50 50 0 0 1 110 60" fill="none" stroke="#dc2626" stroke-width="4"/>
                            <text x="12" y="55" class="vu-text">-20</text>
                            <text x="28" y="38" class="vu-text">-10</text>
                            <text x="48" y="28" class="vu-text">-7</text>
                            <text x="58" y="24" class="vu-text">-5</text>
                            <text x="70" y="24" class="vu-text">-3</text>
                            <text x="82" y="28" class="vu-text vu-zero">0</text>
                            <text x="95" y="38" class="vu-text vu-red">+1</text>
                            <text x="105" y="55" class="vu-text vu-red">+3</text>
                          </svg>
                          <div class="vu-needle" id="vuNeedleR"></div>
                          <div class="vu-needle-pivot"></div>
                        </div>
                      </div>
                      <div class="vu-label">R</div>
                    </div>
                  </div>

                  <!-- PPM (Right of VU) -->
                  <div class="meter-section ppm-section">
                    <div class="section-label">PPM</div>
                    <div class="ppm-meters">
                      <div class="vertical-meter ppm-meter">
                        <div class="meter-channel-label">L</div>
                        <div class="meter-track ppm-track">
                          <div class="ppm-fill" id="ppmFillL"></div>
                          <div class="ppm-peak-hold" id="ppmPeakL"></div>
                        </div>
                        <div class="meter-value" id="ppmValL">-‚àû</div>
                      </div>
                      <div class="vertical-meter ppm-meter">
                        <div class="meter-channel-label">R</div>
                        <div class="meter-track ppm-track">
                          <div class="ppm-fill" id="ppmFillR"></div>
                          <div class="ppm-peak-hold" id="ppmPeakR"></div>
                        </div>
                        <div class="meter-value" id="ppmValR">-‚àû</div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- RIGHT: Stereo + Volume Fader -->
              <div class="meter-column right-column">
                <div class="stereo-container">
                  <div class="stereo-header">STEREO</div>
                  <div class="correlation-meter">
                    <div class="correlation-scale">
                      <span>-1</span><span>0</span><span>+1</span>
                    </div>
                    <div class="correlation-track">
                      <div class="correlation-fill" id="correlationFill"></div>
                      <div class="correlation-needle" id="correlationNeedle"></div>
                      <div class="correlation-center"></div>
                    </div>
                  </div>
                  <div class="stereo-scope">
                    <canvas id="stereoCanvas" width="70" height="70"></canvas>
                  </div>
                </div>
                <div class="mute-section">
                  <button type="button" class="mute-btn-panel" id="liveMuteBtn" title="Toggle Live Audio">
                    <svg class="muted-icon hidden" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                      <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
                    </svg>
                    <svg class="unmuted-icon" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                      <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                    <span class="mute-label">OUT</span>
                  </button>
                </div>
              </div>
            </div>
          </div>

        </div>

        <!-- Go Live Setup Section -->
        <div class="stream-key-section" id="streamKeySection">
          <div id="keyAvailable" class="key-available">
            <div class="go-live-grid-compact">
              <div class="setup-row">
                <div class="cred-box-compact">
                  <label>Server</label>
                  <div class="cred-value-compact">
                    <code id="rtmpUrl" class="url-scrolling"><span class="url-text">rtmp://rtmp.freshwax.co.uk/live</span></code>
                    <button class="copy-btn-sm" data-copy="rtmpUrl">Copy</button>
                  </div>
                </div>
                <div class="cred-box-compact">
                  <label>Key</label>
                  <div class="cred-value-compact">
                    <code id="myStreamKey" class="key-loading"><span class="key-generating"><span class="spawn-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span> Spawning</span></code>
                    <button class="copy-btn-sm" data-copy="myStreamKey">Copy</button>
                  </div>
                </div>
              </div>

              <div class="setup-row">
                <div class="setup-field">
                  <label for="inlineStreamTitle">Title</label>
                  <input type="text" id="inlineStreamTitle" placeholder="Friday Night Session" maxlength="60" />
                </div>
                <div class="setup-field">
                  <label for="inlineStreamGenre">Genre</label>
                  <select id="inlineStreamGenre">
                    <option value="Jungle / D&B">Jungle / D&B</option>
                    <option value="Jungle">Jungle</option>
                    <option value="Drum & Bass">Drum & Bass</option>
                    <option value="Liquid D&B">Liquid D&B</option>
                    <option value="Ragga Jungle">Ragga Jungle</option>
                    <option value="Neurofunk">Neurofunk</option>
                    <option value="Jump Up">Jump Up</option>
                    <option value="Breakbeat">Breakbeat</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Multi Streaming Section (Collapsible) - Hidden when live -->
        <div class="multi-stream-section" id="multiStreamSection">
          <button class="multi-stream-header" id="toggleMultiStream" type="button">
            <div class="multi-stream-icon-lg">
              <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8h2v8H9zm4 2h2v6h-2z"/>
              </svg>
            </div>
            <div class="multi-stream-title">
              <h3>Multi Streaming</h3>
              <p>Broadcast to multiple platforms</p>
            </div>
            <div class="multi-stream-toggle">
              <svg class="toggle-chevron" viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
              </svg>
            </div>
          </button>

          <div class="multi-stream-content hidden" id="multiStreamContent">
          <div class="pro-stream-grid">
            <!-- Twitch Section -->
            <div class="pro-stream-card">
              <div class="pro-card-header">
                <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18" class="twitch-color">
                  <path d="M11.571 4.714h1.715v5.143H11.57zm4.715 0H18v5.143h-1.714zM6 0L1.714 4.286v15.428h5.143V24l4.286-4.286h3.428L22.286 12V0zm14.571 11.143l-3.428 3.428h-3.429l-3 3v-3H6.857V1.714h13.714Z"/>
                </svg>
                <span>Twitch</span>
              </div>
              <div class="pro-card-body">
                <div class="pro-input-row">
                  <input type="text" id="twitchUsername" placeholder="Username" autocomplete="off" />
                </div>
                <div class="pro-input-row">
                  <input type="password" id="twitchStreamKey" placeholder="Stream Key" autocomplete="off" />
                </div>
                <button type="button" class="pro-save-btn" id="saveTwitchBtn">Save</button>
              </div>
            </div>

            <!-- Relay Section -->
            <div class="pro-stream-card">
              <div class="pro-card-header">
                <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18" class="relay-color">
                  <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                </svg>
                <span>Relay Source</span>
              </div>
              <div class="pro-card-body">
                <div class="pro-input-row with-btn">
                  <input type="text" id="relayUrl" placeholder="Stream URL to relay" autocomplete="off" />
                  <button type="button" class="pro-select-btn" id="openRelayModal" title="Browse stations">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
                      <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                  </button>
                </div>
                <span id="relaySourceName" class="relay-hint"></span>
              </div>
            </div>

            <!-- Output URL Section -->
            <div class="pro-stream-card output-card">
              <div class="pro-card-header">
                <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18" class="output-color">
                  <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8h2v8H9zm4 2h2v6h-2zm-8 4h2v2H5z"/>
                </svg>
                <span>Your Output URL</span>
              </div>
              <div class="pro-card-body">
                <div class="output-url-row">
                  <code id="outputUrl">https://stream.freshwax.co.uk/live/freshwax-main/index.m3u8</code>
                  <button class="pro-copy-btn" id="copyOutputUrl">Copy</button>
                </div>
                <span class="output-hint">Share with stations to relay your stream</span>
              </div>
            </div>
          </div>

          <!-- Share Button -->
          <div class="share-btn-row">
            <button id="openShareModal" class="share-btn-main">
              <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/>
              </svg>
              <span>Share Stream</span>
            </button>
          </div>
          </div><!-- End multi-stream-content -->
        </div>
      </div>

      <!-- Relay Sources Modal -->
      <div id="relaySourcesModal" class="modal-overlay hidden">
        <div class="modal-content relay-modal">
          <div class="modal-header">
            <h3>Select Radio Station</h3>
            <button class="modal-close-btn" id="closeRelayModal">&times;</button>
          </div>
          <div class="modal-body">
            <p class="modal-hint">Select a station you're currently streaming on to relay through Fresh Wax</p>
            <div id="relaySourcesList" class="relay-sources-list">
              <div class="loading-sources">
                <div class="loading-dots wave">
                  <span class="dot"></span>
                  <span class="dot"></span>
                  <span class="dot"></span>
                </div>
                <span>Loading stations</span>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button class="modal-btn secondary" id="clearRelaySource">Clear Selection</button>
            <button class="modal-btn primary" id="confirmRelaySource">Confirm</button>
          </div>
        </div>
      </div>

      <!-- Share Stream Modal -->
      <div id="shareStreamModal" class="modal-overlay hidden">
        <div class="modal-content share-modal">
          <div class="modal-header">
            <h3>Share Your Stream</h3>
            <button class="modal-close-btn" id="closeShareModal">&times;</button>
          </div>
          <div class="modal-body">
            <!-- Stream Info Preview -->
            <div class="share-stream-info">
              <div class="share-stream-details">
                <span class="share-dj-name" id="shareDjName">DJ Name</span>
                <span class="share-stream-title" id="shareStreamTitle">Live Session</span>
                <span class="share-stream-genre" id="shareStreamGenre">Jungle / D&B</span>
              </div>
            </div>

            <!-- Thumbnail Section -->
            <div class="share-thumbnail-section">
              <div class="share-thumb-preview" id="shareThumbPreview">
                <div class="share-thumb-placeholder" id="shareThumbPlaceholder">
                  <span>üì∏</span>
                  <span>No thumbnail</span>
                </div>
                <img id="shareThumbImg" src="" alt="Stream thumbnail" class="hidden" />
              </div>
              <div class="share-thumb-actions">
                <button id="shareCaptureBtn" class="share-action-btn capture">
                  <span>üì∏</span> Capture from Stream
                </button>
                <button id="shareClearThumbBtn" class="share-action-btn clear hidden">
                  <span>‚úï</span> Clear
                </button>
              </div>
            </div>

            <!-- Post Text -->
            <div class="share-post-section">
              <label for="sharePostText">Your message</label>
              <textarea id="sharePostText" class="share-post-input" placeholder="üéß I'm live on Fresh Wax! Tune in now..." maxlength="280" rows="3"></textarea>
              <span class="share-char-count"><span id="shareCharCount">0</span>/280</span>
            </div>

            <!-- Share Platforms -->
            <div class="share-platforms">
              <button id="shareToTwitter" class="share-platform-btn twitter">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                <span>Post to X</span>
              </button>
              <button id="shareToFacebook" class="share-platform-btn facebook">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg>
                <span>Share on Facebook</span>
              </button>
              <button id="shareCopyLink" class="share-platform-btn copy-link">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                <span>Copy Link</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Column: Chat + Viewers -->
      <div class="right-column">
        <!-- Live Stream Chat (mirrors main live page) -->
        <LiveChat />

        <!-- Relay Chat (shown when streaming via relay) -->
        <div id="relayChatSection" class="relay-chat-section hidden">
          <div class="relay-chat-header">
            <h3>üì∫ <span id="relayChatSourceName">Source Chat</span></h3>
            <button id="toggleRelayChatBtn" class="toggle-relay-chat-btn" title="Toggle chat">‚àí</button>
          </div>
          <div id="relayChatContainer" class="relay-chat-container">
            <iframe id="relayChatFrame" class="relay-chat-frame" allow="autoplay" allowfullscreen></iframe>
            <div id="relayChatUnsupported" class="relay-chat-unsupported hidden">
              <p>Chat embed not available for this platform.</p>
              <a id="relayChatExternalLink" href="#" target="_blank" rel="noopener" class="open-chat-link">Open Chat in New Tab ‚Üí</a>
            </div>
          </div>
        </div>

      </div>
    </div>

    <footer class="lobby-footer">
      <span>Fresh Wax</span>
      <span class="footer-dot">‚Ä¢</span>
      <span>DJ Lobby</span>
    </footer>
    
    <!-- DM Modal -->
    <div id="dmModal" class="dm-modal hidden">
      <div class="dm-modal-overlay"></div>
      <div class="dm-modal-content">
        <div class="dm-modal-header">
          <h2>üì© Direct Message</h2>
          <button id="closeDmBtn" class="close-dm-btn">‚úï</button>
        </div>
        
        <!-- DJ Selection View -->
        <div id="dmSelectView" class="dm-view">
          <p class="dm-select-hint">Select a DJ to message privately:</p>
          <div id="dmDjList" class="dm-dj-list">
            <p class="empty-state">No other DJs online</p>
          </div>
          <div class="dm-notice">
            <span class="notice-icon">‚ö†Ô∏è</span>
            <span>Messages are not stored and will be deleted when this chat closes.</span>
          </div>
        </div>
        
        <!-- Chat View -->
        <div id="dmChatView" class="dm-view hidden">
          <div class="dm-chat-header">
            <button id="dmBackBtn" class="dm-back-btn">‚Üê Back</button>
            <div class="dm-chat-with">
              <span id="dmChatWithName">DJ Name</span>
            </div>
          </div>
          <div class="dm-messages" id="dmMessages">
            <div class="dm-welcome">
              <p>Start a private conversation</p>
              <p class="hint">Only you and this DJ can see these messages.</p>
            </div>
          </div>
          <div class="dm-input-section">
            <div class="dm-input-wrapper">
              <input type="text" id="dmInput" placeholder="Type a message..." maxlength="500" autocomplete="off" />
              <button id="dmSendBtn" type="button">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                  <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="dm-notice small">
            <span class="notice-icon">‚ö†Ô∏è</span>
            <span>This chat is temporary and not stored.</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- DM Notification -->
    <div id="dmNotification" class="dm-notification hidden">
      <div class="dm-notif-content">
        <span class="dm-notif-icon">üí¨</span>
        <span id="dmNotifText">New DM from DJ Name</span>
        <button id="dmNotifOpenBtn" class="dm-notif-open">Open</button>
        <button id="dmNotifDismissBtn" class="dm-notif-dismiss">‚úï</button>
      </div>
    </div>
  </div>


<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
  import { getAuth, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
  import { getFirestore, collection, query, orderBy, limit, addDoc, serverTimestamp, doc, setDoc, deleteDoc, getDocs, getDoc, where } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';
  
  // Pusher-based real-time features (replaces Firebase onSnapshot)
  import { 
    initDjLobbyPusher, 
    sendChatMessage, 
    requestTakeover, 
    approveTakeover, 
    declineTakeover,
    openDmConversation,
    sendDm,
    cleanup as cleanupPusher,
    getOnlineDjs
  } from '/dj-lobby-pusher.js?v=3';
  
  const app = initializeApp(window.FIREBASE_CONFIG);

  const auth = getAuth(app);
  // Expose auth globally for pusher module to get idToken
  window.firebaseAuth = auth;
  const db = getFirestore(app);

  // Debug logging - set to false for production
  const DEBUG = false;
  const log = (...args) => DEBUG && console.log(...args);

  // Normalize HLS URLs to use the correct base URL (handles old trycloudflare URLs)
  function normalizeHlsUrl(url) {
    if (!url) return url;
    const correctBaseUrl = window.HLS_BASE_URL || 'https://stream.freshwax.co.uk';
    // Extract the path after the domain (e.g., /live/stream_key/index.m3u8)
    const match = url.match(/\/live\/[^\/]+\/index\.m3u8$/);
    if (match) {
      return correctBaseUrl + match[0];
    }
    return url;
  }

  let currentUser = null;
  let userInfo = null;
  let currentStream = null;
  let mySlot = null;
  let presenceRef = null;
  let streamStartTime = null;
  let streamEndTime = null;
  let previousStreamDjId = null; // Track DJ changes for seamless transitions
  let allDjSlots = []; // Cache of all scheduled slots for consecutive slot calculation
  let userSubscription = { tier: 'free', isPro: false }; // User subscription status
  let currentEventSession = null; // Track if current stream is part of an event (no mid-session breaks)

  // HLS Player state
  let hlsPlayer = null;
  let isVideoPlaying = false;
  let currentHlsUrl = null; // Track current URL to avoid re-initializing

  // Stream info panel state
  let infoPanelDurationInterval = null;

  // OBS Preview Player state (DJ's own test stream)
  let obsHlsPlayer = null;
  let currentObsPreviewUrl = null;
  let obsPreviewCheckInterval = null;

  // Preview source state: 'obs' or 'butt' - for switching between OBS video and BUTT audio-only
  let currentPreviewSource = 'obs';
  let buttAudioSource = 'obs'; // Which audio source to use for BUTT spectrum: 'obs' or 'live'

  // Stream key for preview (can be set via ?testPreview=key for testing)
  const urlParams = new URLSearchParams(window.location.search);
  console.log('[Test Mode] URL params:', window.location.search);
  let currentStreamKey = urlParams.get('testPreview') || null;
  const forcePreview = urlParams.has('forcePreview');
  // Allow overriding HLS base URL for testing (e.g., ?hlsBase=https://tunnel.trycloudflare.com)
  const testHlsBase = urlParams.get('hlsBase');
  if (testHlsBase) {
    window.HLS_BASE_URL = testHlsBase;
    console.log('[Test Mode] Using custom HLS base URL:', testHlsBase);
  }
  // Test preview function - can be triggered by button or URL param
  function loadTestPreview() {
    console.log('[Test Mode] Loading test video...');
    const videoEl = document.getElementById('obsVideo');
    const offlineState = document.getElementById('obsOfflineState');
    const videoPreview = document.getElementById('obsVideoPreview');
    const customUrlInput = document.getElementById('customHlsUrl');

    console.log('[Test Mode] Elements:', { videoEl: !!videoEl, offlineState: !!offlineState, videoPreview: !!videoPreview });

    if (videoEl && offlineState && videoPreview) {
      offlineState.classList.add('hidden');
      videoPreview.classList.remove('hidden');

      // Use custom URL if provided, otherwise use Big Buck Bunny test stream
      const customUrl = customUrlInput?.value?.trim();
      const testUrl = customUrl || 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8';
      console.log('[Test Mode] Loading URL:', testUrl, customUrl ? '(custom)' : '(default test)');

      if (typeof Hls !== 'undefined' && Hls.isSupported()) {
        console.log('[Test Mode] Using HLS.js');
        const hls = new Hls();
        hls.loadSource(testUrl);
        hls.attachMedia(videoEl);
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          console.log('[Test Mode] HLS manifest parsed, playing...');
          videoEl.play().catch(e => console.error('[Test Mode] Play error:', e));
        });
        hls.on(Hls.Events.ERROR, (e, data) => console.error('[Test Mode] HLS error:', data));
      } else {
        console.log('[Test Mode] Using native HLS');
        videoEl.src = testUrl;
        videoEl.play().catch(e => console.error('[Test Mode] Play error:', e));
      }
    } else {
      console.error('[Test Mode] Video elements not found!');
      alert('Video elements not found - check console');
    }
  }

  // Add click handler for test button
  document.getElementById('testPreviewBtn')?.addEventListener('click', loadTestPreview);

  // Add click handler for stop button
  document.getElementById('stopPreviewBtn')?.addEventListener('click', () => {
    const videoEl = document.getElementById('obsVideo');
    const offlineState = document.getElementById('obsOfflineState');
    const videoPreview = document.getElementById('obsVideoPreview');
    if (videoEl) {
      videoEl.pause();
      videoEl.src = '';
    }
    offlineState?.classList.remove('hidden');
    videoPreview?.classList.add('hidden');
    console.log('[Test Mode] Preview stopped');
  });

  // Direct test mode - use ?directTest to load a known working test video
  const directTest = urlParams.has('directTest');
  if (directTest) {
    console.log('[Test Mode] DIRECT TEST - Loading test video immediately');
    setTimeout(loadTestPreview, 1000);
  }

  if (currentStreamKey) {
    console.log('[Test Mode] Using test preview stream key:', currentStreamKey);
    if (forcePreview) {
      console.log('[Test Mode] Force preview enabled - skipping availability check');
      // Force start preview check immediately after page loads
      setTimeout(() => {
        console.log('[Test Mode] Force starting preview check...');
        startObsPreviewCheck();
      }, 2000);
    }
  }

  // Takeover limiting - max 3 attempts per session
  let takeoverAttempts = 0;
  const MAX_TAKEOVER_ATTEMPTS = 3;
  let takeoverTimeout = null;
  let takeoverPending = false;
  
  // DM System
  let dmTargetDj = null;
  let dmMessages = [];
  let dmUnsubscribe = null;
  let onlineDjsCache = [];
  let authInitialized = false;
  
  // Auth timeout - if auth check takes too long, offer refresh
  let authTimeout = setTimeout(() => {
    if (!authInitialized) {
      log('[DJLobby] Auth timeout - no response after 8 seconds');
      const authGate = document.getElementById('authGate');
      if (authGate) {
        authGate.innerHTML = `
          <div class="auth-content">
            <div class="not-eligible-icon">‚è≥</div>
            <h2 style="margin: 1rem 0 0.5rem; color: #fff;">Taking too long?</h2>
            <p style="color: #aaa; margin-bottom: 1.5rem;">Authentication is taking longer than expected.</p>
            <button onclick="location.reload()" class="action-btn primary">Refresh Page</button>
            <a href="/live" class="action-btn secondary" style="margin-top: 0.75rem; display: inline-block;">Back to Live</a>
          </div>
        `;
      }
    }
  }, 8000);
  
  onAuthStateChanged(auth, async (user) => {
    authInitialized = true;
    clearTimeout(authTimeout);
    if (!user) {
      window.location.href = '/login?redirect=/account/dj-lobby';
      return;
    }
    currentUser = user;
    
    // Set a timeout for the access check itself
    const accessCheckTimeout = setTimeout(() => {
      log('[DJLobby] Access check timeout - no response after 15 seconds');
      const authGate = document.getElementById('authGate');
      if (authGate && !authGate.classList.contains('hidden')) {
        authGate.innerHTML = `
          <div class="auth-content">
            <div class="not-eligible-icon">‚ö†Ô∏è</div>
            <h2 style="margin: 1rem 0 0.5rem; color: #fff;">Connection Issue</h2>
            <p style="color: #aaa; margin-bottom: 1.5rem;">Unable to verify DJ access. Please check your connection and try again.</p>
            <button onclick="location.reload()" class="action-btn primary">Try Again</button>
            <a href="/live" class="action-btn secondary" style="margin-top: 0.75rem; display: inline-block;">Back to Live</a>
          </div>
        `;
      }
    }, 15000);
    
    await checkDjAccess(user.uid);
    clearTimeout(accessCheckTimeout);
  });
  
  async function checkDjAccess(userId) {
    try {
      log('[DJ Lobby] Checking access for:', userId);
      
      // Helper function with timeout
      const fetchWithTimeout = async (url, timeout = 10000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          return response;
        } catch (e) {
          clearTimeout(timeoutId);
          throw e;
        }
      };
      
      // Check user type first - pass email for admin check
      const userEmail = currentUser?.email ? encodeURIComponent(currentUser.email) : '';
      let response;
      try {
        response = await fetchWithTimeout(`/api/get-user-type?uid=${userId}&email=${userEmail}`);
      } catch (e) {
        console.error('[DJ Lobby] get-user-type fetch failed:', e);
        showAccessDenied();
        return;
      }
      
      if (!response.ok) {
        console.error('[DJ Lobby] get-user-type returned', response.status);
        showAccessDenied();
        return;
      }
      
      const result = await response.json();
      log('[DJ Lobby] User type result:', result);
      
      if (!result.success) { 
        console.error('[DJ Lobby] get-user-type failed:', result.error);
        showAccessDenied(); 
        return; 
      }
      
      const isAdmin = result.isAdmin === true;
      // Use Firebase Auth displayName (same as Header.astro) - this is the public name
      const displayName = currentUser.displayName || result.partnerDisplayName || result.name || 'DJ';
      
      userInfo = {
        id: userId,
        uid: userId,  // Also add uid for bypass request compatibility
        name: displayName,
        firstName: displayName.split(' ')[0] || 'D',
        avatar: result.avatarUrl || currentUser.photoURL || null,
        email: currentUser.email,
        isAdmin: isAdmin
      };
      
      log('[DJ Lobby] User info set:', { displayName, firebaseDisplayName: currentUser.displayName, apiPartnerDisplayName: result.partnerDisplayName, avatarUrl: result.avatarUrl, photoURL: currentUser.photoURL, finalAvatar: userInfo.avatar });
      
      // Check eligibility (must have mix with 10+ likes OR have bypass approval)
      log('[DJ Lobby] Checking eligibility...');
      let eligibilityResponse;
      try {
        eligibilityResponse = await fetchWithTimeout(`/api/check-dj-eligibility?userId=${userId}`);
      } catch (e) {
        console.error('[DJ Lobby] check-dj-eligibility fetch failed:', e);
        showNotEligible({ reason: 'error', message: 'Could not verify eligibility. Please try again.' });
        return;
      }
      
      if (!eligibilityResponse.ok) {
        console.error('[DJ Lobby] check-dj-eligibility returned', eligibilityResponse.status);
        showNotEligible({ reason: 'error', message: 'Could not verify eligibility. Please try again.' });
        return;
      }
      
      const eligibility = await eligibilityResponse.json();
      log('[DJ Lobby] Eligibility result:', eligibility);
      
      if (!eligibility.success) {
        console.error('[DJ Lobby] Eligibility check failed:', eligibility.error);
        showNotEligible({ reason: 'error', message: 'Could not verify eligibility. Please try again.' });
        return;
      }
      
      if (!eligibility.eligible && !isAdmin) {
        log('[DJ Lobby] User not eligible, showing requirements');
        showNotEligible(eligibility);
        return;
      }
      
      log('[DJ Lobby] Access granted, showing lobby');

      // Check subscription tier from eligibility response
      userSubscription = {
        tier: eligibility.subscriptionTier || 'free',
        isPro: eligibility.subscriptionTier === 'pro' || eligibility.subscriptionTier === 'premium' || userInfo.isAdmin
      };

      showLobby();
      initLobby();
      updateProFeatures();
    } catch (e) {
      console.error('[DJ Lobby] Access check failed:', e);
      showAccessDenied();
    }
  }
  
  function showNotEligible(eligibility) {
    document.getElementById('authGate').classList.add('hidden');
    document.getElementById('accessDenied').classList.add('hidden');
    document.getElementById('notEligible').classList.remove('hidden');
    
    const icon = document.querySelector('.not-eligible-icon');
    const title = document.querySelector('.not-eligible-content h1');
    const requirements = document.querySelector('.eligibility-requirements');
    const actions = document.querySelector('.eligibility-actions');
    const whySection = document.querySelector('.eligibility-why');
    
    // Handle banned status
    if (eligibility.reason === 'banned') {
      icon.textContent = 'üö´';
      title.innerHTML = 'ACCESS <span class="red">SUSPENDED</span>';
      document.getElementById('eligibilityMessage').textContent = eligibility.message || 'Your account has been suspended from streaming.';
      requirements.innerHTML = `
        <div class="banned-notice">
          <p>Your streaming privileges have been suspended.</p>
          ${eligibility.bannedReason ? `<p class="ban-reason">Reason: ${eligibility.bannedReason}</p>` : ''}
          <p class="contact-info">If you believe this is a mistake, please contact us.</p>
        </div>
      `;
      actions.innerHTML = `
        <a href="/contact" class="action-btn primary">Contact Support</a>
        <a href="/live" class="action-btn secondary">Back to Live</a>
      `;
      whySection.classList.add('hidden');
      document.getElementById('bypassRequestSection')?.classList.add('hidden');
      return;
    }
    
    // Handle on-hold status
    if (eligibility.reason === 'on_hold') {
      icon.textContent = '‚è∏Ô∏è';
      title.innerHTML = 'ON <span class="red">HOLD</span>';
      document.getElementById('eligibilityMessage').textContent = eligibility.message || 'Your streaming access is temporarily on hold.';
      requirements.innerHTML = `
        <div class="hold-notice">
          <p>Your streaming access is temporarily restricted.</p>
          ${eligibility.holdReason ? `<p class="hold-reason">Reason: ${eligibility.holdReason}</p>` : ''}
          <p class="contact-info">Please contact us if you have questions.</p>
        </div>
      `;
      actions.innerHTML = `
        <a href="/contact" class="action-btn primary">Contact Support</a>
        <a href="/live" class="action-btn secondary">Back to Live</a>
      `;
      whySection.classList.add('hidden');
      document.getElementById('bypassRequestSection')?.classList.add('hidden');
      return;
    }
    
    // Default eligibility check (mixes/likes)
    icon.textContent = 'üéß';
    title.innerHTML = 'ALMOST <span class="red">THERE</span>';
    document.getElementById('eligibilityMessage').textContent = eligibility.message || 'You need to build your reputation before accessing the DJ Lobby.';
    
    // Update requirements
    const reqMixes = document.getElementById('reqMixes');
    const reqLikes = document.getElementById('reqLikes');
    
    if (reqMixes && eligibility.mixCount > 0) {
      reqMixes.classList.add('met');
      reqMixes.querySelector('.req-icon').textContent = '‚úÖ';
    }
    
    if (reqLikes && eligibility.qualifyingMixes > 0) {
      reqLikes.classList.add('met');
      reqLikes.querySelector('.req-icon').textContent = '‚úÖ';
    }
    
    // Always show progress - update values (defaults to 0 if not available)
    const bestLikes = eligibility.bestMixLikes || 0;
    const requiredLikes = eligibility.requiredLikes || 10;
    document.getElementById('bestMixLikes').textContent = bestLikes;
    const progress = Math.min(100, (bestLikes / requiredLikes) * 100);
    document.getElementById('likesProgress').style.width = progress + '%';
    
    whySection.classList.remove('hidden');
    
    // Check and show bypass request status
    checkBypassStatus(eligibility);
    startBypassPolling();
  }
  
  // ==========================================
  // BYPASS REQUEST FUNCTIONALITY
  // ==========================================
  
  let currentBypassStatus = null;
  let bypassPollInterval = null;
  
  async function checkBypassStatus(eligibility) {
    if (!userInfo?.uid) return;
    
    try {
      const response = await fetch(`/api/admin/bypass-requests?action=status&userId=${userInfo.uid}`);
      const result = await response.json();
      
      if (result.success) {
        currentBypassStatus = { ...result, ...eligibility };
        updateBypassUI(result);
      }
    } catch (error) {
      console.error('[Bypass] Error checking status:', error);
    }
  }
  
  function updateBypassUI(status) {
    const form = document.getElementById('bypassRequestForm');
    const pending = document.getElementById('bypassPending');
    const approved = document.getElementById('bypassApproved');
    const denied = document.getElementById('bypassDenied');
    
    form?.classList.add('hidden');
    pending?.classList.add('hidden');
    approved?.classList.add('hidden');
    denied?.classList.add('hidden');
    
    if (!status.hasRequest) {
      form?.classList.remove('hidden');
    } else if (status.request?.status === 'pending') {
      pending?.classList.remove('hidden');
    } else if (status.request?.status === 'approved') {
      approved?.classList.remove('hidden');
    } else if (status.request?.status === 'denied') {
      denied?.classList.remove('hidden');
      if (status.request?.denialReason) {
        const reasonEl = document.getElementById('bypassDenialReason');
        if (reasonEl) reasonEl.textContent = `Your request was not approved: ${status.request.denialReason}`;
      }
    }
  }
  
  function startBypassPolling() {
    if (bypassPollInterval) return;
    bypassPollInterval = setInterval(async () => {
      if (currentBypassStatus?.request?.status === 'pending') {
        await checkBypassStatus(currentBypassStatus);
        if (currentBypassStatus?.request?.status === 'approved') {
          stopBypassPolling();
        }
      }
    }, 60000); // 60s instead of 30s to reduce Firebase reads
  }
  
  function stopBypassPolling() {
    if (bypassPollInterval) {
      clearInterval(bypassPollInterval);
      bypassPollInterval = null;
    }
  }
  
  // Submit bypass request
  document.getElementById('submitBypassRequest')?.addEventListener('click', async () => {
    const btn = document.getElementById('submitBypassRequest');
    const reason = document.getElementById('bypassReason')?.value?.trim() || '';
    
    if (!userInfo?.uid) {
      alert('Please sign in first');
      return;
    }
    
    btn.disabled = true;
    btn.textContent = 'Submitting...';
    
    try {
      const response = await fetch('/api/admin/bypass-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'request',
          userId: userInfo.uid,
          djName: userInfo.name || userInfo.email?.split('@')[0],
          email: userInfo.email,
          reason: reason || null,
          mixCount: currentBypassStatus?.mixCount || 0,
          bestMixLikes: currentBypassStatus?.bestMixLikes || 0
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        await checkBypassStatus(currentBypassStatus || {});
      } else {
        alert(result.error || 'Failed to submit request');
        btn.disabled = false;
        btn.textContent = 'üé´ Request Bypass Access';
      }
    } catch (error) {
      console.error('[Bypass] Submit error:', error);
      alert('Failed to submit request. Please try again.');
      btn.disabled = false;
      btn.textContent = 'üé´ Request Bypass Access';
    }
  });
  
  // Cancel bypass request
  document.getElementById('cancelBypassRequest')?.addEventListener('click', async () => {
    if (!confirm('Cancel your bypass request?')) return;

    try {
      const response = await fetch('/api/admin/bypass-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancel',
          userId: userInfo.uid,
          adminKey: window.ADMIN_KEY
        })
      });
      
      const result = await response.json();
      if (result.success) {
        await checkBypassStatus(currentBypassStatus || {});
      } else {
        alert(result.error || 'Failed to cancel request');
      }
    } catch (error) {
      console.error('[Bypass] Cancel error:', error);
    }
  });
  
  // Continue with bypass (after approval)
  document.getElementById('continueWithBypass')?.addEventListener('click', () => {
    location.reload();
  });
  
  // Resubmit after denial
  document.getElementById('resubmitBypassRequest')?.addEventListener('click', async () => {
    try {
      await fetch('/api/admin/bypass-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancel',
          userId: userInfo.uid,
          adminKey: window.ADMIN_KEY
        })
      });
      await checkBypassStatus(currentBypassStatus || {});
    } catch (error) {
      console.error('[Bypass] Resubmit error:', error);
    }
  });

  // Quick Access Code Redemption
  document.getElementById('redeemAccessCodeBtn')?.addEventListener('click', async () => {
    const codeInput = document.getElementById('quickAccessCodeInput');
    const btn = document.getElementById('redeemAccessCodeBtn');
    const errorEl = document.getElementById('quickAccessError');
    const successEl = document.getElementById('quickAccessSuccess');
    const btnText = btn?.querySelector('.btn-text');
    const btnSpinner = btn?.querySelector('.btn-spinner');

    const code = codeInput?.value?.trim();
    if (!code) {
      errorEl.textContent = 'Please enter an access code';
      errorEl.classList.remove('hidden');
      successEl.classList.add('hidden');
      return;
    }

    // Show loading state
    btn.disabled = true;
    btnText?.classList.add('hidden');
    btnSpinner?.classList.remove('hidden');
    errorEl.classList.add('hidden');
    successEl.classList.add('hidden');

    try {
      const response = await fetch('/api/redeem-access-key', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          code: code,
          userId: userInfo.uid,
          userEmail: userInfo.email,
          userName: userInfo.name
        })
      });

      const result = await response.json();

      if (result.success) {
        successEl.textContent = result.message || 'Access granted! Redirecting to lobby...';
        successEl.classList.remove('hidden');
        errorEl.classList.add('hidden');

        // Brief delay then reload to show lobby
        setTimeout(() => {
          window.location.reload();
        }, 1500);
      } else {
        errorEl.textContent = result.error || 'Invalid access code';
        errorEl.classList.remove('hidden');
        successEl.classList.add('hidden');

        // Reset button
        btn.disabled = false;
        btnText?.classList.remove('hidden');
        btnSpinner?.classList.add('hidden');
      }
    } catch (error) {
      console.error('[QuickAccess] Redeem error:', error);
      errorEl.textContent = 'Failed to redeem code. Please try again.';
      errorEl.classList.remove('hidden');
      successEl.classList.add('hidden');

      // Reset button
      btn.disabled = false;
      btnText?.classList.remove('hidden');
      btnSpinner?.classList.add('hidden');
    }
  });

  // Allow Enter key to submit the quick access code
  document.getElementById('quickAccessCodeInput')?.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      document.getElementById('redeemAccessCodeBtn')?.click();
    }
  });

  // Toggle Twitch stream key visibility
  document.getElementById('toggleTwitchKeyVisibility')?.addEventListener('click', () => {
    const input = document.getElementById('twitchStreamKey');
    if (input) {
      input.type = input.type === 'password' ? 'text' : 'password';
    }
  });

  // Relay Sources Modal
  let relaySources = [];
  let selectedRelaySource = null;

  async function loadRelaySources() {
    try {
      const response = await fetch('/api/livestream/relay-sources');
      const result = await response.json();
      if (result.success && result.sources) {
        relaySources = result.sources.filter(s => s.active);
        renderRelaySources();
      }
    } catch (e) {
      console.error('Error loading relay sources:', e);
      document.getElementById('relaySourcesList').innerHTML =
        '<div class="no-sources-message">Unable to load stations</div>';
    }
  }

  function renderRelaySources() {
    const container = document.getElementById('relaySourcesList');
    if (!container) return;

    if (relaySources.length === 0) {
      container.innerHTML = '<div class="no-sources-message">No radio stations configured yet</div>';
      return;
    }

    container.innerHTML = relaySources.map(source => `
      <div class="relay-source-item ${selectedRelaySource?.id === source.id ? 'selected' : ''}"
           data-id="${source.id}"
           data-url="${source.streamUrl}"
           data-name="${source.name}">
        <img src="${source.logoUrl || '/place-holder.webp'}" alt="${source.name}" class="relay-source-logo" />
        <div class="relay-source-info">
          <div class="relay-source-name">${source.name}</div>
          <div class="relay-source-genre">${source.genre || 'Various'}</div>
        </div>
        <span class="relay-source-status ${source.isCurrentlyLive ? 'live' : 'offline'}">
          ${source.isCurrentlyLive ? 'Live' : 'Offline'}
        </span>
      </div>
    `).join('');

    // Add click handlers
    container.querySelectorAll('.relay-source-item').forEach(item => {
      item.addEventListener('click', () => {
        container.querySelectorAll('.relay-source-item').forEach(i => i.classList.remove('selected'));
        item.classList.add('selected');
        selectedRelaySource = {
          id: item.dataset.id,
          url: item.dataset.url,
          name: item.dataset.name
        };
      });
    });
  }

  // Open relay modal
  document.getElementById('openRelayModal')?.addEventListener('click', () => {
    document.getElementById('relaySourcesModal').classList.remove('hidden');
    loadRelaySources();
  });

  // Close relay modal
  document.getElementById('closeRelayModal')?.addEventListener('click', () => {
    document.getElementById('relaySourcesModal').classList.add('hidden');
  });

  // Click outside modal to close
  document.getElementById('relaySourcesModal')?.addEventListener('click', (e) => {
    if (e.target.id === 'relaySourcesModal') {
      document.getElementById('relaySourcesModal').classList.add('hidden');
    }
  });

  // Clear relay selection
  document.getElementById('clearRelaySource')?.addEventListener('click', () => {
    selectedRelaySource = null;
    document.getElementById('relayUrl').value = '';
    document.getElementById('relaySourceName').textContent = '';
    document.getElementById('relaySourcesList').querySelectorAll('.relay-source-item').forEach(i => i.classList.remove('selected'));
    document.getElementById('relaySourcesModal').classList.add('hidden');
  });

  // Confirm relay selection
  document.getElementById('confirmRelaySource')?.addEventListener('click', () => {
    if (selectedRelaySource) {
      document.getElementById('relayUrl').value = selectedRelaySource.url;
      document.getElementById('relaySourceName').textContent = `Relaying from: ${selectedRelaySource.name}`;
    }
    document.getElementById('relaySourcesModal').classList.add('hidden');
  });

  function showAccessDenied() {
    document.getElementById('authGate').classList.add('hidden');
    document.getElementById('accessDenied').classList.remove('hidden');
  }

  // Enable/disable pro features based on subscription
  function updateProFeatures() {
    const isPro = userSubscription?.isPro || false;
    const twitchRow = document.getElementById('twitchRow');
    const relayRow = document.getElementById('relayRow');

    if (isPro) {
      // Enable pro features
      twitchRow?.classList.remove('disabled');
      twitchRow?.classList.add('enabled');
      relayRow?.classList.remove('disabled');
      relayRow?.classList.add('enabled');

      // Enable inputs
      document.getElementById('twitchUsername')?.removeAttribute('disabled');
      document.getElementById('twitchStreamKey')?.removeAttribute('disabled');
      document.getElementById('toggleTwitchKeyVisibility')?.removeAttribute('disabled');
      document.getElementById('relayUrl')?.removeAttribute('disabled');
      document.getElementById('openRelayModal')?.removeAttribute('disabled');
    } else {
      // Disable pro features for standard accounts
      twitchRow?.classList.add('disabled');
      twitchRow?.classList.remove('enabled');
      relayRow?.classList.add('disabled');
      relayRow?.classList.remove('enabled');
    }

    log('[ProFeatures] Updated for tier:', userSubscription?.tier, 'isPro:', isPro);
  }
  
  function showLobby() {
    document.getElementById('authGate').classList.add('hidden');
    document.getElementById('mainLobby').classList.remove('hidden');
    
    // Populate header with user info
    document.getElementById('headerName').textContent = userInfo.name;
    
    // Handle avatar with letter fallback
    const avatarImg = document.getElementById('headerAvatar');
    const avatarLetter = document.getElementById('headerAvatarLetter');
    
    if (userInfo.avatar && userInfo.avatar !== '/place-holder.webp') {
      // Try to load the image
      avatarImg.onload = () => {
        avatarImg.classList.remove('hidden');
        avatarLetter.classList.add('hidden');
      };
      avatarImg.onerror = () => {
        // Image failed, show letter
        avatarImg.classList.add('hidden');
        avatarLetter.classList.remove('hidden');
        avatarLetter.textContent = getAvatarLetter(userInfo.name, userInfo.firstName);
      };
      avatarImg.src = userInfo.avatar;
    } else {
      // No avatar URL, show letter
      avatarImg.classList.add('hidden');
      avatarLetter.classList.remove('hidden');
      avatarLetter.textContent = getAvatarLetter(userInfo.name, userInfo.firstName);
    }
  }
  
  function getAvatarLetter(displayName, firstName) {
    // Try display name first, then firstName
    const name = displayName || firstName || 'D';
    return name.charAt(0).toUpperCase();
  }
  
  async function initLobby() {
    // Initialize livestream chat with default welcome message
    renderLivestreamMessages([]);

    // Load initial data from API
    await loadAllSlots(); // Load all slots for consecutive slot detection
    await loadStreamStatus();
    await checkAndCleanupChat();
    await loadMySlot();
    
    // Initialize Pusher-based real-time features (replaces Firebase onSnapshot)
    // This handles: presence, chat, takeover, DMs
    await initDjLobbyPusher(currentUser, userInfo);
    
    // Setup UI event listeners
    setupEventListeners();

    // Initialize OBS/BUTT source toggle
    initSourceToggle();

    // Load saved Twitch settings
    loadTwitchSettings();

    // Polling for non-realtime data (reduced frequency to minimize Firebase reads)
    setInterval(loadStreamStatus, 60000); // 60s instead of 10s - saves ~84% reads
    setInterval(updateTimeRemaining, 100); // Update every 100ms for tenths of a second
    setInterval(checkStreamKeyAvailability, 60000); // 60s instead of 30s
    setInterval(loadAllSlots, 60000); // Refresh slots every minute for consecutive slot detection
  }
  
  // Page cleanup - called when leaving
  function setupPageCleanup() {
    window.addEventListener('beforeunload', async () => {
      try {
        await cleanupPusher();
      } catch(e) {
        console.error('Cleanup error:', e);
      }
    });
  }
  
  // Call setup after initLobby
  setupPageCleanup();
  
  // Check if chat should be cleaned up (2 hours since last stream ended and no one is live)
  async function checkAndCleanupChat() {
    try {
      // Get chat settings doc - this may fail due to permissions, that's ok
      const settingsRef = doc(db, 'djLobbySettings', 'chatCleanup');
      const settingsSnap = await getDoc(settingsRef);
      
      if (!settingsSnap.exists()) return; // No settings, skip cleanup
      
      const settings = settingsSnap.data();
      const lastStreamEndTime = settings.lastStreamEndTime?.toMillis() || 0;
      const now = Date.now();
      const twoHoursMs = 2 * 60 * 60 * 1000; // 2 hours in milliseconds
      
      // If no one is currently streaming AND 2 hours have passed since last stream ended
      if (!currentStream && lastStreamEndTime > 0 && (now - lastStreamEndTime) > twoHoursMs) {
        log('Chat cleanup: 2+ hours since last stream, clearing chat history...');
        
        // Delete all DJ lobby chat messages
        const chatSnapshot = await getDocs(collection(db, 'djLobbyChat'));
        const deletePromises = [];
        chatSnapshot.forEach(document => {
          deletePromises.push(deleteDoc(doc(db, 'djLobbyChat', document.id)));
        });
        await Promise.all(deletePromises);
        
        // Reset the lastStreamEndTime so we don't keep deleting
        await setDoc(settingsRef, { 
          lastStreamEndTime: null,
          lastCleanup: serverTimestamp()
        }, { merge: true });
        
        log('Chat cleanup complete');
      }
    } catch (e) {
      // Permissions error is expected if rules don't allow reading djLobbySettings
      // This is non-critical, just skip cleanup silently
      if (e.code !== 'permission-denied') {
        console.warn('Chat cleanup skipped:', e.message);
      }
    }
  }
  
  // Call this when a stream ends to record the time
  async function recordStreamEnd() {
    try {
      const settingsRef = doc(db, 'djLobbySettings', 'chatCleanup');
      await setDoc(settingsRef, { 
        lastStreamEndTime: serverTimestamp()
      }, { merge: true });
    } catch (e) {
      console.error('Record stream end error:', e);
    }
  }
  
  // REPLACED BY PUSHER MODULE - presence events now handled via Pusher channel
  // function subscribeToOnlineDjs() { ... }
  
  function updateOnlineDjsList(djs) {
    document.getElementById('onlineDjCount').textContent = djs.length;
    
    const list = document.getElementById('djsList');
    if (djs.length === 0) {
      list.innerHTML = '<p class="empty-state">No DJs online yet</p>';
      return;
    }
    
    list.innerHTML = djs.map(dj => {
      const isLive = currentStream && currentStream.djId === dj.odamiMa;
      const isMe = dj.odamiMa === currentUser?.uid;
      const isReady = dj.isReady === true;
      const avatarLetter = dj.avatarLetter || (dj.name ? dj.name.charAt(0).toUpperCase() : 'D');
      const hasAvatar = dj.avatar && dj.avatar !== '/place-holder.webp';
      
      return `
        <div class="dj-item ${isLive ? 'is-live' : ''} ${isReady && !isLive ? 'is-ready' : ''}">
          ${hasAvatar 
            ? `<img src="${dj.avatar}" alt="" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="dj-avatar-letter" style="display:none;">${avatarLetter}</span>`
            : `<span class="dj-avatar-letter">${avatarLetter}</span>`
          }
          <span>${dj.name}${isMe ? ' (you)' : ''}</span>
        </div>
      `;
    }).join('');
  }

  // Setup HLS player for video streams
  function setupHlsPlayer(stream) {
    const videoElement = document.getElementById('hlsVideo');
    // Use hlsUrl (from status API) or fall back to videoStreamUrl/streamUrl
    // Normalize to correct base URL (fixes old trycloudflare.com URLs)
    const rawHlsUrl = stream?.hlsUrl || stream?.videoStreamUrl || stream?.streamUrl;
    const hlsUrl = normalizeHlsUrl(rawHlsUrl);

    if (!videoElement || !hlsUrl) {
      log('[HLS] No video element or stream URL. Stream:', stream);
      return;
    }

    // If same stream URL and player exists, check if actually playing
    if (currentHlsUrl === hlsUrl && hlsPlayer) {
      // Only skip if actually playing, otherwise try to play
      if (!videoElement.paused && isVideoPlaying) {
        log('[HLS] Already playing this stream, skipping re-init');
        return;
      }
      // Not playing yet, try to play
      log('[HLS] Same stream but not playing, attempting to play...');
      videoElement.play().catch(e => {
        log('[HLS] Auto-play blocked, user interaction required:', e.message);
      });
      return;
    }

    log('[HLS] Setting up player for:', hlsUrl);
    currentHlsUrl = hlsUrl;

    // Clean up existing player
    if (hlsPlayer) {
      log('[HLS] Destroying existing player');
      hlsPlayer.destroy();
      hlsPlayer = null;
    }

    const nativeHlsSupport = videoElement.canPlayType('application/vnd.apple.mpegurl');

    // Only use native HLS if "probably" - "maybe" means browser might not actually support it
    if (nativeHlsSupport === 'probably') {
      log('[HLS] Using native HLS support');
      videoElement.src = hlsUrl;
      // Auto-play for native HLS
      videoElement.play().catch(e => {
        log('[HLS] Auto-play blocked (native), user interaction required:', e.message);
      });
    } else if (window.Hls && Hls.isSupported()) {
      log('[HLS] Using HLS.js library');
      hlsPlayer = new Hls({
        enableWorker: true,
        lowLatencyMode: true,
        backBufferLength: 90,
        maxBufferLength: 30,
        maxMaxBufferLength: 60
      });

      hlsPlayer.loadSource(hlsUrl);
      hlsPlayer.attachMedia(videoElement);

      hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
        log('[HLS] Manifest parsed, auto-playing...');
        // Trigger fade-in for smooth transition
        triggerStreamFadeIn();
        // Auto-play when manifest is ready
        videoElement.play().catch(e => {
          log('[HLS] Auto-play blocked, user interaction required:', e.message);
        });
      });

      hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
        console.error('[HLS] Error:', data.type, data.details);
        if (data.fatal) {
          if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
            log('[HLS] Network error, will retry...');
            setTimeout(() => {
              if (hlsPlayer) {
                hlsPlayer.loadSource(hlsUrl);
              }
            }, 3000);
          } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
            log('[HLS] Media error, recovering...');
            hlsPlayer.recoverMediaError();
          }
        }
      });
    } else {
      console.error('[HLS] Not supported');
    }

    // Sync video events with UI
    videoElement.addEventListener('play', () => {
      isVideoPlaying = true;
      document.getElementById('playIcon')?.classList.add('hidden');
      document.getElementById('pauseIcon')?.classList.remove('hidden');
      startHealthMonitoring();
    });

    videoElement.addEventListener('pause', () => {
      isVideoPlaying = false;
      document.getElementById('playIcon')?.classList.remove('hidden');
      document.getElementById('pauseIcon')?.classList.add('hidden');
      stopHealthMonitoring();
    });
  }

  // Stream health monitoring interval
  let healthInterval = null;

  // OBS Preview - Check and play DJ's own test stream before going live
  function updateServerIndicator(isConnected) {
    const dot = document.getElementById('serverDot');
    if (dot) {
      dot.className = 'indicator-dot ' + (isConnected ? 'connected' : 'disconnected');
    }
  }

  function updateObsIndicator(isConnected) {
    const dot = document.getElementById('obsDot');
    if (dot) {
      dot.className = 'indicator-dot ' + (isConnected ? 'connected' : 'disconnected');
    }
  }

  function updateButtIndicator(isConnected) {
    const dot = document.getElementById('buttDot');
    if (dot) {
      dot.className = 'indicator-dot ' + (isConnected ? 'connected' : 'disconnected');
    }
  }

  function setPreviewSource(source) {
    currentPreviewSource = source;
    const obsIndicator = document.getElementById('obsIndicator');
    const buttIndicator = document.getElementById('buttIndicator');
    const obsVideoPreview = document.getElementById('obsVideoPreview');
    const buttAudioPreview = document.getElementById('buttAudioPreview');
    const obsOfflineState = document.getElementById('obsOfflineState');

    if (source === 'obs') {
      // OBS mode - show video or offline state
      obsIndicator?.classList.add('active');
      buttIndicator?.classList.remove('active');
      buttAudioPreview?.classList.add('hidden');
      // Show OBS content if streaming, otherwise show offline
      if (currentObsPreviewUrl && obsHlsPlayer) {
        obsVideoPreview?.classList.remove('hidden');
        obsOfflineState?.classList.add('hidden');
      } else {
        obsVideoPreview?.classList.add('hidden');
        obsOfflineState?.classList.remove('hidden');
      }
    } else if (source === 'butt') {
      // BUTT mode - show audio-only placeholder
      obsIndicator?.classList.remove('active');
      buttIndicator?.classList.add('active');
      obsVideoPreview?.classList.add('hidden');
      obsOfflineState?.classList.add('hidden');
      buttAudioPreview?.classList.remove('hidden');
      // Update BUTT placeholder with DJ name and title
      const buttDjName = document.getElementById('buttDjName');
      const buttStreamTitle = document.getElementById('buttStreamTitle');
      if (buttDjName && userInfo) {
        buttDjName.textContent = userInfo.name || 'DJ';
      }
      if (buttStreamTitle) {
        const titleInput = document.getElementById('inlineStreamTitle');
        buttStreamTitle.textContent = titleInput?.value || '';
      }
    }
    // Switch audio analyser source for meters
    switchAudioSource(source);
  }

  function initSourceToggle() {
    const obsIndicator = document.getElementById('obsIndicator');
    const buttIndicator = document.getElementById('buttIndicator');

    obsIndicator?.addEventListener('click', () => setPreviewSource('obs'));
    buttIndicator?.addEventListener('click', () => setPreviewSource('butt'));

    // Update BUTT placeholder when title changes
    const titleInput = document.getElementById('inlineStreamTitle');
    titleInput?.addEventListener('input', () => {
      if (currentPreviewSource === 'butt') {
        const buttStreamTitle = document.getElementById('buttStreamTitle');
        if (buttStreamTitle) {
          buttStreamTitle.textContent = titleInput.value || '';
        }
      }
    });
  }

  function switchAudioSource(source) {
    // Switch between OBS and BUTT audio analysers
    // OBS uses the preview stream analysers, BUTT uses the live stream analysers
    buttAudioSource = source;
    console.log('[Audio] Switching BUTT placeholder audio source to:', source);
  }

  function updateYoutubeIndicator(status) {
    const dot = document.getElementById('youtubeDot');
    if (dot) {
      // status: 'connected', 'connecting', 'disconnected', 'error'
      dot.className = 'indicator-dot ' + status;
    }
  }

  function updateTwitchIndicator(status) {
    const dot = document.getElementById('twitchDot');
    if (dot) {
      dot.className = 'indicator-dot ' + status;
    }
  }

  function showRelayIndicators(show) {
    const relayIndicators = document.getElementById('relayIndicators');
    if (relayIndicators) {
      if (show) {
        relayIndicators.classList.remove('hidden');
      } else {
        relayIndicators.classList.add('hidden');
      }
    }
  }

  // Check relay health by querying the streaming server API
  async function checkRelayHealth() {
    try {
      // Check MediaMTX API for active relay paths
      const response = await fetch('https://stream.freshwax.co.uk:9997/v3/paths/list', {
        signal: AbortSignal.timeout(5000)
      }).catch(() => null);

      if (response && response.ok) {
        const data = await response.json();
        const paths = data.items || [];

        // Check for YouTube relay (freshwax-main or youtube path)
        const youtubeRelay = paths.find(p =>
          p.name?.includes('youtube') || p.name?.includes('freshwax-main')
        );
        updateYoutubeIndicator(youtubeRelay?.ready ? 'connected' : 'disconnected');

        // Check for Twitch relay
        const twitchRelay = paths.find(p => p.name?.includes('twitch'));
        updateTwitchIndicator(twitchRelay?.ready ? 'connected' : 'disconnected');
      } else {
        // API not available, assume relays are running if stream is live
        updateYoutubeIndicator('connected');
        updateTwitchIndicator('connected');
      }
    } catch (e) {
      console.log('[RelayHealth] Check failed:', e.message);
      // On error, assume connected if stream is live
      if (currentStream) {
        updateYoutubeIndicator('connected');
        updateTwitchIndicator('connected');
      }
    }
  }

  let obsPreviewFailCount = 0;
  const OBS_PREVIEW_MAX_FAILS = 30; // Very tolerant - keep trying for ~90 seconds before giving up
  let userIsStreaming = false; // Set when user clicks "I'm Ready" - never destroy while streaming

  async function checkObsPreview() {
    // Check if DJ's own stream is available at their stream key
    if (!currentStreamKey) {
      console.log('[ObsPreview] No stream key yet, waiting...');
      updateServerIndicator(false);
      updateObsIndicator(false);
      return;
    }

    // Build the HLS URL for the DJ's own preview stream
    const baseUrl = window.HLS_BASE_URL || 'https://stream.freshwax.co.uk';
    const previewUrl = `${baseUrl}/live/${currentStreamKey}/index.m3u8`;

    try {
      // Check if server is reachable
      updateServerIndicator(true);

      // Try to fetch the HLS manifest to see if OBS stream is available
      const response = await fetch(previewUrl, {
        method: 'GET',
        signal: AbortSignal.timeout(5000)
      });

      if (response.ok) {
        console.log('[ObsPreview] Stream available at:', previewUrl);
        updateObsIndicator(true);
        obsPreviewFailCount = 0; // Reset fail counter on success

        // Only initialize if URL changed
        if (currentObsPreviewUrl !== previewUrl) {
          currentObsPreviewUrl = previewUrl;
          initObsPreviewPlayer(previewUrl);
          document.querySelector('.obs-panel')?.classList.add('streaming');
        }
      } else {
        handleObsPreviewFailure('HTTP ' + response.status);
      }
    } catch (e) {
      handleObsPreviewFailure(e.message);
    }
  }

  function handleObsPreviewFailure(reason) {
    console.log('[ObsPreview] Check failed:', reason);

    // If user is actively streaming (clicked I'm Ready), never destroy - just keep trying
    if (userIsStreaming) {
      console.log('[ObsPreview] User is streaming, will keep trying to reconnect...');
      updateObsIndicator(false);
      // Keep currentObsPreviewUrl so we can recover
      return;
    }

    // If player is already running, be tolerant of temporary failures
    if (currentObsPreviewUrl && obsHlsPlayer) {
      obsPreviewFailCount++;
      console.log('[ObsPreview] Fail count:', obsPreviewFailCount, '/', OBS_PREVIEW_MAX_FAILS);

      // Only destroy after many consecutive failures (and not actively streaming)
      if (obsPreviewFailCount >= OBS_PREVIEW_MAX_FAILS) {
        console.log('[ObsPreview] Too many failures, destroying player');
        updateObsIndicator(false);
        currentObsPreviewUrl = null;
        obsPreviewFailCount = 0;
        destroyObsPreviewPlayer();
        document.querySelector('.obs-panel')?.classList.remove('streaming');
      }
    } else {
      // No player running yet, just update indicator
      updateObsIndicator(false);
    }
  }

  function initObsPreviewPlayer(url) {
    const videoEl = document.getElementById('obsVideo');
    const offlineState = document.getElementById('obsOfflineState');
    const videoPreview = document.getElementById('obsVideoPreview');
    const broadcastAudioPanel = document.getElementById('broadcastAudioPanel');
    const buttAudioPreview = document.getElementById('buttAudioPreview');

    if (!videoEl) return;

    // Show video, hide offline state, show broadcast audio panel
    // But only if OBS is the selected source (not BUTT mode)
    offlineState?.classList.add('hidden');
    if (currentPreviewSource === 'obs') {
      videoPreview?.classList.remove('hidden');
      buttAudioPreview?.classList.add('hidden');
    }
    broadcastAudioPanel?.classList.remove('hidden');

    if (Hls.isSupported()) {
      if (obsHlsPlayer) {
        obsHlsPlayer.destroy();
      }
      obsHlsPlayer = new Hls({
        enableWorker: true,
        lowLatencyMode: true,
        backBufferLength: 30
      });
      obsHlsPlayer.loadSource(url);
      obsHlsPlayer.attachMedia(videoEl);
      obsHlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
        videoEl.play().catch(() => {});
      });
      obsHlsPlayer.on(Hls.Events.ERROR, (event, data) => {
        if (data.fatal) {
          console.log('[ObsPreview] Fatal HLS error:', data.type, data.details);
          // Try to recover from fatal errors
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              console.log('[ObsPreview] Network error, attempting recovery...');
              obsHlsPlayer.startLoad();
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              console.log('[ObsPreview] Media error, attempting recovery...');
              obsHlsPlayer.recoverMediaError();
              break;
            default:
              console.log('[ObsPreview] Unrecoverable error, destroying player');
              destroyObsPreviewPlayer();
              break;
          }
        }
      });
    } else if (videoEl.canPlayType('application/vnd.apple.mpegurl')) {
      videoEl.src = url;
      videoEl.play().catch(() => {});
    }
  }

  function destroyObsPreviewPlayer() {
    const offlineState = document.getElementById('obsOfflineState');
    const videoPreview = document.getElementById('obsVideoPreview');
    const broadcastAudioPanel = document.getElementById('broadcastAudioPanel');
    const buttAudioPreview = document.getElementById('buttAudioPreview');

    if (obsHlsPlayer) {
      obsHlsPlayer.destroy();
      obsHlsPlayer = null;
    }

    // Hide video preview
    videoPreview?.classList.add('hidden');

    // If in OBS mode, show offline state; if in BUTT mode, keep BUTT placeholder
    if (currentPreviewSource === 'obs') {
      offlineState?.classList.remove('hidden');
      buttAudioPreview?.classList.add('hidden');
    } else if (currentPreviewSource === 'butt') {
      offlineState?.classList.add('hidden');
      buttAudioPreview?.classList.remove('hidden');
    }

    // Only hide audio panel if not streaming/ready
    if (!userIsStreaming) {
      broadcastAudioPanel?.classList.add('hidden');
    }
  }

  function startObsPreviewCheck() {
    // Check immediately
    checkObsPreview();
    // Then check every 3 seconds
    if (obsPreviewCheckInterval) clearInterval(obsPreviewCheckInterval);
    obsPreviewCheckInterval = setInterval(checkObsPreview, 3000);
  }

  function stopObsPreviewCheck() {
    if (obsPreviewCheckInterval) {
      clearInterval(obsPreviewCheckInterval);
      obsPreviewCheckInterval = null;
    }
    destroyObsPreviewPlayer();
  }

  // Update mute button visual state
  function updateMuteButtonState(player, isMuted) {
    const btn = document.getElementById(`${player}MuteBtn`);
    if (!btn) return;

    const mutedIcon = btn.querySelector('.muted-icon');
    const unmutedIcon = btn.querySelector('.unmuted-icon');

    if (isMuted) {
      mutedIcon?.classList.remove('hidden');
      unmutedIcon?.classList.add('hidden');
    } else {
      mutedIcon?.classList.add('hidden');
      unmutedIcon?.classList.remove('hidden');
    }
  }

  // Update center stats panel
  function updateCenterStats(stats) {
    if (stats.viewers !== undefined) {
      const el = document.getElementById('centerViewers');
      if (el) el.textContent = stats.viewers;
    }
    if (stats.bitrate !== undefined) {
      const el = document.getElementById('centerBitrate');
      if (el) el.textContent = stats.bitrate;
    }
    if (stats.resolution !== undefined) {
      const el = document.getElementById('centerResolution');
      if (el) el.textContent = stats.resolution;
    }
    if (stats.fps !== undefined) {
      const el = document.getElementById('centerFps');
      if (el) el.textContent = stats.fps;
    }
    if (stats.latency !== undefined) {
      const el = document.getElementById('centerLatency');
      if (el) el.textContent = stats.latency;
    }
    if (stats.uptime !== undefined) {
      const el = document.getElementById('centerUptime');
      if (el) el.textContent = stats.uptime;
    }
  }

  // Update stream health stats from HLS.js
  function updateStreamHealth() {
    const healthEl = document.getElementById('streamHealth');
    const previewSection = document.querySelector('.preview-section');
    const liveIndicator = document.getElementById('healthLiveIndicator');

    if (!hlsPlayer || !isVideoPlaying) {
      healthEl?.classList.add('hidden');
      liveIndicator?.classList.add('hidden');
      return;
    }

    healthEl?.classList.remove('hidden');

    // Show live indicator if this is our stream
    const isMyStream = currentStream?.djId === currentUser?.uid;
    if (isMyStream) {
      liveIndicator?.classList.remove('hidden');
    } else {
      liveIndicator?.classList.add('hidden');
    }

    // Get HLS.js stats
    const bitrateEl = document.getElementById('healthBitrate');
    const qualityEl = document.getElementById('healthQuality');
    const droppedEl = document.getElementById('healthDropped');
    const bufferEl = document.getElementById('healthBuffer');
    const latencyEl = document.getElementById('healthLatency');
    const uptimeEl = document.getElementById('healthUptime');

    // Get current level info
    const currentLevel = hlsPlayer.levels?.[hlsPlayer.currentLevel];
    const videoEl = document.getElementById('hlsVideo');

    if (currentLevel) {
      // Bitrate in Mbps
      const bitrate = currentLevel.bitrate ? (currentLevel.bitrate / 1000000).toFixed(1) : '--';
      if (bitrateEl) {
        bitrateEl.textContent = bitrate !== '--' ? `${bitrate}Mb` : '--';
        bitrateEl.className = 'stat-value' + (currentLevel.bitrate < 1000000 ? ' warn' : currentLevel.bitrate < 500000 ? ' bad' : '');
      }

      // Resolution
      const width = currentLevel.width || videoEl?.videoWidth || 0;
      const height = currentLevel.height || videoEl?.videoHeight || 0;
      if (qualityEl) {
        if (height > 0) {
          qualityEl.textContent = `${width}x${height}`;
          qualityEl.className = 'stat-value' + (height < 480 ? ' bad' : height < 720 ? ' warn' : '');
        } else {
          qualityEl.textContent = '--';
          qualityEl.className = 'stat-value';
        }
      }
    }

    // Dropped frames from video element
    if (videoEl) {
      const quality = videoEl.getVideoPlaybackQuality?.();
      if (quality && droppedEl) {
        const dropped = quality.droppedVideoFrames || 0;
        droppedEl.textContent = dropped.toString();
        droppedEl.className = 'stat-value' + (dropped > 100 ? ' bad' : dropped > 20 ? ' warn' : '');
      }

      // Buffer amount
      if (videoEl.buffered?.length > 0 && bufferEl) {
        const buffered = videoEl.buffered.end(videoEl.buffered.length - 1) - videoEl.currentTime;
        bufferEl.textContent = `${buffered.toFixed(1)}s`;
        bufferEl.className = 'stat-value' + (buffered < 2 ? ' bad' : buffered < 5 ? ' warn' : '');
      }
    }

    // Latency estimate from HLS.js
    if (latencyEl) {
      if (hlsPlayer.latency !== undefined) {
        const latency = hlsPlayer.latency;
        latencyEl.textContent = `${latency.toFixed(1)}s`;
        latencyEl.className = 'stat-value' + (latency > 15 ? ' bad' : latency > 8 ? ' warn' : '');
      } else if (hlsPlayer.targetLatency !== undefined) {
        latencyEl.textContent = `~${hlsPlayer.targetLatency.toFixed(0)}s`;
        latencyEl.className = 'stat-value';
      } else {
        latencyEl.textContent = '--';
      }
    }

    // Uptime from stream start
    let uptimeStr = '--';
    if (streamStartTime) {
      const elapsed = Math.floor((Date.now() - streamStartTime.getTime()) / 1000);
      const hours = Math.floor(elapsed / 3600);
      const mins = Math.floor((elapsed % 3600) / 60);
      const secs = elapsed % 60;
      if (hours > 0) {
        uptimeStr = `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      } else {
        uptimeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
      }
      if (uptimeEl) {
        uptimeEl.textContent = uptimeStr;
        uptimeEl.className = 'stat-value';
      }
    } else if (uptimeEl) {
      uptimeEl.textContent = '--';
    }

    // Update center stats panel
    const centerStats = {};
    if (currentLevel) {
      const bitrate = currentLevel.bitrate ? (currentLevel.bitrate / 1000000).toFixed(1) : '--';
      centerStats.bitrate = bitrate !== '--' ? `${bitrate}Mb` : '--';
      const width = currentLevel.width || videoEl?.videoWidth || 0;
      const height = currentLevel.height || videoEl?.videoHeight || 0;
      centerStats.resolution = height > 0 ? `${height}p` : '--';
      // FPS - get from HLS level or estimate
      const fps = currentLevel.frameRate || currentLevel.attrs?.['FRAME-RATE'] || '--';
      centerStats.fps = fps !== '--' ? Math.round(fps) : '--';
    }
    if (hlsPlayer.latency !== undefined) {
      centerStats.latency = `${hlsPlayer.latency.toFixed(1)}s`;
    } else if (hlsPlayer.targetLatency !== undefined) {
      centerStats.latency = `~${hlsPlayer.targetLatency.toFixed(0)}s`;
    }
    centerStats.uptime = uptimeStr;
    updateCenterStats(centerStats);
  }

  // Start health monitoring
  function startHealthMonitoring() {
    if (healthInterval) clearInterval(healthInterval);
    healthInterval = setInterval(updateStreamHealth, 1000);
  }

  // Stop health monitoring
  function stopHealthMonitoring() {
    if (healthInterval) {
      clearInterval(healthInterval);
      healthInterval = null;
    }
    document.getElementById('streamHealth')?.classList.add('hidden');
  }

  // Save Twitch settings to localStorage
  function saveTwitchSettings() {
    const username = document.getElementById('twitchUsername')?.value?.trim() || '';
    const streamKey = document.getElementById('twitchStreamKey')?.value?.trim() || '';
    const saveBtn = document.getElementById('saveTwitchBtn');

    if (!username && !streamKey) {
      // Clear settings
      localStorage.removeItem('freshwax_twitch_username');
      localStorage.removeItem('freshwax_twitch_key');
    } else {
      if (username) localStorage.setItem('freshwax_twitch_username', username);
      if (streamKey) localStorage.setItem('freshwax_twitch_key', streamKey);
    }

    // Show success feedback
    if (saveBtn) {
      const originalText = saveBtn.textContent;
      saveBtn.textContent = 'Saved!';
      saveBtn.style.background = '#16a34a';
      setTimeout(() => {
        saveBtn.textContent = originalText;
        saveBtn.style.background = '';
      }, 1500);
    }
  }

  // Load saved Twitch settings
  function loadTwitchSettings() {
    const username = localStorage.getItem('freshwax_twitch_username');
    const streamKey = localStorage.getItem('freshwax_twitch_key');

    if (username) {
      const usernameInput = document.getElementById('twitchUsername');
      if (usernameInput) usernameInput.value = username;
    }
    if (streamKey) {
      const keyInput = document.getElementById('twitchStreamKey');
      if (keyInput) keyInput.value = streamKey;
    }
  }

  // Copy output URL to clipboard
  function copyOutputUrlToClipboard() {
    const outputUrl = document.getElementById('outputUrl')?.textContent?.trim();
    const copyBtn = document.getElementById('copyOutputUrl');

    if (!outputUrl) return;

    navigator.clipboard.writeText(outputUrl).then(() => {
      if (copyBtn) {
        const originalText = copyBtn.textContent;
        copyBtn.textContent = 'Copied!';
        setTimeout(() => {
          copyBtn.textContent = originalText;
        }, 1500);
      }
    }).catch(() => {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = outputUrl;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      if (copyBtn) {
        copyBtn.textContent = 'Copied!';
        setTimeout(() => {
          copyBtn.textContent = 'Copy';
        }, 1500);
      }
    });
  }

  // Store captured thumbnail data
  let capturedThumbnailBlob = null;
  let capturedThumbnailUrl = null;

  // Capture thumbnail from video
  function captureVideoThumbnail() {
    const video = document.getElementById('hlsVideo');
    const btn = document.getElementById('captureThumbBtn');
    const preview = document.getElementById('thumbnailPreview');
    const previewImg = document.getElementById('capturedThumb');
    const twitterBtn = document.getElementById('shareTwitterBtn');
    const facebookBtn = document.getElementById('shareFacebookBtn');

    if (!video || video.paused || !video.videoWidth) {
      alert('No video playing to capture');
      return;
    }

    try {
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Convert to blob and show preview
      canvas.toBlob(async (blob) => {
        if (!blob) return;

        // Store the blob for sharing
        capturedThumbnailBlob = blob;

        // Clean up previous URL if exists
        if (capturedThumbnailUrl) {
          URL.revokeObjectURL(capturedThumbnailUrl);
        }

        // Create new URL for preview
        capturedThumbnailUrl = URL.createObjectURL(blob);

        // Show preview
        if (previewImg && preview) {
          previewImg.src = capturedThumbnailUrl;
          preview.classList.remove('hidden');
        }

        // Enable share buttons
        if (twitterBtn) twitterBtn.disabled = false;
        if (facebookBtn) facebookBtn.disabled = false;

        // Show success feedback
        const captureText = btn.querySelector('.capture-text');
        if (captureText) {
          captureText.textContent = '‚úì Captured';
          setTimeout(() => {
            captureText.textContent = 'Capture';
          }, 1500);
        }
      }, 'image/jpeg', 0.9);
    } catch (e) {
      console.error('Thumbnail capture failed:', e);
      alert('Failed to capture thumbnail');
    }
  }

  // Clear captured thumbnail
  function clearThumbnail() {
    const preview = document.getElementById('thumbnailPreview');
    const previewImg = document.getElementById('capturedThumb');
    const twitterBtn = document.getElementById('shareTwitterBtn');
    const facebookBtn = document.getElementById('shareFacebookBtn');

    if (capturedThumbnailUrl) {
      URL.revokeObjectURL(capturedThumbnailUrl);
      capturedThumbnailUrl = null;
    }
    capturedThumbnailBlob = null;

    if (preview) preview.classList.add('hidden');
    if (previewImg) previewImg.src = '';
    if (twitterBtn) twitterBtn.disabled = true;
    if (facebookBtn) facebookBtn.disabled = true;
  }

  // Share to Twitter/X
  function shareToTwitter() {
    const postText = document.getElementById('socialPostText')?.value || '';
    const text = encodeURIComponent(postText || 'Live now on Fresh Wax! üéßüîä');
    const url = encodeURIComponent('https://freshwax.co.uk/live');
    window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank', 'width=550,height=420');
  }

  // Share to Facebook
  function shareToFacebook() {
    const url = encodeURIComponent('https://freshwax.co.uk/live');
    window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank', 'width=550,height=420');
  }

  // ========== SHARE MODAL FUNCTIONS ==========

  // Store share modal thumbnail data
  let shareThumbBlob = null;
  let shareThumbUrl = null;

  function openShareModal() {
    const modal = document.getElementById('shareStreamModal');
    if (!modal) return;

    // Populate stream info
    const djNameEl = document.getElementById('shareDjName');
    const titleEl = document.getElementById('shareStreamTitle');
    const genreEl = document.getElementById('shareStreamGenre');
    const postTextEl = document.getElementById('sharePostText');

    if (djNameEl) djNameEl.textContent = userInfo?.name || 'DJ';
    if (titleEl) titleEl.textContent = document.getElementById('inlineStreamTitle')?.value || 'Live Session';
    if (genreEl) genreEl.textContent = document.getElementById('inlineStreamGenre')?.value || 'Jungle / D&B';

    // Set default post text
    if (postTextEl && !postTextEl.value) {
      const djName = userInfo?.name || 'DJ';
      const title = document.getElementById('inlineStreamTitle')?.value || 'Live Session';
      postTextEl.value = `üéß I'm live on Fresh Wax!\n\n${title}\n\nTune in now üîä`;
      updateCharCount();
    }

    modal.classList.remove('hidden');
    document.body.style.overflow = 'hidden';
  }

  function closeShareModal() {
    const modal = document.getElementById('shareStreamModal');
    if (modal) {
      modal.classList.add('hidden');
      document.body.style.overflow = '';
    }
  }

  function captureShareThumbnail() {
    const video = document.getElementById('hlsVideo');
    const previewEl = document.getElementById('shareThumbPreview');
    const placeholder = document.getElementById('shareThumbPlaceholder');
    const imgEl = document.getElementById('shareThumbImg');
    const captureBtn = document.getElementById('shareCaptureBtn');
    const clearBtn = document.getElementById('shareClearThumbBtn');

    if (!video || video.paused || !video.videoWidth) {
      alert('No video stream available to capture');
      return;
    }

    try {
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0);

      canvas.toBlob((blob) => {
        if (!blob) {
          alert('Failed to capture thumbnail');
          return;
        }

        // Clean up previous URL
        if (shareThumbUrl) {
          URL.revokeObjectURL(shareThumbUrl);
        }

        shareThumbBlob = blob;
        shareThumbUrl = URL.createObjectURL(blob);

        // Update UI
        if (imgEl) {
          imgEl.src = shareThumbUrl;
          imgEl.classList.remove('hidden');
        }
        if (placeholder) placeholder.classList.add('hidden');
        if (previewEl) previewEl.classList.add('has-image');
        if (clearBtn) clearBtn.classList.remove('hidden');

        // Visual feedback
        if (captureBtn) {
          const originalText = captureBtn.innerHTML;
          captureBtn.innerHTML = '<span>‚úì</span> Captured!';
          setTimeout(() => {
            captureBtn.innerHTML = '<span>üì∏</span> Capture from Stream';
          }, 1500);
        }
      }, 'image/jpeg', 0.9);
    } catch (e) {
      console.error('Share thumbnail capture failed:', e);
      alert('Failed to capture thumbnail');
    }
  }

  function clearShareThumbnail() {
    const previewEl = document.getElementById('shareThumbPreview');
    const placeholder = document.getElementById('shareThumbPlaceholder');
    const imgEl = document.getElementById('shareThumbImg');
    const clearBtn = document.getElementById('shareClearThumbBtn');

    if (shareThumbUrl) {
      URL.revokeObjectURL(shareThumbUrl);
      shareThumbUrl = null;
    }
    shareThumbBlob = null;

    if (imgEl) {
      imgEl.src = '';
      imgEl.classList.add('hidden');
    }
    if (placeholder) placeholder.classList.remove('hidden');
    if (previewEl) previewEl.classList.remove('has-image');
    if (clearBtn) clearBtn.classList.add('hidden');
  }

  function updateCharCount() {
    const textEl = document.getElementById('sharePostText');
    const countEl = document.getElementById('shareCharCount');
    if (textEl && countEl) {
      countEl.textContent = textEl.value.length.toString();
    }
  }

  function shareToTwitterFromModal() {
    const postText = document.getElementById('sharePostText')?.value || '';
    const text = encodeURIComponent(postText || 'Live now on Fresh Wax! üéßüîä');
    const url = encodeURIComponent('https://freshwax.co.uk/live');
    window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank', 'width=550,height=420');
  }

  function shareToFacebookFromModal() {
    const url = encodeURIComponent('https://freshwax.co.uk/live');
    window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank', 'width=550,height=420');
  }

  function copyStreamLink() {
    const btn = document.getElementById('shareCopyLink');
    const url = 'https://freshwax.co.uk/live';

    navigator.clipboard.writeText(url).then(() => {
      if (btn) {
        btn.classList.add('copied');
        const originalHTML = btn.innerHTML;
        btn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg><span>Copied!</span>';
        setTimeout(() => {
          btn.classList.remove('copied');
          btn.innerHTML = originalHTML;
        }, 2000);
      }
    }).catch(err => {
      console.error('Failed to copy:', err);
      alert('Failed to copy link');
    });
  }

  // ========== END SHARE MODAL FUNCTIONS ==========

  // Cleanup HLS player
  function cleanupHlsPlayer() {
    stopHealthMonitoring();
    if (hlsPlayer) {
      hlsPlayer.destroy();
      hlsPlayer = null;
    }
    isVideoPlaying = false;
    currentHlsUrl = null;
    const videoElement = document.getElementById('hlsVideo');
    if (videoElement) {
      videoElement.src = '';
    }
  }

  // Audio analyser references (initialized later when audio context is created)
  let obsAnalyserL = null;
  let obsAnalyserR = null;
  let liveAnalyserL = null;
  let liveAnalyserR = null;

  // =============== BROADCAST AUDIO PANEL ===============
  let broadcastMeterAnimationId = null;
  let broadcastAudioSource = 'preview'; // 'preview' or 'live'
  let lufsHistory = [];
  let peakHoldL = -Infinity, peakHoldR = -Infinity;
  let peakHoldTimer = null;
  let stereoCanvasCtx = null;

  // Calibration settings (stored in localStorage)
  let calGainOffset = parseFloat(localStorage.getItem('calGainOffset') || '0');
  let calRefLevel = parseInt(localStorage.getItem('calRefLevel') || '-23');

  function initBroadcastMeters() {
    const canvas = document.getElementById('stereoCanvas');
    if (canvas) {
      stereoCanvasCtx = canvas.getContext('2d');
    }

    // Panel minimize button
    document.getElementById('panelMinimize')?.addEventListener('click', () => {
      const panel = document.getElementById('broadcastAudioPanel');
      const btn = document.getElementById('panelMinimize');
      if (panel?.classList.contains('minimized')) {
        panel.classList.remove('minimized');
        btn.textContent = '‚àí';
      } else {
        panel?.classList.add('minimized');
        btn.textContent = '+';
      }
    });

    // Source toggle button
    document.getElementById('audioSourceToggle')?.addEventListener('click', () => {
      broadcastAudioSource = broadcastAudioSource === 'preview' ? 'live' : 'preview';
      const label = document.querySelector('#audioSourceToggle .source-label');
      if (label) label.textContent = broadcastAudioSource.toUpperCase();
    });

    // Calibration button - toggle panel
    document.getElementById('calibrateBtn')?.addEventListener('click', () => {
      const calPanel = document.getElementById('calibrationPanel');
      calPanel?.classList.toggle('hidden');
    });

    // Calibration gain offset slider
    const gainSlider = document.getElementById('calGainOffset');
    const gainValue = document.getElementById('calGainValue');
    if (gainSlider) {
      gainSlider.value = calGainOffset;
      if (gainValue) gainValue.textContent = `${calGainOffset > 0 ? '+' : ''}${calGainOffset} dB`;
      gainSlider.addEventListener('input', (e) => {
        calGainOffset = parseFloat(e.target.value);
        if (gainValue) gainValue.textContent = `${calGainOffset > 0 ? '+' : ''}${calGainOffset} dB`;
        localStorage.setItem('calGainOffset', calGainOffset.toString());
      });
    }

    // Reference level selector
    const refSelect = document.getElementById('calRefLevel');
    if (refSelect) {
      refSelect.value = calRefLevel.toString();
      refSelect.addEventListener('change', (e) => {
        calRefLevel = parseInt(e.target.value);
        localStorage.setItem('calRefLevel', calRefLevel.toString());
        // Update LUFS target marker position
        const marker = document.querySelector('.lufs-target-marker');
        if (marker) {
          const percent = ((calRefLevel + 59) / 59) * 100;
          marker.style.left = `${Math.max(0, Math.min(100, percent))}%`;
          marker.title = `${calRefLevel} LUFS Target`;
        }
      });
    }

    // Reset calibration
    document.getElementById('calReset')?.addEventListener('click', () => {
      calGainOffset = 0;
      calRefLevel = -23;
      localStorage.removeItem('calGainOffset');
      localStorage.removeItem('calRefLevel');
      if (gainSlider) gainSlider.value = 0;
      if (gainValue) gainValue.textContent = '0 dB';
      if (refSelect) refSelect.value = '-23';
    });

    // Close calibration panel
    document.getElementById('calClose')?.addEventListener('click', () => {
      document.getElementById('calibrationPanel')?.classList.add('hidden');
    });

    // Start animation loop
    if (!broadcastMeterAnimationId) {
      animateBroadcastMeters();
    }

    // Reset peak hold every 2 seconds
    peakHoldTimer = setInterval(() => {
      peakHoldL = -Infinity;
      peakHoldR = -Infinity;
    }, 2000);
  }

  function stopBroadcastMeters() {
    if (broadcastMeterAnimationId) {
      cancelAnimationFrame(broadcastMeterAnimationId);
      broadcastMeterAnimationId = null;
    }
    if (peakHoldTimer) {
      clearInterval(peakHoldTimer);
      peakHoldTimer = null;
    }
    lufsHistory = [];
  }

  function animateBroadcastMeters() {
    // Get the active analyser based on source selection
    const analyserL = broadcastAudioSource === 'preview' ? obsAnalyserL : liveAnalyserL;
    const analyserR = broadcastAudioSource === 'preview' ? obsAnalyserR : liveAnalyserR;

    if (analyserL && analyserR) {
      // Get frequency data
      const dataL = new Uint8Array(analyserL.frequencyBinCount);
      const dataR = new Uint8Array(analyserR.frequencyBinCount);
      analyserL.getByteFrequencyData(dataL);
      analyserR.getByteFrequencyData(dataR);

      // Calculate RMS levels
      const rmsL = calculateRMS(dataL);
      const rmsR = calculateRMS(dataR);

      // Convert to dB and apply calibration offset
      const dbL = 20 * Math.log10(Math.max(rmsL, 0.0001)) + calGainOffset;
      const dbR = 20 * Math.log10(Math.max(rmsR, 0.0001)) + calGainOffset;

      // Update True Peak meters
      updateTruePeakMeter('L', dbL);
      updateTruePeakMeter('R', dbR);

      // Update PPM meters
      updatePPMMeter('L', dbL);
      updatePPMMeter('R', dbR);

      // Update VU meters
      updateVUMeter('L', rmsL);
      updateVUMeter('R', rmsR);

      // Update LUFS (simplified - using RMS as approximation)
      updateLUFS(rmsL, rmsR);

      // Update Correlation meter
      updateCorrelation(dataL, dataR);

      // Update Stereo Scope
      updateStereoScope(dataL, dataR);

      // Update BUTT spectrum if visible (uses its own audio source based on OBS/BUTT toggle)
      const buttPreview = document.getElementById('buttAudioPreview');
      if (buttPreview && !buttPreview.classList.contains('hidden')) {
        // Get the correct analysers based on buttAudioSource
        const buttAnalyserL = buttAudioSource === 'obs' ? obsAnalyserL : liveAnalyserL;
        const buttAnalyserR = buttAudioSource === 'obs' ? obsAnalyserR : liveAnalyserR;

        if (buttAnalyserL && buttAnalyserR) {
          const buttDataL = new Uint8Array(buttAnalyserL.frequencyBinCount);
          const buttDataR = new Uint8Array(buttAnalyserR.frequencyBinCount);
          buttAnalyserL.getByteFrequencyData(buttDataL);
          buttAnalyserR.getByteFrequencyData(buttDataR);
          updateButtSpectrum(buttDataL, buttDataR);
        }
      }
    }

    broadcastMeterAnimationId = requestAnimationFrame(animateBroadcastMeters);
  }

  function calculateRMS(data) {
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
      const normalized = data[i] / 255;
      sum += normalized * normalized;
    }
    return Math.sqrt(sum / data.length);
  }

  function updateTruePeakMeter(channel, db) {
    const segments = document.querySelectorAll(`#truePeak${channel} .segment`);
    const holdEl = document.getElementById(`truePeakHold${channel}`);
    const valEl = document.getElementById(`truePeakVal${channel}`);

    // Map dB to segments (16 segments, -60 to 0 dB range)
    const normalizedLevel = Math.max(0, Math.min(1, (db + 60) / 60));
    const litCount = Math.round(normalizedLevel * 16);

    // Update peak hold
    if (channel === 'L') {
      if (db > peakHoldL) peakHoldL = db;
      if (holdEl) holdEl.style.bottom = `${Math.max(0, (peakHoldL + 60) / 60 * 100)}%`;
    } else {
      if (db > peakHoldR) peakHoldR = db;
      if (holdEl) holdEl.style.bottom = `${Math.max(0, (peakHoldR + 60) / 60 * 100)}%`;
    }

    // Light up segments from bottom to top
    segments.forEach((seg, i) => {
      const segIndex = 15 - i; // Reverse index (bottom = 15, top = 0)
      if (segIndex < litCount) {
        seg.classList.add('lit');
      } else {
        seg.classList.remove('lit');
      }
    });

    // Update value display
    if (valEl) {
      valEl.textContent = db > -60 ? db.toFixed(1) : '-‚àû';
    }
  }

  function updatePPMMeter(channel, db) {
    const fillEl = document.getElementById(`ppmFill${channel}`);
    const peakEl = document.getElementById(`ppmPeak${channel}`);
    const valEl = document.getElementById(`ppmVal${channel}`);

    // Map dB to percentage (PPM scale: -60 to +3 dB)
    const normalizedLevel = Math.max(0, Math.min(1, (db + 60) / 63));
    const percentage = normalizedLevel * 100;

    if (fillEl) fillEl.style.height = `${percentage}%`;
    if (peakEl) peakEl.style.bottom = `${percentage}%`;
    if (valEl) valEl.textContent = db > -60 ? db.toFixed(1) : '-‚àû';
  }

  function updateVUMeter(channel, rms) {
    const needleEl = document.getElementById(`vuNeedle${channel}`);
    if (!needleEl) return;

    // VU meter calibration: -6 dBFS digital should read around 0 VU
    // At RMS 0.5 (-6 dBFS): 20 * log10(0.5) = -6, +6 offset = 0 VU
    const vuDb = 20 * Math.log10(Math.max(rms, 0.0001)) + 6;
    const clampedVu = Math.max(-20, Math.min(3, vuDb));

    // Map -20 to +3 VU to -45 to +45 degrees
    const angle = ((clampedVu + 20) / 23) * 90 - 45;
    needleEl.style.transform = `translateX(-50%) rotate(${angle}deg)`;
  }

  function updateLUFS(rmsL, rmsR) {
    // Improved LUFS calculation using ITU-R BS.1770 approximation
    // Apply K-weighting approximation: boost highs (+4dB at 2kHz), cut lows
    // This is a simplified K-weighting factor (real K-weighting uses specific filters)
    const kWeightingFactor = 1.2; // Approximate boost for presence frequencies

    // Calculate mean square (not RMS) for proper loudness calculation
    const msL = rmsL * rmsL * kWeightingFactor;
    const msR = rmsR * rmsR * kWeightingFactor;

    // Sum channels (mono compatibility) - no 0.707 reduction for stereo
    const summedMs = msL + msR;

    // Convert to LUFS: -0.691 + 10 * log10(sum) is the ITU formula
    // Simplified: 10 * log10(ms) gives dB, then offset to LUFS scale
    const momentaryLufs = summedMs > 0 ? 10 * Math.log10(Math.max(summedMs, 1e-10)) : -70;

    // Apply calibration offset
    const calibratedLufs = momentaryLufs + calGainOffset;

    // Store mean-square values for proper integration (not LUFS values)
    // Use power averaging, not linear averaging of dB values
    lufsHistory.push(summedMs);
    if (lufsHistory.length > 300) lufsHistory.shift(); // ~5 seconds at 60fps

    // Calculate short-term (last 3 seconds) - power average then convert
    const shortTermSamples = lufsHistory.slice(-180);
    const shortTermMs = shortTermSamples.reduce((a, b) => a + b, 0) / shortTermSamples.length;
    const shortTermLufs = shortTermMs > 0 ? 10 * Math.log10(Math.max(shortTermMs, 1e-10)) + calGainOffset : -70;

    // Calculate integrated (gated) - filter out quiet sections below -70 LUFS
    const gateThreshold = 1e-7; // Approximately -70 LUFS
    const gatedSamples = lufsHistory.filter(ms => ms > gateThreshold);
    const integratedMs = gatedSamples.length > 0
      ? gatedSamples.reduce((a, b) => a + b, 0) / gatedSamples.length
      : 0;
    const integratedLufs = integratedMs > 0 ? 10 * Math.log10(Math.max(integratedMs, 1e-10)) + calGainOffset : -70;

    // Calculate loudness range (LRA) - difference between 95th and 10th percentile
    const sortedMs = [...lufsHistory].sort((a, b) => a - b);
    const p10 = sortedMs[Math.floor(sortedMs.length * 0.1)] || 0;
    const p95 = sortedMs[Math.floor(sortedMs.length * 0.95)] || 0;
    const p10Lufs = p10 > 0 ? 10 * Math.log10(Math.max(p10, 1e-10)) : -70;
    const p95Lufs = p95 > 0 ? 10 * Math.log10(Math.max(p95, 1e-10)) : -70;
    const lufsRange = Math.max(0, p95Lufs - p10Lufs);

    // Update display
    const intEl = document.getElementById('lufsIntegrated');
    const shortEl = document.getElementById('lufsShort');
    const momEl = document.getElementById('lufsMomentary');
    const rangeEl = document.getElementById('lufsRange');
    const barEl = document.getElementById('lufsBarFill');

    if (intEl) intEl.textContent = integratedLufs > -60 ? integratedLufs.toFixed(1) : '-‚àû';
    if (shortEl) shortEl.textContent = shortTermLufs > -60 ? shortTermLufs.toFixed(1) : '-‚àû';
    if (momEl) momEl.textContent = calibratedLufs > -60 ? calibratedLufs.toFixed(1) : '-‚àû';
    if (rangeEl) rangeEl.textContent = isFinite(lufsRange) && lufsRange < 40 ? lufsRange.toFixed(1) + ' LU' : '0.0 LU';

    // Update bar (map -60 to 0 LUFS to 0-100%)
    if (barEl) {
      const barPercent = Math.max(0, Math.min(100, ((integratedLufs + 60) / 60) * 100));
      barEl.style.width = `${barPercent}%`;
    }

    // Color the main value based on calibrated reference level
    if (intEl) {
      const targetLufs = calRefLevel; // -23, -24, -16, or -14
      if (integratedLufs > targetLufs + 6) {
        intEl.style.color = '#ef4444'; // Too loud
      } else if (integratedLufs > targetLufs + 3) {
        intEl.style.color = '#eab308'; // Getting loud
      } else if (integratedLufs > targetLufs - 3) {
        intEl.style.color = '#22c55e'; // Good range
      } else {
        intEl.style.color = '#666'; // Too quiet
      }
    }
  }

  function updateCorrelation(dataL, dataR) {
    // Calculate correlation coefficient
    let sumL = 0, sumR = 0, sumLR = 0, sumL2 = 0, sumR2 = 0;
    const n = Math.min(dataL.length, dataR.length);

    for (let i = 0; i < n; i++) {
      sumL += dataL[i];
      sumR += dataR[i];
      sumLR += dataL[i] * dataR[i];
      sumL2 += dataL[i] * dataL[i];
      sumR2 += dataR[i] * dataR[i];
    }

    const meanL = sumL / n;
    const meanR = sumR / n;
    const stdL = Math.sqrt(sumL2 / n - meanL * meanL);
    const stdR = Math.sqrt(sumR2 / n - meanR * meanR);
    const covariance = sumLR / n - meanL * meanR;

    let correlation = 0;
    if (stdL > 0 && stdR > 0) {
      correlation = covariance / (stdL * stdR);
    }

    // Update correlation needle (-1 to +1 maps to 0% to 100%)
    const needleEl = document.getElementById('correlationNeedle');
    const fillEl = document.getElementById('correlationFill');

    if (needleEl) {
      const percent = ((correlation + 1) / 2) * 100;
      needleEl.style.left = `${percent}%`;
    }

    // Fill shows deviation from mono (center)
    if (fillEl) {
      const fillWidth = Math.abs(correlation) * 50;
      fillEl.style.width = `${fillWidth}%`;
      if (correlation >= 0) {
        fillEl.style.left = '50%';
        fillEl.style.background = '#22c55e';
      } else {
        fillEl.style.left = `${50 - fillWidth}%`;
        fillEl.style.background = '#ef4444';
      }
    }
  }

  function updateStereoScope(dataL, dataR) {
    if (!stereoCanvasCtx) return;

    const canvas = stereoCanvasCtx.canvas;
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;

    // Fade previous frame
    stereoCanvasCtx.fillStyle = 'rgba(5, 5, 5, 0.3)';
    stereoCanvasCtx.fillRect(0, 0, w, h);

    // Draw crosshairs
    stereoCanvasCtx.strokeStyle = '#222';
    stereoCanvasCtx.lineWidth = 1;
    stereoCanvasCtx.beginPath();
    stereoCanvasCtx.moveTo(cx, 0);
    stereoCanvasCtx.lineTo(cx, h);
    stereoCanvasCtx.moveTo(0, cy);
    stereoCanvasCtx.lineTo(w, cy);
    stereoCanvasCtx.stroke();

    // Draw Lissajous figure
    stereoCanvasCtx.strokeStyle = '#22c55e';
    stereoCanvasCtx.lineWidth = 1;
    stereoCanvasCtx.beginPath();

    const step = Math.max(1, Math.floor(dataL.length / 100));
    for (let i = 0; i < dataL.length; i += step) {
      const l = (dataL[i] / 255 - 0.5) * 2;
      const r = (dataR[i] / 255 - 0.5) * 2;

      // Rotate 45 degrees for M/S display
      const x = cx + (l - r) * (w / 3);
      const y = cy - (l + r) * (h / 3);

      if (i === 0) {
        stereoCanvasCtx.moveTo(x, y);
      } else {
        stereoCanvasCtx.lineTo(x, y);
      }
    }
    stereoCanvasCtx.stroke();

    // Draw glow dots at points
    stereoCanvasCtx.fillStyle = 'rgba(34, 197, 94, 0.5)';
    for (let i = 0; i < dataL.length; i += step * 2) {
      const l = (dataL[i] / 255 - 0.5) * 2;
      const r = (dataR[i] / 255 - 0.5) * 2;
      const x = cx + (l - r) * (w / 3);
      const y = cy - (l + r) * (h / 3);
      stereoCanvasCtx.beginPath();
      stereoCanvasCtx.arc(x, y, 2, 0, Math.PI * 2);
      stereoCanvasCtx.fill();
    }
  }

  // BUTT Waveform Visualizer
  let buttWaveformCtx = null;
  const buttWaveformSmoothed = new Array(64).fill(0);
  const buttWaveformAttack = 0.08;
  const buttWaveformDecay = 0.94;

  function updateButtSpectrum(dataL, dataR) {
    const canvas = document.getElementById('buttWaveformCanvas');
    if (!canvas) return;

    if (!buttWaveformCtx) {
      buttWaveformCtx = canvas.getContext('2d');
    }

    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;

    // Clear with fade effect
    buttWaveformCtx.fillStyle = 'rgba(5, 5, 5, 0.3)';
    buttWaveformCtx.fillRect(0, 0, w, h);

    // Combine L+R channels
    const combined = new Uint8Array(dataL.length);
    for (let i = 0; i < dataL.length; i++) {
      combined[i] = Math.max(dataL[i], dataR[i]);
    }

    const numBars = 16;
    const gap = 4;
    const barWidth = (w - (numBars - 1) * gap) / numBars;
    const binCount = combined.length;

    // Draw mirrored bars from center
    for (let i = 0; i < numBars; i++) {
      const startBin = Math.floor((i / numBars) * binCount * 0.5);
      const endBin = Math.floor(((i + 1) / numBars) * binCount * 0.5);

      let sum = 0;
      let count = 0;
      for (let j = startBin; j <= endBin && j < binCount; j++) {
        sum += combined[j];
        count++;
      }
      const avg = count > 0 ? sum / count : 0;
      const normalized = Math.pow(avg / 255, 0.85) * 0.9;
      const targetHeight = normalized * (h / 2 - 6);

      // Smooth
      const smoothIdx = i;
      buttWaveformSmoothed[smoothIdx] += (targetHeight - buttWaveformSmoothed[smoothIdx]) * buttWaveformAttack;
      if (buttWaveformSmoothed[smoothIdx] > targetHeight) {
        buttWaveformSmoothed[smoothIdx] *= buttWaveformDecay;
      }

      const barHeight = buttWaveformSmoothed[smoothIdx];
      const x = i * (barWidth + gap);

      // Create gradient for each bar
      const gradient = buttWaveformCtx.createLinearGradient(0, cy - barHeight, 0, cy + barHeight);
      gradient.addColorStop(0, '#dc2626');
      gradient.addColorStop(0.3, '#ea580c');
      gradient.addColorStop(0.5, '#eab308');
      gradient.addColorStop(0.7, '#ea580c');
      gradient.addColorStop(1, '#dc2626');

      buttWaveformCtx.fillStyle = gradient;

      // Draw bar going up with rounded ends
      buttWaveformCtx.beginPath();
      buttWaveformCtx.roundRect(x, cy - barHeight, barWidth, barHeight, 2);
      buttWaveformCtx.fill();
      // Draw bar going down (mirror)
      buttWaveformCtx.beginPath();
      buttWaveformCtx.roundRect(x, cy, barWidth, barHeight, 2);
      buttWaveformCtx.fill();
    }

    // Draw center line
    buttWaveformCtx.strokeStyle = 'rgba(220, 38, 38, 0.3)';
    buttWaveformCtx.lineWidth = 1;
    buttWaveformCtx.beginPath();
    buttWaveformCtx.moveTo(0, cy);
    buttWaveformCtx.lineTo(w, cy);
    buttWaveformCtx.stroke();

    // Add glow effect
    buttWaveformCtx.shadowColor = '#dc2626';
    buttWaveformCtx.shadowBlur = 10;
  }
  // =============== END BROADCAST AUDIO PANEL ===============

  async function loadStreamStatus() {
    try {
      // Add cache buster to prevent stale cached responses
      const cacheBuster = Date.now();
      const response = await fetch(`/api/livestream/status?_t=${cacheBuster}`);
      const result = await response.json();
      
      const statusDot = document.querySelector('.status-dot');
      const statusText = document.getElementById('statusText');
      const offlineState = document.getElementById('offlineState');
      const videoPreview = document.getElementById('videoPreview');
      const audioPreview = document.getElementById('audioPreview');
      const timeRemaining = document.getElementById('timeRemaining');
      const takeoverRequest = document.getElementById('takeoverRequest');
      const noStreamTakeover = document.getElementById('noStreamTakeover');

      if (result.success && result.isLive && result.primaryStream) {
        currentStream = result.primaryStream;

        // Set global stream ID for LiveChat component
        const streamId = currentStream.slotId || currentStream.id || currentStream.streamId;
        const previousStreamId = window.currentStreamId;
        window.currentStreamId = streamId;

        // Initialize livestream chat if not done, or switch from playlist-global to actual stream
        if (streamId && (!window.livestreamChatInitialized || previousStreamId !== streamId)) {
          // Cleanup previous channel first (e.g., playlist-global)
          if (livestreamChatChannel) {
            livestreamChatChannel.unbind_all();
            window.livestreamPusher?.unsubscribe(livestreamChatChannel.name);
            livestreamChatChannel = null;
          }
          window.livestreamChatInitialized = false;
          initLivestreamChat(streamId);
        }

        statusDot?.classList.remove('offline');
        statusDot?.classList.add('live');
        document.querySelector('.live-panel')?.classList.add('streaming');
        if (statusText) statusText.textContent = `${currentStream.djName} is LIVE`;

        // Show relay indicators and set to connecting when stream goes live
        showRelayIndicators(true);
        updateYoutubeIndicator('connecting');
        updateTwitchIndicator('connecting');
        // Check relay health after a short delay (give relays time to start)
        setTimeout(checkRelayHealth, 5000);

        offlineState?.classList.add('hidden');
        timeRemaining?.classList.remove('hidden');

        // Check if this is a new DJ (for seamless transitions)
        const isNewDj = previousStreamDjId && previousStreamDjId !== currentStream.djId;
        const isSameDj = previousStreamDjId === currentStream.djId;

        // If new DJ started, trigger immediate fade in (seamless transition)
        if (isNewDj) {
          log('[Stream] New DJ detected, triggering seamless transition');
          triggerStreamFadeIn();
        }

        // Update previous DJ tracker
        previousStreamDjId = currentStream.djId;

        // Parse stream times
        if (currentStream.startedAt) {
          streamStartTime = new Date(currentStream.startedAt);
        }

        // Determine if this DJ has a booked slot
        const hasBookedSlot = currentStream.endTime || currentStream.duration;

        let baseEndTime;
        if (currentStream.endTime) {
          baseEndTime = new Date(currentStream.endTime);
        } else if (currentStream.duration) {
          baseEndTime = new Date(streamStartTime.getTime() + currentStream.duration * 60000);
        } else {
          // Default to end of current hour if no scheduled end time
          const now = new Date();
          baseEndTime = new Date(now);
          baseEndTime.setMinutes(0, 0, 0);
          baseEndTime.setHours(baseEndTime.getHours() + 1);
        }

        // Calculate max stream end time (accounts for events, consecutive slots, subscription tier)
        // This determines how long the DJ can stream based on:
        // - Event bookings (2+ hours): Full duration, no mid-session breaks
        // - Consecutive slots: Extended to end of all consecutive slots
        // - Unbooked (Free tier): Current hour + next hour (max 2 hrs)
        // - Unbooked (Pro tier): Current hour + next 2 hours (max 3 hrs)
        streamEndTime = calculateMaxStreamEndTime(currentStream.djId, streamStartTime || new Date(), hasBookedSlot);

        // If calculateMaxStreamEndTime returned less than baseEndTime, use baseEndTime
        if (baseEndTime > streamEndTime) {
          streamEndTime = baseEndTime;
        }

        const eventMode = isInEventMode();
        log(`[Stream] End time: ${streamEndTime.toLocaleTimeString()} | Event mode: ${eventMode} | Base: ${baseEndTime.toLocaleTimeString()}`);

        const currentDjName = document.getElementById('currentDjName');
        const currentStreamTitle = document.getElementById('currentStreamTitle');
        const currentDjAvatar = document.getElementById('currentDjAvatar');
        if (currentDjName) currentDjName.textContent = currentStream.djName || 'DJ';
        if (currentStreamTitle) currentStreamTitle.textContent = currentStream.title || 'Live Stream';
        if (currentStream.djAvatar && currentDjAvatar) {
          currentDjAvatar.src = currentStream.djAvatar;
        }

        // Check if this is a video stream (HLS/Red5) or audio-only (Icecast)
        const isVideoStream = currentStream.hlsUrl || currentStream.streamSource === 'red5' ||
                             (currentStream.streamType !== 'audio' && !currentStream.audioStreamUrl?.includes('8000'));

        if (isVideoStream) {
          videoPreview?.classList.remove('hidden');
          audioPreview?.classList.add('hidden');
          // Setup HLS video player (includes auto-play)
          setupHlsPlayer(currentStream);
        } else {
          audioPreview?.classList.remove('hidden');
          videoPreview?.classList.add('hidden');
          cleanupHlsPlayer();
          const streamCover = document.getElementById('streamCover');
          if (currentStream.djAvatar && streamCover) streamCover.src = currentStream.djAvatar;
          // Setup audio stream with auto-play
          const audioEl = document.getElementById('audioElement');
          const audioUrl = currentStream.audioStreamUrl || currentStream.streamUrl;
          if (audioEl && audioUrl) {
            audioEl.src = audioUrl;
            audioEl.play().catch(e => {
              log('[Audio] Auto-play blocked, user interaction required:', e.message);
            });
          }
        }

        // Handle takeover UI and End Stream button based on who is streaming
        if (currentStream.djId === currentUser?.uid) {
          takeoverRequest?.classList.add('hidden');
          noStreamTakeover?.classList.add('hidden');
          // Enable End Stream button for current streamer
          updateEndStreamButton(true, true);
        } else {
          takeoverRequest?.classList.remove('hidden');
          noStreamTakeover?.classList.add('hidden');
          const takeoverFromName = document.getElementById('takeoverFromName');
          if (takeoverFromName) takeoverFromName.textContent = currentStream.djName || 'current DJ';
          // Disable End Stream button - not your stream (unless admin)
          updateEndStreamButton(true, false);
        }

        // Hide Go Live setup section when someone is streaming (gives more space to video)
        document.getElementById('streamKeySection')?.classList.add('hidden');
        // Hide Multi Streaming section when live
        document.getElementById('multiStreamSection')?.classList.add('hidden');
        // Show Broadcast Audio Panel when live
        document.getElementById('broadcastAudioPanel')?.classList.remove('hidden');
        initBroadcastMeters();
        // Expand video player to use the extra space
        document.querySelector('.preview-section')?.classList.add('expanded');
        // Disable Go Live button when someone is streaming
        const goLiveBtn = document.getElementById('setReadyBtn');
        if (goLiveBtn) {
          goLiveBtn.disabled = true;
          goLiveBtn.classList.add('disabled');
        }

        // Check for relay chat
        updateRelayChatSection(currentStream);

        // Update stream info panel with live data
        updateStreamInfoPanel(true, currentStream);
      } else {
        currentStream = null;
        streamStartTime = null;
        streamEndTime = null;

        // Cleanup livestream chat when stream ends
        cleanupLivestreamChat();

        statusDot?.classList.add('offline');
        statusDot?.classList.remove('live');
        document.querySelector('.live-panel')?.classList.remove('streaming');
        if (statusText) statusText.textContent = 'No one streaming';

        // Hide relay indicators when stream ends
        showRelayIndicators(false);

        offlineState?.classList.remove('hidden');
        videoPreview?.classList.add('hidden');
        audioPreview?.classList.add('hidden');
        timeRemaining?.classList.add('hidden');
        takeoverRequest?.classList.add('hidden');
        noStreamTakeover?.classList.remove('hidden');

        // Cleanup HLS player when stream ends
        cleanupHlsPlayer();

        const offlineDjName = document.getElementById('currentDjName');
        const offlineStreamTitle = document.getElementById('currentStreamTitle');
        const offlineDjAvatar = document.getElementById('currentDjAvatar');
        if (offlineDjName) offlineDjName.textContent = '-';
        if (offlineStreamTitle) offlineStreamTitle.textContent = 'No stream';
        if (offlineDjAvatar) offlineDjAvatar.src = '/place-holder.webp';

        // Disable End Stream button - no active stream
        updateEndStreamButton(false, false);

        // Only reset UI if user is NOT in "Ready" state (hasn't clicked I'm Ready)
        // When userIsStreaming is true, keep the audio panel visible and key info hidden
        if (!userIsStreaming) {
          // Show Go Live setup section when no one is streaming
          document.getElementById('streamKeySection')?.classList.remove('hidden');
          // Show Multi Streaming section when not live
          document.getElementById('multiStreamSection')?.classList.remove('hidden');
          // Hide Broadcast Audio Panel when not live
          document.getElementById('broadcastAudioPanel')?.classList.add('hidden');
          stopBroadcastMeters();
          // Shrink video player back to normal size
          document.querySelector('.preview-section')?.classList.remove('expanded');
          // Enable Go Live button when no one is streaming
          const goLiveBtn = document.getElementById('setReadyBtn');
          if (goLiveBtn) {
            goLiveBtn.disabled = false;
            goLiveBtn.classList.remove('disabled');
          }
        }

        // Hide relay chat when no stream
        updateRelayChatSection(null);

        // Reset stream info panel to offline state
        updateStreamInfoPanel(false);
      }
    } catch (e) {
      console.error('Stream status error:', e);
    }
  }

  // Fetch and display stream viewers (users on live page)
  async function loadStreamViewers() {
    try {
      // Need a current stream to show viewers
      if (!currentStream || !currentStream.id) {
        updateCenterStats({ viewers: 0 });
        return;
      }

      const response = await fetch(`/api/livestream/listeners?streamId=${currentStream.id}`);
      const result = await response.json();

      if (result.success && result.listeners && result.listeners.length > 0) {
        const newCount = result.listeners.length;
        updateCenterStats({ viewers: newCount });
      } else {
        updateCenterStats({ viewers: 0 });
      }
    } catch (e) {
      console.error('Failed to load viewers:', e);
    }
  }

  // Load viewers initially and on interval
  loadStreamViewers();
  setInterval(loadStreamViewers, 15000);

  // Stream Info Panel - Update real-time stream information
  function updateStreamInfoPanel(isLive, stream = null) {
    const statusValue = document.getElementById('streamStatusValue');
    const statusIndicator = statusValue?.querySelector('.status-indicator');
    const durationEl = document.getElementById('streamDuration');
    const bitrateEl = document.getElementById('streamBitrate');
    const resolutionEl = document.getElementById('streamResolution');
    const fpsEl = document.getElementById('streamFps');

    if (isLive && stream) {
      // Update status to live
      if (statusIndicator) {
        statusIndicator.classList.remove('offline');
        statusIndicator.classList.add('live');
      }
      if (statusValue) {
        statusValue.innerHTML = '<span class="status-indicator live"></span> Live';
      }

      // Start duration timer
      if (infoPanelDurationInterval) clearInterval(infoPanelDurationInterval);
      const startTime = stream.startedAt ? new Date(stream.startedAt) : new Date();

      function updateDuration() {
        const now = new Date();
        const diff = Math.floor((now - startTime) / 1000);
        const hours = Math.floor(diff / 3600);
        const mins = Math.floor((diff % 3600) / 60);
        const secs = diff % 60;
        if (durationEl) {
          durationEl.textContent = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
      }
      updateDuration();
      infoPanelDurationInterval = setInterval(updateDuration, 1000);

      // Get video metadata for resolution/fps/bitrate from the video element
      const videoEl = document.getElementById('liveVideoElement');
      if (videoEl) {
        const updateVideoInfo = () => {
          if (videoEl.videoWidth && videoEl.videoHeight) {
            if (resolutionEl) resolutionEl.textContent = `${videoEl.videoWidth}x${videoEl.videoHeight}`;
          }
        };
        videoEl.addEventListener('loadedmetadata', updateVideoInfo);
        videoEl.addEventListener('resize', updateVideoInfo);
        updateVideoInfo();
      }

      // Estimate bitrate from HLS (if available)
      if (hlsPlayer && hlsPlayer.bandwidthEstimate) {
        const kbps = Math.round(hlsPlayer.bandwidthEstimate / 1000);
        if (bitrateEl) bitrateEl.textContent = `${kbps} kbps`;
      } else if (bitrateEl) {
        bitrateEl.textContent = '-- kbps';
      }

      // FPS - HLS.js doesn't expose this directly, show default
      if (fpsEl) fpsEl.textContent = '30';

    } else {
      // Reset to offline state
      if (statusValue) {
        statusValue.innerHTML = '<span class="status-indicator offline"></span> Offline';
      }
      if (durationEl) durationEl.textContent = '00:00:00';
      if (bitrateEl) bitrateEl.textContent = '-- kbps';
      if (resolutionEl) resolutionEl.textContent = '--';
      if (fpsEl) fpsEl.textContent = '--';

      // Stop duration timer
      if (infoPanelDurationInterval) {
        clearInterval(infoPanelDurationInterval);
        infoPanelDurationInterval = null;
      }
    }
  }

  // Initialize info panel in offline state
  updateStreamInfoPanel(false);

  // Relay Chat Helper - shows chat from relay source (Twitch, YouTube, etc.)
  function updateRelayChatSection(stream) {
    const section = document.getElementById('relayChatSection');
    const frame = document.getElementById('relayChatFrame');
    const unsupported = document.getElementById('relayChatUnsupported');
    const sourceName = document.getElementById('relayChatSourceName');
    const externalLink = document.getElementById('relayChatExternalLink');

    // Hide if no stream or not a relay
    if (!stream || !stream.relayUrl) {
      section?.classList.add('hidden');
      if (frame) frame.src = '';
      return;
    }

    const relayUrl = stream.relayUrl;
    const chatEmbed = getRelayChatEmbed(relayUrl);

    if (chatEmbed) {
      section?.classList.remove('hidden');
      sourceName.textContent = chatEmbed.name + ' Chat';
      frame.src = chatEmbed.embedUrl;
      frame.classList.remove('hidden');
      unsupported?.classList.add('hidden');
    } else {
      // Show unsupported message with link to original
      section?.classList.remove('hidden');
      sourceName.textContent = 'Source Chat';
      frame.src = '';
      frame.classList.add('hidden');
      unsupported?.classList.remove('hidden');
      externalLink.href = relayUrl;
    }
  }

  function getRelayChatEmbed(url) {
    const host = window.location.hostname;

    // Twitch
    const twitchMatch = url.match(/twitch\.tv\/([^\/\?]+)/i);
    if (twitchMatch) {
      const channel = twitchMatch[1];
      return {
        name: 'Twitch',
        embedUrl: `https://www.twitch.tv/embed/${channel}/chat?parent=${host}&darkpopout`
      };
    }

    // YouTube Live (multiple URL formats)
    const ytVideoMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\/\?]+)/i);
    const ytLiveMatch = url.match(/youtube\.com\/live\/([^\/\?]+)/i);
    const ytChannelMatch = url.match(/youtube\.com\/(?:channel|c)\/([^\/\?]+)/i);

    if (ytVideoMatch || ytLiveMatch) {
      const videoId = ytVideoMatch ? ytVideoMatch[1] : ytLiveMatch[1];
      return {
        name: 'YouTube',
        embedUrl: `https://www.youtube.com/live_chat?v=${videoId}&embed_domain=${host}`
      };
    }

    // Kick.com
    const kickMatch = url.match(/kick\.com\/([^\/\?]+)/i);
    if (kickMatch) {
      const channel = kickMatch[1];
      return {
        name: 'Kick',
        embedUrl: `https://kick.com/${channel}/chatroom`
      };
    }

    // No supported embed found
    return null;
  }

  // Toggle relay chat visibility
  document.getElementById('toggleRelayChatBtn')?.addEventListener('click', () => {
    const container = document.getElementById('relayChatContainer');
    const btn = document.getElementById('toggleRelayChatBtn');
    if (container?.classList.toggle('collapsed')) {
      btn.textContent = '+';
    } else {
      btn.textContent = '‚àí';
    }
  });
  
  function updateTimeRemaining() {
    const timeLeft = document.getElementById('timeLeft');
    const headerTimeLeft = document.getElementById('headerTimeLeft');
    const headerTimeRemaining = document.getElementById('headerTimeRemaining');

    if (!streamEndTime) {
      if (timeLeft) timeLeft.textContent = '--:--:--';
      if (headerTimeLeft) headerTimeLeft.textContent = '--:--:--';
      if (headerTimeRemaining) headerTimeRemaining.classList.add('hidden');
      return;
    }

    const now = new Date();
    const diff = streamEndTime - now;

    if (diff <= 0) {
      // Check if same DJ has next slot (continuous streaming)
      if (currentStream && hasSameDjNextSlot(currentStream.djId, streamEndTime)) {
        // Same DJ continues - recalculate end time and skip fade
        log('[Stream] Same DJ has next slot, extending without transition');
        const newEndTime = calculateContinuousEndTime(currentStream.djId, streamEndTime);
        if (newEndTime > streamEndTime) {
          streamEndTime = newEndTime;
          // Reset fade state
          isFadingOut = false;
          const playerWrapper = document.querySelector('.preview-player');
          if (playerWrapper) {
            playerWrapper.classList.remove('fading-out', 'faded-out');
          }
          return; // Continue without fade
        }
      }

      if (timeLeft) {
        timeLeft.textContent = '00:00:00.0';
        timeLeft.style.color = '#dc2626';
      }
      if (headerTimeLeft) {
        headerTimeLeft.textContent = '00:00:00.0';
        headerTimeLeft.classList.add('urgent');
      }
      // Trigger fade out when time is up (only if DJ is actually changing)
      triggerStreamFadeOut();
      return;
    }

    const hours = Math.floor(diff / 3600000);
    const mins = Math.floor((diff % 3600000) / 60000);
    const secs = Math.floor((diff % 60000) / 1000);
    const tenths = Math.floor((diff % 1000) / 100); // 1-digit tenths of a second
    const timeStr = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${tenths}`;

    if (timeLeft) timeLeft.textContent = timeStr;
    if (headerTimeLeft) {
      headerTimeLeft.textContent = timeStr;
      if (hours === 0 && mins < 5) {
        headerTimeLeft.classList.add('urgent');
      } else {
        headerTimeLeft.classList.remove('urgent');
      }
    }
    if (headerTimeRemaining) headerTimeRemaining.classList.remove('hidden');

    // Check if same DJ continues or if in event mode - skip countdown/fade animations
    const sameDjContinues = currentStream && hasSameDjNextSlot(currentStream.djId, streamEndTime);
    const inEventMode = isInEventMode();

    // In event mode, never show mid-session transitions (only at very end of entire event)
    const skipTransitions = sameDjContinues || inEventMode;

    // Start fade out in last 10 seconds (only if DJ changing and not in event mode mid-session)
    if (diff <= 10000 && diff > 0 && !skipTransitions) {
      startGradualFadeOut(diff / 10000);
    }

    if (mins < 5) {
      if (timeLeft) timeLeft.style.color = '#dc2626';
    } else {
      if (timeLeft) timeLeft.style.color = '#fff';
    }
  }

  // Fade out video and audio gradually
  let isFadingOut = false;
  function startGradualFadeOut(progress) {
    const videoEl = document.getElementById('hlsVideo');
    const audioEl = document.getElementById('audioElement');
    const playerWrapper = document.querySelector('.preview-player');

    // Calculate opacity and volume based on remaining time (1 = full, 0 = none)
    const opacity = Math.max(0, progress);
    const volume = Math.max(0, progress);

    if (videoEl) {
      videoEl.style.opacity = opacity;
      videoEl.volume = volume;
    }
    if (audioEl) {
      audioEl.volume = volume;
    }
    if (playerWrapper && !isFadingOut) {
      playerWrapper.classList.add('fading-out');
    }
  }

  // Trigger full fade out
  function triggerStreamFadeOut() {
    if (isFadingOut) return;
    isFadingOut = true;

    const videoEl = document.getElementById('hlsVideo');
    const audioEl = document.getElementById('audioElement');
    const playerWrapper = document.querySelector('.preview-player');

    if (playerWrapper) {
      playerWrapper.classList.add('faded-out');
    }
    if (videoEl) {
      videoEl.style.opacity = '0';
      videoEl.volume = 0;
    }
    if (audioEl) {
      audioEl.volume = 0;
    }
  }

  // Fade in new stream
  function triggerStreamFadeIn() {
    isFadingOut = false;
    const videoEl = document.getElementById('hlsVideo');
    const audioEl = document.getElementById('audioElement');
    const playerWrapper = document.querySelector('.preview-player');

    if (playerWrapper) {
      playerWrapper.classList.remove('fading-out', 'faded-out');
      playerWrapper.classList.add('fading-in');
    }
    if (videoEl) {
      videoEl.style.opacity = '0';
      videoEl.style.transition = 'opacity 2s ease-in';
      setTimeout(() => {
        videoEl.style.opacity = '1';
        videoEl.volume = 1;
      }, 100);
    }
    if (audioEl) {
      audioEl.volume = 0;
      // Gradually increase volume over 2 seconds
      let vol = 0;
      const fadeInInterval = setInterval(() => {
        vol += 0.05;
        if (vol >= 1) {
          vol = 1;
          clearInterval(fadeInInterval);
        }
        audioEl.volume = vol;
      }, 100);
    }

    // Remove fade-in class after animation
    setTimeout(() => {
      playerWrapper?.classList.remove('fading-in');
    }, 2000);
  }
  
  async function loadMySlot() {
    try {
      const now = new Date();
      const end = new Date(now.getTime() + 24 * 60 * 60 * 1000);
      
      const response = await fetch(`/api/livestream/slots?start=${now.toISOString()}&end=${end.toISOString()}&djId=${currentUser.uid}`);
      const result = await response.json();
      
      if (result.success && result.slots && result.slots.length > 0) {
        // Sort by startTime to get the earliest upcoming slot
        const sortedSlots = result.slots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
        mySlot = sortedSlots[0];
        checkStreamKeyAvailability();
      } else {
        mySlot = null;
        showKeyNotAvailable();
      }
    } catch (e) {
      console.error('Load slot error:', e);
    }
  }

  // Load all scheduled slots for today (for consecutive slot detection)
  async function loadAllSlots() {
    try {
      const now = new Date();
      const end = new Date(now.getTime() + 24 * 60 * 60 * 1000);
      const response = await fetch(`/api/livestream/slots?start=${now.toISOString()}&end=${end.toISOString()}`);
      const result = await response.json();
      if (result.success && result.slots) {
        allDjSlots = result.slots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
      }
    } catch (e) {
      console.error('Load all slots error:', e);
    }
  }

  // Calculate the continuous end time for a DJ (accounting for consecutive slots)
  function calculateContinuousEndTime(djId, currentEndTime) {
    if (!allDjSlots || allDjSlots.length === 0) return currentEndTime;

    let endTime = new Date(currentEndTime);
    const djSlots = allDjSlots.filter(s => s.djId === djId);

    // Sort slots by start time
    djSlots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));

    // Find consecutive slots from current end time
    let extended = true;
    while (extended) {
      extended = false;
      for (const slot of djSlots) {
        const slotStart = new Date(slot.startTime);
        const slotEnd = new Date(slot.endTime);

        // Check if this slot starts at or very close to current end time (within 5 min tolerance)
        const gap = Math.abs(slotStart.getTime() - endTime.getTime());
        if (gap <= 5 * 60 * 1000 && slotEnd > endTime) {
          endTime = slotEnd;
          extended = true;
          log(`[Slots] Extended end time to ${slotEnd.toLocaleTimeString()} for consecutive slot`);
        }
      }
    }

    return endTime;
  }

  // Check if same DJ has the next slot (for continuous streaming without fade)
  function hasSameDjNextSlot(djId, currentEndTime) {
    if (!allDjSlots || allDjSlots.length === 0) return false;

    const endTime = new Date(currentEndTime);

    // Find slot that starts at or right after current end time
    for (const slot of allDjSlots) {
      const slotStart = new Date(slot.startTime);
      const gap = Math.abs(slotStart.getTime() - endTime.getTime());

      // If there's a slot starting within 5 minutes of end time
      if (gap <= 5 * 60 * 1000 && slot.djId === djId) {
        return true;
      }
    }
    return false;
  }

  // Check if this is an event session (long booking or multi-hour event)
  // Events run continuously without any breaks/transitions
  function isEventSession(djId, streamStart) {
    if (!allDjSlots || allDjSlots.length === 0) return null;

    const djSlots = allDjSlots.filter(s => s.djId === djId && ['scheduled', 'live', 'in_lobby'].includes(s.status));
    if (djSlots.length === 0) return null;

    // Sort by start time
    djSlots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));

    // Find the slot that covers or is closest to the stream start
    const start = new Date(streamStart);
    let eventSlot = null;

    for (const slot of djSlots) {
      const slotStart = new Date(slot.startTime);
      const slotEnd = new Date(slot.endTime);

      // Check if stream started during or just before this slot
      if (start >= new Date(slotStart.getTime() - 15 * 60000) && start < slotEnd) {
        eventSlot = slot;
        break;
      }
    }

    if (!eventSlot) return null;

    // Check if this is a long booking (2+ hours = event)
    const duration = eventSlot.duration ||
      (new Date(eventSlot.endTime) - new Date(eventSlot.startTime)) / 60000;

    if (duration >= 120) {
      // This is an event - single long booking
      return {
        isEvent: true,
        startTime: new Date(eventSlot.startTime),
        endTime: new Date(eventSlot.endTime),
        totalDuration: duration,
        slots: [eventSlot]
      };
    }

    // Check for consecutive slots (multiple hours booked back-to-back = event)
    let eventEnd = new Date(eventSlot.endTime);
    let eventSlots = [eventSlot];
    let totalDuration = duration;

    for (const slot of djSlots) {
      if (slot.id === eventSlot.id) continue;
      const slotStart = new Date(slot.startTime);
      const slotEnd = new Date(slot.endTime);
      const slotDuration = slot.duration || (slotEnd - slotStart) / 60000;

      // Check if this slot is consecutive (within 5 min)
      const gap = Math.abs(slotStart.getTime() - eventEnd.getTime());
      if (gap <= 5 * 60000 && slotEnd > eventEnd) {
        eventSlots.push(slot);
        eventEnd = slotEnd;
        totalDuration += slotDuration;
      }
    }

    // If total consecutive time is 2+ hours, treat as event
    if (totalDuration >= 120 || eventSlots.length >= 2) {
      return {
        isEvent: true,
        startTime: new Date(eventSlot.startTime),
        endTime: eventEnd,
        totalDuration,
        slots: eventSlots
      };
    }

    return null;
  }

  // Calculate max allowed streaming time for a DJ (based on subscription + whether they have next slot)
  function calculateMaxStreamEndTime(djId, streamStart, hasBookedSlot) {
    const start = new Date(streamStart);
    const now = new Date();

    // Check if this is an event session
    const eventSession = isEventSession(djId, streamStart);
    if (eventSession && eventSession.isEvent) {
      currentEventSession = eventSession;
      log(`[Stream] Event session detected: ${eventSession.totalDuration} minutes total`);
      return eventSession.endTime;
    }

    currentEventSession = null;

    // For non-event streams, calculate based on rules:
    // Free DJ (no booking): current hour + next hour (max 2 hours)
    // Pro/Paid DJ: current hour + next 2 hours (max 3 hours)

    // End of current hour
    const endOfCurrentHour = new Date(start);
    endOfCurrentHour.setMinutes(0, 0, 0);
    endOfCurrentHour.setHours(endOfCurrentHour.getHours() + 1);

    // If they have booked slots, use those
    if (hasBookedSlot) {
      const continuousEnd = calculateContinuousEndTime(djId, endOfCurrentHour);
      return continuousEnd;
    }

    // For unbooked streams:
    const isPro = userSubscription?.isPro || false;
    const extraHours = isPro ? 2 : 1; // Pro gets +2 hours, Free gets +1 hour

    // Check if they have the next slot(s) booked
    const hasNextHour = hasSameDjNextSlot(djId, endOfCurrentHour);

    if (hasNextHour) {
      // They have next hour booked, extend to end of that
      const continuousEnd = calculateContinuousEndTime(djId, endOfCurrentHour);
      return continuousEnd;
    }

    // No booking - allow current hour + extra based on tier
    const maxEnd = new Date(endOfCurrentHour);
    maxEnd.setHours(maxEnd.getHours() + extraHours);

    log(`[Stream] Max end time: ${maxEnd.toLocaleTimeString()} (${isPro ? 'Pro' : 'Free'} tier)`);
    return maxEnd;
  }

  // Check if stream should have transitions disabled (event mode)
  function isInEventMode() {
    return currentEventSession && currentEventSession.isEvent;
  }

  // Format duration in days, hours, minutes
  function formatDuration(totalMinutes) {
    if (totalMinutes <= 0) return '0 minutes';
    
    const days = Math.floor(totalMinutes / 1440);
    const hours = Math.floor((totalMinutes % 1440) / 60);
    const mins = totalMinutes % 60;
    
    const parts = [];
    if (days > 0) parts.push(`${days} day${days !== 1 ? 's' : ''}`);
    if (hours > 0) parts.push(`${hours} hour${hours !== 1 ? 's' : ''}`);
    if (mins > 0 || parts.length === 0) parts.push(`${mins} minute${mins !== 1 ? 's' : ''}`);
    
    return parts.join(', ');
  }
  
  function showKeyNotAvailable() {
    // Called when user has no booked slot - but we still generate a key for them
    const slotTimeDisplay = document.getElementById('slotTimeDisplay');
    const countdownEl = document.getElementById('countdownToSlot');

    if (slotTimeDisplay) slotTimeDisplay.textContent = 'No slot booked';
    if (countdownEl) countdownEl.textContent = 'You can still go live anytime';

    // Always generate a stream key for DJs, even without a booked slot
    if (!currentStreamKey) {
      loadStreamKeyForGoLive();
    } else {
      // Display existing key
      const streamKeyEl = document.getElementById('myStreamKey');
      if (streamKeyEl) {
        streamKeyEl.classList.remove('key-loading');
        streamKeyEl.classList.add('key-reveal');
        streamKeyEl.innerHTML = `<span class="key-text">${currentStreamKey}</span>`;
      }
      startObsPreviewCheck();
    }
  }

  function checkStreamKeyAvailability() {
    const keyStatus = document.getElementById('keyStatus');
    const slotTimeDisplay = document.getElementById('slotTimeDisplay');
    const countdownEl = document.getElementById('countdownToSlot');
    const streamKeyEl = document.getElementById('myStreamKey');

    // If user has a booked slot, show slot info
    if (mySlot) {
      const now = new Date();
      const slotStart = new Date(mySlot.startTime);
      const slotEnd = new Date(mySlot.endTime);

      if (slotTimeDisplay) {
        slotTimeDisplay.textContent =
          `Your slot: ${slotStart.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })} - ${slotEnd.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })}`;
      }

      const minsUntil = Math.ceil((slotStart - now) / 60000);
      if (countdownEl) {
        if (minsUntil > 0) {
          countdownEl.textContent = `Starts in ${formatDuration(minsUntil)}`;
          countdownEl.classList.remove('slot-now');
        } else if (now < slotEnd) {
          countdownEl.textContent = `Your slot is NOW!`;
          countdownEl.classList.add('slot-now');
        } else {
          countdownEl.textContent = '';
          countdownEl.classList.remove('slot-now');
        }
      }

      // If slot has a stream key, use it
      if (mySlot.streamKey) {
        currentStreamKey = mySlot.streamKey;
        // Only animate if not already displayed
        if (!streamKeyDisplayed && streamKeyEl) {
          streamKeyEl.classList.remove('key-loading');
          streamKeyEl.classList.add('key-reveal');
          streamKeyEl.innerHTML = `<span class="key-text">${mySlot.streamKey}</span>`;
          streamKeyDisplayed = true;
        }
        // Start checking for OBS preview stream
        startObsPreviewCheck();
      }
    } else {
      if (slotTimeDisplay) slotTimeDisplay.textContent = 'Your slot: --:-- - --:--';
      if (countdownEl) countdownEl.textContent = '';
    }

    // Always generate a stream key if we don't have one
    if (!currentStreamKey) {
      loadStreamKeyForGoLive();
    } else if (!streamKeyDisplayed) {
      // Display existing key only if not already shown
      if (streamKeyEl) {
        streamKeyEl.classList.remove('key-loading');
        streamKeyEl.classList.add('key-reveal');
        streamKeyEl.innerHTML = `<span class="key-text">${currentStreamKey}</span>`;
        streamKeyDisplayed = true;
      }
      // Start checking for OBS preview stream
      startObsPreviewCheck();
    }
  }
  
  async function fetchStreamKey() {
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify({ action: 'getStreamKey', slotId: mySlot.id, djId: currentUser.uid })
      });
      
      const result = await response.json();
      if (result.success && result.streamKey) {
        const keyEl = document.getElementById('myStreamKey');
        if (keyEl) {
          keyEl.classList.remove('key-loading');
          keyEl.classList.add('key-reveal');
          keyEl.innerHTML = `<span class="key-text">${result.streamKey}</span>`;
        }
        mySlot.streamKey = result.streamKey;
        currentStreamKey = result.streamKey;
      }
    } catch (e) {
      console.error('Fetch key error:', e);
    }
  }
  
  // REPLACED BY PUSHER MODULE - takeover events now handled via private Pusher channel
  // function subscribeToTakeover() { ... }
  
  function showIncomingTakeover(data) {
    const div = document.getElementById('incomingTakeover');
    document.getElementById('incomingDjName').textContent = data.requesterName || 'A DJ';
    document.getElementById('incomingDjAvatar').src = data.requesterAvatar || '/place-holder.webp';
    div.classList.remove('hidden');
    div.dataset.requesterId = data.requesterId;
  }
  
  function hideIncomingTakeover() {
    document.getElementById('incomingTakeover').classList.add('hidden');
  }
  
  function showTakeoverApproved(data) {
    const div = document.getElementById('takeoverApproved');
    document.getElementById('takeoverServerUrl').textContent = data.serverUrl || 'rtmp://rtmp.freshwax.co.uk/live';
    document.getElementById('takeoverStreamKey').textContent = data.streamKey || '-';
    div.classList.remove('hidden');
    document.getElementById('takeoverRequest').classList.add('hidden');
    document.getElementById('noStreamTakeover').classList.add('hidden');
  }
  
  // REPLACED BY PUSHER MODULE - chat messages now handled via Pusher channel
  // function subscribeToChat() { ... }
  
  function renderMessages(messages) {
    // DISABLED: Now using LiveChat component
    return;
    const container = document.getElementById('chatMessages');

    if (messages.length === 0) {
      return;
    }
    
    container.innerHTML = messages.map(msg => {
      const time = msg.createdAt?.toDate ? 
        msg.createdAt.toDate().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : '';
      
      return `
        <div class="chat-message">
          <div class="chat-message-content">
            <div class="chat-message-header">
              <span class="chat-message-name">${escapeHtml(msg.name || 'DJ')}</span>
              <span class="chat-message-time">${time}</span>
            </div>
            <div class="chat-message-text">${escapeHtml(msg.text)}</div>
          </div>
        </div>
      `;
    }).join('');
    
    container.scrollTop = container.scrollHeight;
  }
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // ============================================
  // DM SYSTEM
  // ============================================
  
  function getDmChannelId(uid1, uid2) {
    // Create consistent channel ID regardless of who initiates
    return [uid1, uid2].sort().join('_');
  }
  
  function openDmModal() {
    document.getElementById('dmModal').classList.remove('hidden');
    document.getElementById('dmSelectView').classList.remove('hidden');
    document.getElementById('dmChatView').classList.add('hidden');
    populateDmDjList();
  }
  
  function closeDmModal() {
    document.getElementById('dmModal').classList.add('hidden');
    
    // Clean up DM messages from Firestore
    if (dmTargetDj && currentUser) {
      cleanupDmMessages();
    }
    
    // Unsubscribe from DM listener
    if (dmUnsubscribe) {
      dmUnsubscribe();
      dmUnsubscribe = null;
    }
    
    // Reset state
    dmTargetDj = null;
    dmMessages = [];
    document.getElementById('dmMessages').innerHTML = `
      <div class="dm-welcome">
        <p>Start a private conversation</p>
        <p class="hint">Only you and this DJ can see these messages.</p>
      </div>
    `;
  }
  
  function populateDmDjList() {
    const list = document.getElementById('dmDjList');
    const otherDjs = onlineDjsCache.filter(dj => dj.odamiMa !== currentUser?.uid);
    
    if (otherDjs.length === 0) {
      list.innerHTML = '<p class="empty-state">No other DJs online</p>';
      return;
    }
    
    list.innerHTML = otherDjs.map(dj => {
      const avatarLetter = dj.avatarLetter || (dj.name ? dj.name.charAt(0).toUpperCase() : 'D');
      const hasAvatar = dj.avatar && dj.avatar !== '/place-holder.webp';
      const isLive = currentStream && currentStream.djId === dj.odamiMa;
      
      return `
        <div class="dm-dj-item" data-dj-id="${dj.odamiMa}" data-dj-name="${escapeHtml(dj.name || 'DJ')}" data-dj-avatar="${dj.avatar || ''}" data-dj-letter="${avatarLetter}">
          ${hasAvatar 
            ? `<img src="${dj.avatar}" alt="" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="dm-dj-avatar-letter" style="display:none;">${avatarLetter}</span>`
            : `<span class="dm-dj-avatar-letter">${avatarLetter}</span>`
          }
          <div class="dm-dj-info">
            <div class="dm-dj-name">${escapeHtml(dj.name || 'DJ')}</div>
            <div class="dm-dj-status">${isLive ? 'üî¥ Live now' : 'Online'}</div>
          </div>
        </div>
      `;
    }).join('');
    
    // Add click handlers
    list.querySelectorAll('.dm-dj-item').forEach(item => {
      item.addEventListener('click', () => {
        const djId = item.dataset.djId;
        const djName = item.dataset.djName;
        const djAvatar = item.dataset.djAvatar;
        const djLetter = item.dataset.djLetter;
        selectDmTarget(djId, djName, djAvatar, djLetter);
      });
    });
  }
  
  function selectDmTarget(djId, djName, djAvatar, djLetter) {
    // Use Pusher module to handle DM conversation
    openDmConversation({ id: djId, name: djName, avatar: djAvatar, letter: djLetter });
    
    // Update local reference for UI
    dmTargetDj = { id: djId, name: djName, avatar: djAvatar, letter: djLetter };
    
    // Switch to chat view
    document.getElementById('dmSelectView').classList.add('hidden');
    document.getElementById('dmChatView').classList.remove('hidden');
    document.getElementById('dmChatWithName').textContent = djName;
  }
  
  function goBackToDmList() {
    // Use Pusher module to close DM
    closeDmModal();
    
    dmTargetDj = null;
    
    // Switch to selection view
    document.getElementById('dmChatView').classList.add('hidden');
    document.getElementById('dmSelectView').classList.remove('hidden');
    populateDmDjList();
  }
  
  // REPLACED BY PUSHER MODULE - DM messages now handled via Pusher channel
  // function subscribeToDmChannel() { ... }
  
  // REPLACED BY PUSHER MODULE - DM rendering now handled by dj-lobby-pusher.js
  // function renderDmMessages() { ... }
  
  function renderDmMessages() {
    const container = document.getElementById('dmMessages');
    
    if (dmMessages.length === 0) {
      container.innerHTML = `
        <div class="dm-welcome">
          <p>Start a private conversation</p>
          <p class="hint">Only you and this DJ can see these messages.</p>
        </div>
      `;
      return;
    }
    
    container.innerHTML = dmMessages.map(msg => {
      const isSent = msg.senderId === currentUser?.uid;
      const time = msg.createdAt?.toDate ? 
        msg.createdAt.toDate().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : '';
      
      return `
        <div class="dm-message ${isSent ? 'sent' : ''}">
          <div class="dm-message-content">
            <div class="dm-message-name">${isSent ? 'You' : escapeHtml(msg.senderName || 'DJ')}</div>
            <div class="dm-message-text">${escapeHtml(msg.text)}</div>
            <div class="dm-message-time">${time}</div>
          </div>
        </div>
      `;
    }).join('');
    
    container.scrollTop = container.scrollHeight;
  }
  
  async function sendDmMessage() {
    const input = document.getElementById('dmInput');
    const text = input.value.trim();
    if (!text) return;
    
    input.value = '';
    
    try {
      // Use Pusher module to send DM (handles API + Pusher broadcast)
      await sendDm(text);
    } catch (e) {
      console.error('DM send error:', e);
      input.value = text;
    }
  }
  
  async function cleanupDmMessages() {
    if (!dmTargetDj || !currentUser) return;
    
    try {
      const channelId = getDmChannelId(currentUser.uid, dmTargetDj.id);
      
      // Delete all messages in the channel
      const messagesRef = collection(db, 'djDirectMessages', channelId, 'messages');
      const snapshot = await getDocs(messagesRef);
      
      const deletePromises = [];
      snapshot.forEach(document => {
        deletePromises.push(deleteDoc(doc(db, 'djDirectMessages', channelId, 'messages', document.id)));
      });
      
      await Promise.all(deletePromises);
      
      // Delete channel doc
      await deleteDoc(doc(db, 'djDirectMessages', channelId));
      
    } catch (e) {
      console.error('DM cleanup error:', e);
    }
  }
  
  // REPLACED BY PUSHER MODULE - DM notifications now handled via private Pusher channel
  // function subscribeToIncomingDms() { ... }
  
  function showDmNotification(senderId, senderName, message) {
    const notif = document.getElementById('dmNotification');
    const text = document.getElementById('dmNotifText');
    
    text.textContent = `New DM from ${senderName}`;
    notif.dataset.senderId = senderId;
    notif.dataset.senderName = senderName;
    notif.classList.remove('hidden');
    
    // Auto-hide after 10 seconds
    setTimeout(() => {
      notif.classList.add('hidden');
    }, 10000);
  }
  
  function openDmFromNotification() {
    const notif = document.getElementById('dmNotification');
    const senderId = notif.dataset.senderId;
    const senderName = notif.dataset.senderName;
    
    notif.classList.add('hidden');
    
    // Find the sender in online DJs cache
    const senderDj = onlineDjsCache.find(dj => dj.odamiMa === senderId);
    if (senderDj) {
      openDmModal();
      const avatarLetter = senderDj.avatarLetter || (senderDj.name ? senderDj.name.charAt(0).toUpperCase() : 'D');
      selectDmTarget(senderId, senderDj.name || senderName, senderDj.avatar || '', avatarLetter);
    } else {
      // DJ went offline, just open modal
      openDmModal();
    }
  }

  // ==========================================
  // GO LIVE MODAL
  // ==========================================

  // currentStreamKey is now initialized earlier (line ~820) with test mode support
  let streamKeyValidUntil = null;
  let streamKeyDisplayed = false; // Flag to prevent re-animation of stream key
  let currentStreamSource = 'obs'; // 'obs' or 'relay'
  let approvedRelayData = null;

  async function openGoLiveInline() {
    // Check if someone else is already streaming
    if (currentStream && currentStream.djId !== currentUser.uid) {
      alert('Someone is already live! Use the Takeover feature if you want to take over.');
      return;
    }

    // Generate/fetch stream key if needed
    if (!currentStreamKey) {
      document.getElementById('keyStatus').textContent = 'Loading...';
      await loadStreamKeyForGoLive();
    }

    // Scroll to the Go Live section
    const keySection = document.getElementById('streamKeySection');
    keySection?.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Update status
    document.getElementById('keyStatus').textContent = 'Ready';
    document.getElementById('keyStatus').className = 'key-status ready';
  }

  async function loadStreamKeyForGoLive() {
    const inlineKeyEl = document.getElementById('myStreamKey');

    // If key is already displayed, don't re-animate but ensure preview check is running
    if (streamKeyDisplayed && currentStreamKey) {
      log('[GoLive] Stream key already displayed, skipping animation');
      startObsPreviewCheck();
      return;
    }

    // Check if we already have a valid stream key in memory
    if (currentStreamKey && streamKeyValidUntil) {
      const validUntil = new Date(streamKeyValidUntil);
      const now = new Date();
      // If key is still valid (with 2 min buffer), reuse it
      if (validUntil.getTime() - now.getTime() > 2 * 60 * 1000) {
        log('[GoLive] Reusing existing stream key, valid until:', streamKeyValidUntil);
        if (inlineKeyEl && !streamKeyDisplayed) {
          // Show spawning animation first
          inlineKeyEl.classList.add('key-loading');
          inlineKeyEl.classList.remove('key-reveal');
          inlineKeyEl.innerHTML = '<span class="key-generating"><span class="spawn-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span> Spawning</span>';
          // Wait 5 seconds for animation before revealing
          await new Promise(resolve => setTimeout(resolve, 5000));
          inlineKeyEl.classList.remove('key-loading');
          inlineKeyEl.classList.add('key-reveal');
          inlineKeyEl.innerHTML = `<span class="key-text">${currentStreamKey}</span>`;
          streamKeyDisplayed = true;
        }
        startObsPreviewCheck();
        return;
      }
    }

    // Check localStorage for a saved key (survives page refresh)
    const savedKey = localStorage.getItem('freshwax_stream_key');
    const savedValidUntil = localStorage.getItem('freshwax_stream_key_valid_until');
    if (savedKey && savedValidUntil) {
      const validUntil = new Date(savedValidUntil);
      const now = new Date();
      // If saved key is still valid (with 2 min buffer), use it
      if (validUntil.getTime() - now.getTime() > 2 * 60 * 1000) {
        log('[GoLive] Using saved stream key from localStorage, valid until:', savedValidUntil);
        currentStreamKey = savedKey;
        streamKeyValidUntil = savedValidUntil;
        if (inlineKeyEl && !streamKeyDisplayed) {
          // Show spawning animation first
          inlineKeyEl.classList.add('key-loading');
          inlineKeyEl.classList.remove('key-reveal');
          inlineKeyEl.innerHTML = '<span class="key-generating"><span class="spawn-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span> Spawning</span>';
          // Wait 5 seconds for animation before revealing
          await new Promise(resolve => setTimeout(resolve, 5000));
          inlineKeyEl.classList.remove('key-loading');
          inlineKeyEl.classList.add('key-reveal');
          inlineKeyEl.innerHTML = `<span class="key-text">${savedKey}</span>`;
          streamKeyDisplayed = true;
        }
        startObsPreviewCheck();
        return;
      } else {
        // Clear expired key
        localStorage.removeItem('freshwax_stream_key');
        localStorage.removeItem('freshwax_stream_key_valid_until');
      }
    }

    if (inlineKeyEl) {
      inlineKeyEl.classList.add('key-loading');
      inlineKeyEl.classList.remove('key-reveal');
      inlineKeyEl.innerHTML = '<span class="key-generating"><span class="spawn-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span> Spawning</span>';
    }

    // Minimum animation duration (5 seconds) for visual effect
    const minAnimationTime = 5000;
    const animationStart = Date.now();

    try {
      const token = await currentUser.getIdToken();

      // Request a new stream key for go-live
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          action: 'generate_key',
          djId: currentUser.uid,
          djName: userInfo.name
        })
      });

      const result = await response.json();

      // Wait for minimum animation time before revealing
      const elapsed = Date.now() - animationStart;
      if (elapsed < minAnimationTime) {
        await new Promise(resolve => setTimeout(resolve, minAnimationTime - elapsed));
      }

      if (result.success && result.streamKey) {
        currentStreamKey = result.streamKey;
        streamKeyValidUntil = result.validUntil;

        // Save to localStorage so it survives page refresh
        localStorage.setItem('freshwax_stream_key', result.streamKey);
        localStorage.setItem('freshwax_stream_key_valid_until', result.validUntil);

        if (inlineKeyEl) {
          inlineKeyEl.classList.remove('key-loading');
          inlineKeyEl.classList.add('key-reveal');
          inlineKeyEl.innerHTML = `<span class="key-text">${result.streamKey}</span>`;
          streamKeyDisplayed = true; // Mark as displayed to prevent re-animation
        }
        log('[GoLive] New stream key generated and saved, valid until:', result.validUntil);
        // Start checking for OBS preview stream
        startObsPreviewCheck();
      } else {
        if (inlineKeyEl) {
          inlineKeyEl.classList.remove('key-loading');
          inlineKeyEl.classList.remove('key-reveal');
          inlineKeyEl.textContent = 'Error - try again';
        }
        console.error('[GoLive] Failed to generate key:', result.error);
      }
    } catch (error) {
      console.error('[GoLive] Error loading stream key:', error);
      if (inlineKeyEl) {
        inlineKeyEl.classList.remove('key-loading');
        inlineKeyEl.classList.remove('key-reveal');
        inlineKeyEl.textContent = 'Error - try again';
      }
    }
  }

  async function handleGoLiveReady() {
    // Get title and genre from inline fields
    let title, genre;

    title = document.getElementById('inlineStreamTitle')?.value?.trim() || 'Live Session';
    genre = document.getElementById('inlineStreamGenre')?.value || 'Jungle / D&B';

    // Check for user-entered relay URL
    const userRelayUrl = document.getElementById('relayUrl')?.value?.trim() || null;
    const relaySourceName = selectedRelaySource?.name || 'External Source';

    // Determine stream mode based on relay URL
    const isRelayMode = userRelayUrl || (currentStreamSource === 'relay' && approvedRelayData?.relayUrl);

    // For OBS mode, check stream key
    if (!isRelayMode && !currentStreamKey) {
      throw new Error('No stream key available. Please refresh and try again.');
    }

    // For relay mode, check relay URL
    if (isRelayMode && !userRelayUrl && !approvedRelayData?.relayUrl) {
      throw new Error('No relay URL provided.');
    }

    log('[GoLive] Starting go live with key:', currentStreamKey?.substring(0, 10) + '...');

    const token = await currentUser.getIdToken();

    // Get Twitch username and stream key if provided
    const twitchUsername = document.getElementById('twitchUsername')?.value?.trim() || null;
    const twitchStreamKey = document.getElementById('twitchStreamKey')?.value?.trim() || null;

    // Build request body based on source type
    const requestBody = {
      action: isRelayMode ? 'start_relay' : 'go_live',
      djId: currentUser.uid,
      djName: userInfo.name,
      title: title,
      genre: genre,
      twitchUsername: twitchUsername,
      twitchStreamKey: twitchStreamKey
    };

    if (isRelayMode) {
      requestBody.relayUrl = userRelayUrl || approvedRelayData.relayUrl;
      requestBody.stationName = userRelayUrl ? relaySourceName : approvedRelayData.stationName;
    } else {
      requestBody.streamKey = currentStreamKey;
    }

    // Send request
    const response = await fetch('/api/livestream/slots', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(requestBody)
    });

    const result = await response.json();

    if (result.success) {
      // Stream is live!
      log('[GoLive] Successfully went live!', result);

      // Refresh stream status
      await loadStreamStatus();

      // Update UI to show we're live
      updateEndStreamButton(true, true);

      // Hide ready section since we're now live
      document.getElementById('readySection')?.classList.add('hidden');

      return true;
    } else {
      // Log full error for debugging
      console.error('[GoLive] API Error:', result);

      // Throw error so caller knows it failed
      let errorMsg = result.error || 'Failed to go live';
      if (result.details) errorMsg += ': ' + result.details;
      if (result.error === 'stream_not_detected') {
        errorMsg = 'Stream not detected. Make sure OBS is streaming with the correct key.';
      } else if (result.error === 'relay_failed') {
        errorMsg = 'Failed to connect to relay stream.';
      }

      throw new Error(errorMsg);
    }
  }

  async function sendMessage() {
    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    if (!text) return;

    input.value = '';

    try {
      // Use Pusher module's sendChatMessage (handles API + Pusher broadcast)
      await sendChatMessage(text);
    } catch (e) {
      console.error('Send error:', e);
      input.value = text;
    }
  }
  
  function updateEndStreamButton(isLive, isMyStream) {
    const btn = document.getElementById('lobbyEndStreamBtn');
    const status = document.getElementById('endStreamStatus');
    const canEnd = isMyStream || userInfo?.isAdmin;
    
    if (isLive && canEnd) {
      btn.classList.remove('disabled');
      btn.disabled = false;
      btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
      if (isMyStream) {
        status.textContent = 'You are currently live';
        status.classList.add('live');
      } else {
        status.textContent = `Admin: End ${currentStream?.djName || 'DJ'}'s stream`;
        status.classList.add('live');
      }
    } else if (isLive) {
      btn.classList.add('disabled');
      btn.disabled = true;
      btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
      status.textContent = `${currentStream?.djName || 'Another DJ'} is streaming`;
      status.classList.remove('live');
    } else {
      btn.classList.add('disabled');
      btn.disabled = true;
      btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
      status.textContent = 'No active stream';
      status.classList.remove('live');
    }
  }
  
  function updateTakeoverAttemptsUI() {
    const attemptsLeft = MAX_TAKEOVER_ATTEMPTS - takeoverAttempts;
    const attemptsEl = document.getElementById('takeoverAttemptsLeft');
    const limitEl = document.getElementById('takeoverLimitReached');
    const btn = document.getElementById('requestTakeoverBtn');
    
    if (attemptsLeft <= 0) {
      attemptsEl.classList.add('hidden');
      limitEl.classList.remove('hidden');
      btn.classList.add('disabled');
      btn.disabled = true;
    } else {
      attemptsEl.classList.remove('hidden');
      limitEl.classList.add('hidden');
      attemptsEl.textContent = `${attemptsLeft} request${attemptsLeft !== 1 ? 's' : ''} remaining this session`;
      if (!takeoverPending) {
        btn.classList.remove('disabled');
        btn.disabled = false;
      }
    }
  }
  
  function clearTakeoverTimeout() {
    if (takeoverTimeout) {
      clearInterval(takeoverTimeout);
      takeoverTimeout = null;
    }
    takeoverPending = false;
  }
  
  function setupEventListeners() {
    // Multi Streaming Dropdown Toggle
    document.getElementById('toggleMultiStream')?.addEventListener('click', () => {
      const section = document.querySelector('.multi-stream-section');
      const content = document.getElementById('multiStreamContent');
      if (section && content) {
        section.classList.toggle('expanded');
        content.classList.toggle('hidden');
      }
    });

    // Share Stream Modal
    document.getElementById('openShareModal')?.addEventListener('click', openShareModal);
    document.getElementById('closeShareModal')?.addEventListener('click', closeShareModal);
    document.getElementById('shareStreamModal')?.addEventListener('click', (e) => {
      if (e.target.id === 'shareStreamModal') closeShareModal();
    });
    document.getElementById('shareCaptureBtn')?.addEventListener('click', captureShareThumbnail);
    document.getElementById('shareClearThumbBtn')?.addEventListener('click', clearShareThumbnail);
    document.getElementById('shareToTwitter')?.addEventListener('click', shareToTwitterFromModal);
    document.getElementById('shareToFacebook')?.addEventListener('click', shareToFacebookFromModal);
    document.getElementById('shareCopyLink')?.addEventListener('click', copyStreamLink);
    document.getElementById('sharePostText')?.addEventListener('input', updateCharCount);

    // Twitch save button
    document.getElementById('saveTwitchBtn')?.addEventListener('click', saveTwitchSettings);

    // Copy output URL button
    document.getElementById('copyOutputUrl')?.addEventListener('click', copyOutputUrlToClipboard);

    // Volume sliders (horizontal under video players)
    const obsVolumeSlider = document.getElementById('obsVolumeSlider');
    const liveVolumeSlider = document.getElementById('liveVolumeSlider');
    const obsVideo = document.getElementById('obsVideo');
    const hlsVideo = document.getElementById('hlsVideo');

    if (obsVolumeSlider && obsVideo) {
      obsVolumeSlider.addEventListener('input', (e) => {
        obsVideo.volume = e.target.value / 100;
        if (e.target.value > 0) {
          obsVideo.muted = false;
          updateMuteButtonState('obs', false);
        }
        // Sync with vertical fader
        const verticalFader = document.getElementById('obsVolumeFader');
        const faderVal = document.getElementById('obsVolumeFaderVal');
        if (verticalFader) verticalFader.value = e.target.value;
        if (faderVal) faderVal.textContent = e.target.value;
      });
    }

    if (liveVolumeSlider && hlsVideo) {
      liveVolumeSlider.addEventListener('input', (e) => {
        hlsVideo.volume = e.target.value / 100;
        if (e.target.value > 0) {
          hlsVideo.muted = false;
          updateMuteButtonState('live', false);
        }
        // Sync with vertical fader
        const verticalFader = document.getElementById('liveVolumeFader');
        const faderVal = document.getElementById('liveVolumeFaderVal');
        if (verticalFader) verticalFader.value = e.target.value;
        if (faderVal) faderVal.textContent = e.target.value;
      });
    }

    // Vertical volume faders in broadcast panel
    const obsVolumeFader = document.getElementById('obsVolumeFader');
    const liveVolumeFader = document.getElementById('liveVolumeFader');

    if (obsVolumeFader) {
      obsVolumeFader.addEventListener('input', (e) => {
        const val = e.target.value;
        if (obsVideo) {
          obsVideo.volume = val / 100;
          if (val > 0) {
            obsVideo.muted = false;
            updateMuteButtonState('obs', false);
          }
        }
        // Update value display
        const faderVal = document.getElementById('obsVolumeFaderVal');
        if (faderVal) faderVal.textContent = val;
        // Sync with horizontal slider
        if (obsVolumeSlider) obsVolumeSlider.value = val;
      });
    }

    if (liveVolumeFader) {
      liveVolumeFader.addEventListener('input', (e) => {
        const val = e.target.value;
        if (hlsVideo) {
          hlsVideo.volume = val / 100;
          if (val > 0) {
            hlsVideo.muted = false;
            updateMuteButtonState('live', false);
          }
        }
        // Update value display
        const faderVal = document.getElementById('liveVolumeFaderVal');
        if (faderVal) faderVal.textContent = val;
        // Sync with horizontal slider
        if (liveVolumeSlider) liveVolumeSlider.value = val;
      });
    }

    // DM Modal
    document.getElementById('openDmBtn')?.addEventListener('click', openDmModal);
    document.getElementById('closeDmBtn')?.addEventListener('click', closeDmModal);
    document.querySelector('.dm-modal-overlay')?.addEventListener('click', closeDmModal);
    document.getElementById('dmBackBtn')?.addEventListener('click', goBackToDmList);

    document.getElementById('dmSendBtn')?.addEventListener('click', sendDmMessage);
    document.getElementById('dmInput')?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendDmMessage();
    });

    // DM Notification
    document.getElementById('dmNotifOpenBtn')?.addEventListener('click', openDmFromNotification);
    document.getElementById('dmNotifDismissBtn')?.addEventListener('click', () => {
      document.getElementById('dmNotification')?.classList.add('hidden');
    });


    // Sign out
    document.getElementById('signOutBtn')?.addEventListener('click', async () => {
      try {
        // Stop streaming and cleanup preview
        userIsStreaming = false;
        stopObsPreviewCheck();

        if (presenceRef) {
          await deleteDoc(presenceRef);
        }
        await signOut(auth);
        window.location.href = '/live';
      } catch (e) {
        console.error('Sign out error:', e);
        window.location.href = '/live';
      }
    });
    
    // Lobby End Stream button
    const lobbyEndStreamBtn = document.getElementById('lobbyEndStreamBtn');
    lobbyEndStreamBtn?.addEventListener('click', async () => {
      const btn = document.getElementById('lobbyEndStreamBtn');
      const status = document.getElementById('endStreamStatus');
      if (!btn || btn.classList.contains('disabled')) return;

      if (!confirm('Are you sure you want to end your stream?')) return;

      try {
        btn.disabled = true;
        btn.classList.add('ending');
        btn.innerHTML = '<span class="end-icon">‚è≥</span><span class="end-text">Ending...</span>';
        status.textContent = 'Sending end signal...';
        status.classList.add('ending');

        // Use current stream's DJ ID (for admin ending someone else's stream)
        const targetDjId = currentStream?.djId || currentUser.uid;

        const token = await currentUser.getIdToken();
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            action: 'endStream',
            djId: targetDjId,
            isAdmin: userInfo?.isAdmin || false
          })
        });

        const result = await response.json();
        if (result.success) {
          // Show countdown while stream terminates
          let countdown = 10;
          btn.innerHTML = '<span class="end-icon">üî¥</span><span class="end-text">Stopping...</span><span class="end-countdown">' + countdown + 's</span>';
          status.innerHTML = '‚ö° Stream ending in <strong>' + countdown + '</strong> seconds...';

          const countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
              btn.innerHTML = '<span class="end-icon">üî¥</span><span class="end-text">Stopping...</span><span class="end-countdown">' + countdown + 's</span>';
              status.innerHTML = '‚ö° Stream ending in <strong>' + countdown + '</strong> seconds...';
            } else {
              clearInterval(countdownInterval);
              btn.classList.remove('ending');
              status.classList.remove('ending');
              updateEndStreamButton(false, false);
              status.textContent = 'Stream ended successfully';
              // Stop streaming flag and cleanup preview
              userIsStreaming = false;
              // Refresh stream status
              loadStreamStatus();
              recordStreamEnd();
            }
          }, 1000);
        } else {
          alert('Failed to end stream: ' + (result.error || 'Unknown error'));
          btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
          btn.classList.remove('ending');
          status.classList.remove('ending');
          btn.disabled = false;
        }
      } catch (e) {
        console.error('End stream error:', e);
        alert('Failed to end stream');
        btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
        btn.classList.remove('ending');
        status.classList.remove('ending');
        btn.disabled = false;
      }
    });
    
    // Chat
    document.getElementById('sendBtn')?.addEventListener('click', sendMessage);
    document.getElementById('chatInput')?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    // Play/Pause - handles both audio and video
    document.getElementById('playPauseBtn')?.addEventListener('click', () => {
      const audio = document.getElementById('audioElement');
      const video = document.getElementById('hlsVideo');
      const playIcon = document.getElementById('playIcon');
      const pauseIcon = document.getElementById('pauseIcon');

      // Determine which media element is active
      const isVideoStream = currentStream && currentStream.streamType !== 'audio' && !currentStream.streamUrl?.includes('8000');
      const media = isVideoStream ? video : audio;

      if (!media) return;

      if (isVideoStream) {
        // Video stream - HLS player handles the source
        if (isVideoPlaying) {
          media.pause();
        } else {
          media.play().catch(err => console.error('[HLS] Play error:', err));
        }
      } else {
        // Audio stream
        if (!audio.src && currentStream?.streamUrl) {
          audio.src = currentStream.streamUrl;
          audio.play();
        } else if (audio.paused) {
          audio.play();
        } else {
          audio.pause();
        }
        playIcon.classList.toggle('hidden', !audio.paused);
        pauseIcon.classList.toggle('hidden', audio.paused);
      }
    });

    // Volume - controls both audio and video
    document.getElementById('volumeSlider')?.addEventListener('input', (e) => {
      const volume = e.target.value / 100;
      const audioEl = document.getElementById('audioElement');
      const videoEl = document.getElementById('hlsVideo');
      if (audioEl) audioEl.volume = volume;
      if (videoEl) videoEl.volume = volume;
    });

    document.getElementById('muteBtn')?.addEventListener('click', () => {
      const audio = document.getElementById('audioElement');
      const video = document.getElementById('hlsVideo');
      const isVideoStream = currentStream && currentStream.streamType !== 'audio' && !currentStream.streamUrl?.includes('8000');
      const media = isVideoStream ? video : audio;

      if (media) {
        media.muted = !media.muted;
        const volumeSlider = document.getElementById('volumeSlider');
        if (volumeSlider) volumeSlider.value = media.muted ? 0 : media.volume * 100;
      }
    });

    // =============== SEPARATE PLAYER CONTROLS ===============
    // Track which player has audio active (mutual exclusion)
    let activeAudioPlayer = null; // 'obs' or 'live' or null

    // Update control button icons based on state
    function updatePlayerControlIcons(player, isPlaying, isMuted) {
      const playBtn = document.getElementById(`${player}PlayBtn`);
      const muteBtn = document.getElementById(`${player}MuteBtn`);

      if (playBtn) {
        const playIcon = playBtn.querySelector('.play-icon');
        const pauseIcon = playBtn.querySelector('.pause-icon');
        playIcon?.classList.toggle('hidden', isPlaying);
        pauseIcon?.classList.toggle('hidden', !isPlaying);
      }

      if (muteBtn) {
        const mutedIcon = muteBtn.querySelector('.muted-icon');
        const unmutedIcon = muteBtn.querySelector('.unmuted-icon');
        mutedIcon?.classList.toggle('hidden', !isMuted);
        unmutedIcon?.classList.toggle('hidden', isMuted);
        muteBtn.classList.toggle('muted', isMuted);
      }
    }

    // Mute the other player when one unmutes (mutual exclusion)
    function enforceAudioMutualExclusion(activePlayer) {
      const obsVideo = document.getElementById('obsVideo');
      const liveVideo = document.getElementById('hlsVideo');
      const liveAudio = document.getElementById('audioElement');

      if (activePlayer === 'obs') {
        // Mute live stream
        if (liveVideo) liveVideo.muted = true;
        if (liveAudio) liveAudio.muted = true;
        updatePlayerControlIcons('live', !liveVideo?.paused, true);
        activeAudioPlayer = 'obs';
      } else if (activePlayer === 'live') {
        // Mute OBS preview
        if (obsVideo) obsVideo.muted = true;
        updatePlayerControlIcons('obs', !obsVideo?.paused, true);
        activeAudioPlayer = 'live';
      }
    }

    // OBS Preview Play/Pause
    document.getElementById('obsPlayBtn')?.addEventListener('click', () => {
      const obsVideo = document.getElementById('obsVideo');
      if (!obsVideo) return;

      if (obsVideo.paused) {
        obsVideo.play().catch(err => console.error('[OBS Preview] Play error:', err));
        updatePlayerControlIcons('obs', true, obsVideo.muted);
      } else {
        obsVideo.pause();
        updatePlayerControlIcons('obs', false, obsVideo.muted);
      }
    });

    // OBS Preview Mute/Unmute
    document.getElementById('obsMuteBtn')?.addEventListener('click', () => {
      const obsVideo = document.getElementById('obsVideo');
      if (!obsVideo) return;

      const newMutedState = !obsVideo.muted;
      obsVideo.muted = newMutedState;

      // If unmuting, enforce mutual exclusion
      if (!newMutedState) {
        enforceAudioMutualExclusion('obs');
      }

      updatePlayerControlIcons('obs', !obsVideo.paused, newMutedState);
    });

    // Live Stream Play/Pause
    document.getElementById('livePlayBtn')?.addEventListener('click', () => {
      const liveVideo = document.getElementById('hlsVideo');
      const liveAudio = document.getElementById('audioElement');

      // Determine which media element is active
      const isVideoStream = currentStream && currentStream.streamType !== 'audio' && !currentStream.streamUrl?.includes('8000');
      const media = isVideoStream ? liveVideo : liveAudio;

      if (!media) return;

      if (media.paused) {
        media.play().catch(err => console.error('[Live Stream] Play error:', err));
        updatePlayerControlIcons('live', true, media.muted);
      } else {
        media.pause();
        updatePlayerControlIcons('live', false, media.muted);
      }
    });

    // Live Stream Mute/Unmute
    document.getElementById('liveMuteBtn')?.addEventListener('click', () => {
      const liveVideo = document.getElementById('hlsVideo');
      const liveAudio = document.getElementById('audioElement');

      // Determine which media element is active
      const isVideoStream = currentStream && currentStream.streamType !== 'audio' && !currentStream.streamUrl?.includes('8000');
      const media = isVideoStream ? liveVideo : liveAudio;

      if (!media) return;

      const newMutedState = !media.muted;
      media.muted = newMutedState;

      // If unmuting, enforce mutual exclusion
      if (!newMutedState) {
        enforceAudioMutualExclusion('live');
      }

      updatePlayerControlIcons('live', !media.paused, newMutedState);
    });

    // Update live player icons when video state changes
    const liveVideo = document.getElementById('hlsVideo');
    if (liveVideo) {
      liveVideo.addEventListener('play', () => updatePlayerControlIcons('live', true, liveVideo.muted));
      liveVideo.addEventListener('pause', () => updatePlayerControlIcons('live', false, liveVideo.muted));
    }

    // Update OBS player icons when video state changes
    const obsVideoEl = document.getElementById('obsVideo');
    if (obsVideoEl) {
      obsVideoEl.addEventListener('play', () => updatePlayerControlIcons('obs', true, obsVideoEl.muted));
      obsVideoEl.addEventListener('pause', () => updatePlayerControlIcons('obs', false, obsVideoEl.muted));
    }
    // =============== END SEPARATE PLAYER CONTROLS ===============

    // =============== STEREO AUDIO METERS ===============
    let obsAudioContext = null;
    // Note: obsAnalyserL, obsAnalyserR, liveAnalyserL, liveAnalyserR declared earlier for broadcast panel
    let liveAudioContext = null;
    let obsMeterAnimationId = null;
    let liveMeterAnimationId = null;

    function setupAudioMeter(videoElement, prefix) {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaElementSource(videoElement);
        const splitter = audioContext.createChannelSplitter(2);
        const analyserL = audioContext.createAnalyser();
        const analyserR = audioContext.createAnalyser();

        analyserL.fftSize = 256;
        analyserR.fftSize = 256;
        analyserL.smoothingTimeConstant = 0.5;
        analyserR.smoothingTimeConstant = 0.5;

        source.connect(splitter);
        splitter.connect(analyserL, 0);
        splitter.connect(analyserR, 1);
        source.connect(audioContext.destination);

        return { audioContext, analyserL, analyserR };
      } catch (e) {
        console.error(`[${prefix}] Audio meter setup error:`, e);
        return null;
      }
    }

    // Store previous levels for smoothing
    const meterLevels = new Map();

    function updateLedMeter(analyser, ledRowEl, isLeftChannel) {
      if (!analyser || !ledRowEl) return 0;

      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);

      // Calculate RMS level - reduced sensitivity
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i] * dataArray[i];
      }
      const rms = Math.sqrt(sum / dataArray.length);
      // Calibrated for -6dB peak to light ~8-10 of 12 LEDs
      // At -6dB, RMS is roughly 128, so divide by 160 to get ~80% level
      let level = Math.min(100, (rms / 160) * 100);

      // Get previous level for smoothing
      const meterId = ledRowEl.id;
      const prevLevel = meterLevels.get(meterId) || 0;

      // Smooth decay (fast attack, slower release)
      if (level > prevLevel) {
        // Fast attack
        level = level;
      } else {
        // Slower decay for smoother visuals
        level = prevLevel * 0.85 + level * 0.15;
      }

      // Store for next frame
      meterLevels.set(meterId, level);

      // Get all LEDs in the row
      const leds = ledRowEl.querySelectorAll('.led');
      const numLeds = leds.length;

      // Calculate how many LEDs should be lit (from center outward)
      // Level 0-100 maps to 0-12 LEDs
      const ledsToLight = Math.round((level / 100) * numLeds);

      // For left channel: LEDs go from right to left (index 11 to 0, where 11 is closest to center)
      // For right channel: LEDs go from left to right (index 0 to 11, where 0 is closest to center)
      leds.forEach((led, index) => {
        let shouldLight;
        if (isLeftChannel) {
          // Left channel: light from the end (closest to center) backwards
          shouldLight = index >= (numLeds - ledsToLight);
        } else {
          // Right channel: light from the start (closest to center) forwards
          shouldLight = index < ledsToLight;
        }

        if (shouldLight) {
          led.classList.add('lit');
        } else {
          led.classList.remove('lit');
        }
      });

      return level;
    }

    function animateObsMeters() {
      if (obsAnalyserL && obsAnalyserR) {
        updateLedMeter(obsAnalyserL, document.getElementById('obsLeftLeds'), true);
        updateLedMeter(obsAnalyserR, document.getElementById('obsRightLeds'), false);
      }
      obsMeterAnimationId = requestAnimationFrame(animateObsMeters);
    }

    function animateLiveMeters() {
      if (liveAnalyserL && liveAnalyserR) {
        updateLedMeter(liveAnalyserL, document.getElementById('liveLeftLeds'), true);
        updateLedMeter(liveAnalyserR, document.getElementById('liveRightLeds'), false);
      }
      liveMeterAnimationId = requestAnimationFrame(animateLiveMeters);
    }

    // Setup meters when video plays
    const obsVid = document.getElementById('obsVideo');
    if (obsVid) {
      obsVid.addEventListener('play', () => {
        if (!obsAudioContext) {
          const result = setupAudioMeter(obsVid, 'OBS');
          if (result) {
            obsAudioContext = result.audioContext;
            obsAnalyserL = result.analyserL;
            obsAnalyserR = result.analyserR;
            console.log('[Audio] OBS analysers initialized');
          }
        }
        if (obsAudioContext?.state === 'suspended') {
          obsAudioContext.resume();
        }
        if (!obsMeterAnimationId) animateObsMeters();
        // Also start broadcast meters if panel is visible
        const panel = document.getElementById('broadcastAudioPanel');
        if (panel && !panel.classList.contains('hidden') && !broadcastMeterAnimationId) {
          initBroadcastMeters();
        }
      });
      obsVid.addEventListener('pause', () => {
        if (obsMeterAnimationId) {
          cancelAnimationFrame(obsMeterAnimationId);
          obsMeterAnimationId = null;
        }
        // Clear all LEDs
        document.querySelectorAll('#obsLeftLeds .led, #obsRightLeds .led').forEach(led => led.classList.remove('lit'));
      });
    }

    const liveVid = document.getElementById('hlsVideo');
    if (liveVid) {
      liveVid.addEventListener('play', () => {
        if (!liveAudioContext) {
          const result = setupAudioMeter(liveVid, 'Live');
          if (result) {
            liveAudioContext = result.audioContext;
            liveAnalyserL = result.analyserL;
            liveAnalyserR = result.analyserR;
            console.log('[Audio] Live analysers initialized');
          }
        }
        if (liveAudioContext?.state === 'suspended') {
          liveAudioContext.resume();
        }
        if (!liveMeterAnimationId) animateLiveMeters();
        // Also start broadcast meters if panel is visible and source is live
        const panel = document.getElementById('broadcastAudioPanel');
        if (panel && !panel.classList.contains('hidden') && !broadcastMeterAnimationId) {
          initBroadcastMeters();
        }
      });
      liveVid.addEventListener('pause', () => {
        if (liveMeterAnimationId) {
          cancelAnimationFrame(liveMeterAnimationId);
          liveMeterAnimationId = null;
        }
        // Clear all LEDs
        document.querySelectorAll('#liveLeftLeds .led, #liveRightLeds .led').forEach(led => led.classList.remove('lit'));
      });
    }
    // =============== END STEREO AUDIO METERS ===============

    // =============== AUDIO SOURCE TOGGLE ===============
    let activeAudioSource = 'preview'; // 'preview' or 'live'

    function updateAudioSourceUI() {
      const leftArrow = document.querySelector('.toggle-arrow.left-arrow');
      const rightArrow = document.querySelector('.toggle-arrow.right-arrow');
      const obsControls = document.getElementById('obsControls');
      const liveControls = document.getElementById('liveControls');
      const obsVid = document.getElementById('obsVideo');
      const liveVid = document.getElementById('hlsVideo');

      if (activeAudioSource === 'preview') {
        // Preview active
        leftArrow?.classList.add('active');
        rightArrow?.classList.remove('active');
        obsControls?.classList.remove('dimmed');
        liveControls?.classList.add('dimmed');
        // Unmute preview, mute live
        if (obsVid) obsVid.muted = false;
        if (liveVid) liveVid.muted = true;
      } else {
        // Live active
        leftArrow?.classList.remove('active');
        rightArrow?.classList.add('active');
        obsControls?.classList.add('dimmed');
        liveControls?.classList.remove('dimmed');
        // Mute preview, unmute live
        if (obsVid) obsVid.muted = true;
        if (liveVid) liveVid.muted = false;
      }
    }

    // Toggle button event
    document.getElementById('audioToggleBtn')?.addEventListener('click', () => {
      activeAudioSource = activeAudioSource === 'preview' ? 'live' : 'preview';
      updateAudioSourceUI();
    });

    // Initialize audio source state
    updateAudioSourceUI();
    // =============== END AUDIO SOURCE TOGGLE ===============

    // Ready button - Indicates DJ is ready and shows preview (does NOT go live yet)
    document.getElementById('setReadyBtn')?.addEventListener('click', async () => {
      if (!currentUser) return;

      const btn = document.getElementById('setReadyBtn');
      const btnText = document.getElementById('readyBtnText');
      const goLiveBtn = document.getElementById('goLiveBtn');

      // Disable button and show processing
      btn.disabled = true;
      btn.classList.remove('glow');
      btnText.textContent = '‚è≥ Preparing...';

      try {
        // Set ready status (but don't go live yet)
        await fetch('/api/dj-lobby/presence', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'heartbeat',
            userId: currentUser.uid,
            isReady: true
          })
        });

        // Mark user as preparing - preview will persist
        userIsStreaming = true;

        // Hide stream key info and show audio panel so DJ can preview OBS and check levels
        document.getElementById('streamKeySection')?.classList.add('hidden');
        document.getElementById('broadcastAudioPanel')?.classList.remove('hidden');
        initBroadcastMeters();
        // Expand video player to use the extra space
        document.querySelector('.preview-section')?.classList.add('expanded');

        // Update I'm Ready button to show ready state
        btn.classList.add('is-ready-state');
        btnText.textContent = '‚úì Ready';

        // Show the GO LIVE button
        goLiveBtn?.classList.remove('hidden');

        // Show reminder popup
        alert('üéß Start your streaming software (OBS) now!\n\nCheck that:\n‚Ä¢ Your audio levels are good\n‚Ä¢ Your video preview is showing\n\nWhen everything looks good, press GO LIVE!');

      } catch (e) {
        console.error('Ready error:', e);
        alert(e.message || 'Failed to set ready status. Please try again.');
        // Reset button
        btnText.textContent = 'I\'m Ready!';
        btn.disabled = false;
        btn.classList.add('glow');
      }
    });

    // GO LIVE button - Actually starts the stream
    document.getElementById('goLiveBtn')?.addEventListener('click', async () => {
      if (!currentUser) return;

      const goLiveBtn = document.getElementById('goLiveBtn');
      const goLiveBtnText = document.getElementById('goLiveBtnText');
      const readyBtn = document.getElementById('setReadyBtn');
      const readyBtnText = document.getElementById('readyBtnText');

      // Disable button and show processing
      goLiveBtn.disabled = true;
      goLiveBtnText.textContent = '‚è≥ Going Live...';

      try {
        // Start the stream
        await handleGoLiveReady();

        // Hide GO LIVE button
        goLiveBtn.classList.add('hidden');

        // Update Ready button to show LIVE state
        readyBtn.classList.remove('is-ready-state');
        readyBtn.classList.add('is-ready');
        readyBtn.style.background = '#dc2626';
        readyBtnText.textContent = 'üî¥ LIVE';

      } catch (e) {
        console.error('Go Live error:', e);
        alert(e.message || 'Failed to go live. Please check OBS is streaming and try again.');
        // Reset GO LIVE button
        goLiveBtnText.textContent = 'GO LIVE!';
        goLiveBtn.disabled = false;
      }
    });
    
    // Takeover
    document.getElementById('requestTakeoverBtn')?.addEventListener('click', async () => {
      if (!currentStream || !currentUser) return;
      if (takeoverPending) return;
      
      // Check if limit reached
      if (takeoverAttempts >= MAX_TAKEOVER_ATTEMPTS) {
        return;
      }
      
      try {
        // Increment attempts
        takeoverAttempts++;
        takeoverPending = true;
        updateTakeoverAttemptsUI();
        
        await setDoc(doc(db, 'djTakeoverRequests', currentStream.djId), {
          requesterId: currentUser.uid,
          requesterName: userInfo.name,
          requesterAvatar: userInfo.avatar,
          targetDjId: currentStream.djId,
          targetDjName: currentStream.djName,
          status: 'pending',
          createdAt: serverTimestamp()
        });
        
        await setDoc(doc(db, 'djTakeoverRequests', `request_${currentUser.uid}`), {
          requesterId: currentUser.uid,
          targetDjId: currentStream.djId,
          status: 'pending',
          createdAt: serverTimestamp()
        });
        
        document.getElementById('requestTakeoverBtn').classList.add('hidden');
        document.getElementById('takeoverPending').classList.remove('hidden');
        
        // Start 20-second timeout countdown
        let countdown = 20;
        const countdownEl = document.getElementById('takeoverCountdown');
        countdownEl.textContent = `(${countdown}s)`;
        
        takeoverTimeout = setInterval(() => {
          countdown--;
          countdownEl.textContent = `(${countdown}s)`;
          
          if (countdown <= 0) {
            clearInterval(takeoverTimeout);
            takeoverTimeout = null;
            takeoverPending = false;
            
            // Reset UI - timeout expired
            document.getElementById('takeoverPending').classList.add('hidden');
            
            // Check if more attempts available
            if (takeoverAttempts < MAX_TAKEOVER_ATTEMPTS) {
              document.getElementById('requestTakeoverBtn').classList.remove('hidden');
              document.getElementById('requestTakeoverBtn').classList.remove('disabled');
            }
            
            updateTakeoverAttemptsUI();
            
            // Clean up the pending request
            deleteDoc(doc(db, 'djTakeoverRequests', currentStream.djId)).catch(() => {});
            deleteDoc(doc(db, 'djTakeoverRequests', `request_${currentUser.uid}`)).catch(() => {});
          }
        }, 1000);
        
      } catch (e) {
        console.error('Takeover error:', e);
        alert('Failed to send takeover request');
        takeoverPending = false;
      }
    });
    
    document.getElementById('acceptTakeoverBtn')?.addEventListener('click', async () => {
      const div = document.getElementById('incomingTakeover');
      const requesterId = div.dataset.requesterId;
      if (!requesterId || !currentUser) return;

      try {
        // Get current stream key from the live stream or generated key
        let streamKeyToPass = currentStreamKey;
        let serverUrl = 'rtmp://rtmp.freshwax.co.uk/live';

        // If we have a current stream, use its key
        if (currentStream && currentStream.djId === currentUser.uid && currentStream.streamKey) {
          streamKeyToPass = currentStream.streamKey;
        }

        // If no stream key available, try to fetch it
        if (!streamKeyToPass) {
          const token = await currentUser.getIdToken();
          const response = await fetch('/api/livestream/slots?action=checkStreamKey&djId=' + currentUser.uid, {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          const result = await response.json();
          if (result.success && result.streamKey) {
            streamKeyToPass = result.streamKey;
          }
        }

        // Use the Pusher module to approve takeover (handles API + Pusher broadcast)
        const approved = await approveTakeover(requesterId, streamKeyToPass, serverUrl);

        if (approved) {
          hideIncomingTakeover();
          alert('Takeover approved! The new DJ can now use your stream key.');
        } else {
          alert('Failed to approve takeover. Please try again.');
        }
      } catch (e) {
        console.error('Accept error:', e);
        alert('Failed to approve takeover');
      }
    });
    
    document.getElementById('declineTakeoverBtn')?.addEventListener('click', async () => {
      const div = document.getElementById('incomingTakeover');
      const requesterId = div.dataset.requesterId;
      if (!requesterId) return;

      try {
        // Use the Pusher module to decline takeover (handles API + Pusher broadcast)
        const declined = await declineTakeover(requesterId);

        if (declined) {
          hideIncomingTakeover();
        } else {
          alert('Failed to decline takeover');
        }
      } catch (e) {
        console.error('Decline error:', e);
        alert('Failed to decline takeover');
      }
    });
    
    // End stream
    document.getElementById('endStreamBtn')?.addEventListener('click', async () => {
      if (!confirm('End your stream?')) return;
      
      try {
        const token = await currentUser.getIdToken();
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ action: 'endStream', djId: currentUser.uid })
        });
        
        const result = await response.json();
        if (result.success) {
          alert('Stream ended');
          loadStreamStatus();
        } else {
          alert(result.error || 'Failed');
        }
      } catch (e) {
        console.error('End error:', e);
      }
    });
    
    // Copy buttons (both .copy-btn and .copy-btn-sm)
    document.querySelectorAll('.copy-btn, .copy-btn-sm').forEach(btn => {
      btn.addEventListener('click', () => {
        const code = document.getElementById(btn.dataset.copy);
        if (code) {
          // Get just the text content, strip any extra whitespace
          const textToCopy = code.textContent.trim();
          navigator.clipboard.writeText(textToCopy);
          btn.textContent = 'Copied!';
          setTimeout(() => { btn.textContent = 'Copy'; }, 2000);
        }
      });
    });
  }

  // ============================================
  // LIVESTREAM CHAT (mirrors main live page)
  // ============================================

  let livestreamChatChannel = null;

  async function initLivestreamChat(streamId) {
    if (!streamId) return;

    console.log('[LivestreamChat] Initializing chat for stream:', streamId);
    window.livestreamChatInitialized = true;

    // Load initial messages
    try {
      const response = await fetch(`/api/livestream/chat?streamId=${streamId}&limit=50`);
      const result = await response.json();

      if (result.success && result.messages) {
        renderLivestreamMessages(result.messages);
      }
    } catch (err) {
      console.error('[LivestreamChat] Failed to load messages:', err);
    }

    // Subscribe to Pusher channel for new messages
    if (window.Pusher && window.PUSHER_CONFIG?.key) {
      if (!window.livestreamPusher) {
        window.livestreamPusher = new Pusher(window.PUSHER_CONFIG.key, {
          cluster: window.PUSHER_CONFIG.cluster || 'eu'
        });
      }

      const channelName = `stream-${streamId}`;
      console.log('[LivestreamChat] Subscribing to channel:', channelName);

      livestreamChatChannel = window.livestreamPusher.subscribe(channelName);

      livestreamChatChannel.bind('new-message', (data) => {
        console.log('[LivestreamChat] New message:', data);
        appendLivestreamMessage(data);
      });
    }

    // Setup send button handler
    setupLivestreamChatSend(streamId);

    // Show chat form if logged in
    if (currentUser) {
      document.getElementById('loginPrompt')?.classList.add('hidden');
      document.getElementById('chatForm')?.classList.remove('hidden');
    }
  }

  function renderLivestreamMessages(messages, forceScrollToBottom = true) {
    const container = document.getElementById('chatMessages');
    if (!container) return;

    if (!messages || messages.length === 0) {
      container.innerHTML = '';
      return;
    }

    // Sort messages by createdAt - ascending (oldest first at top, newest last at bottom)
    const sortedMessages = [...messages].sort((a, b) => {
      const dateA = a.createdAt ? new Date(a.createdAt) : new Date(0);
      const dateB = b.createdAt ? new Date(b.createdAt) : new Date(0);
      return dateA.getTime() - dateB.getTime();
    });

    // Check if user was at bottom before rendering
    const wasAtBottom = forceScrollToBottom || container.scrollTop + container.clientHeight >= container.scrollHeight - 50;

    // Filter out bot messages for DJ Lobby
    const filteredMessages = sortedMessages.filter(msg => msg.type !== 'bot');
    container.innerHTML = filteredMessages.map(msg => formatLivestreamMessage(msg)).join('');

    // Scroll to bottom if user was already there
    if (wasAtBottom) {
      const scrollToBottom = () => {
        const lastMessage = container.querySelector('.ls-chat-message:last-of-type');
        if (lastMessage) {
          lastMessage.scrollIntoView({ behavior: 'instant', block: 'end' });
        } else {
          container.scrollTop = container.scrollHeight;
        }
      };
      // Multiple scroll attempts to ensure it works after DOM paints
      scrollToBottom();
      requestAnimationFrame(scrollToBottom);
      setTimeout(scrollToBottom, 50);
      setTimeout(scrollToBottom, 150);
    }
  }

  function appendLivestreamMessage(msg) {
    const container = document.getElementById('chatMessages');
    if (!container) return;

    // Skip bot messages in DJ Lobby
    if (msg.type === 'bot') return;

    // Check if user was at bottom before adding
    const wasAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 50;

    // Remove welcome message if present
    const welcome = container.querySelector('.chat-welcome');
    if (welcome) welcome.remove();

    const msgHtml = formatLivestreamMessage(msg);
    container.insertAdjacentHTML('beforeend', msgHtml);

    // Scroll to bottom if user was already there
    if (wasAtBottom) {
      const scrollToBottom = () => {
        const lastMessage = container.querySelector('.ls-chat-message:last-of-type');
        if (lastMessage) {
          lastMessage.scrollIntoView({ behavior: 'instant', block: 'end' });
        } else {
          container.scrollTop = container.scrollHeight;
        }
      };
      scrollToBottom();
      requestAnimationFrame(scrollToBottom);
    }
  }

  function formatLivestreamMessage(msg) {
    const time = msg.createdAt ? new Date(msg.createdAt).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : '';
    const initial = (msg.userName || 'U').charAt(0).toUpperCase();
    const avatarHtml = msg.userAvatar
      ? `<img src="${msg.userAvatar}" alt="" class="ls-chat-avatar" onerror="this.outerHTML='<span class=\\'ls-chat-avatar-letter\\'>${initial}</span>'" />`
      : `<span class="ls-chat-avatar-letter">${initial}</span>`;

    // Handle GIF messages
    if (msg.type === 'giphy' && msg.giphyUrl) {
      return `
        <div class="ls-chat-message" data-message-id="${msg.id || ''}">
          <div class="ls-chat-header">
            <div class="ls-chat-user">
              ${avatarHtml}
              <span class="ls-chat-username">${escapeHtml(msg.userName || 'User')}</span>
            </div>
            <span class="ls-chat-time">${time}</span>
          </div>
          <div class="ls-chat-gif">
            <img src="${msg.giphyUrl}" alt="GIF" loading="lazy" />
          </div>
        </div>
      `;
    }

    // Handle bot messages
    const badgeHtml = msg.badge ? `<span class="ls-chat-badge">${msg.badge}</span>` : '';
    const botClass = msg.type === 'bot' ? 'ls-bot-message' : '';

    return `
      <div class="ls-chat-message ${botClass}" data-message-id="${msg.id || ''}">
        <div class="ls-chat-header">
          <div class="ls-chat-user">
            ${avatarHtml}
            <span class="ls-chat-username">${escapeHtml(msg.userName || 'User')}</span>
            ${badgeHtml}
          </div>
          <span class="ls-chat-time">${time}</span>
        </div>
        <div class="ls-chat-text">${escapeHtml(msg.message || '')}</div>
      </div>
    `;
  }

  function setupLivestreamChatSend(streamId) {
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');

    if (!chatInput || !sendBtn) return;

    const sendMessage = async () => {
      const message = chatInput.value.trim();
      if (!message || !currentUser) return;

      const userName = userInfo?.displayName || userInfo?.firstName || currentUser.displayName || currentUser.email?.split('@')[0] || 'User';
      const userAvatar = userInfo?.photoURL || currentUser.photoURL || null;

      // Optimistic UI - show message immediately
      const tempMsg = {
        id: 'temp_' + Date.now(),
        userId: currentUser.uid,
        userName: userName,
        userAvatar: userAvatar,
        message: message,
        type: 'text',
        createdAt: new Date().toISOString()
      };
      appendLivestreamMessage(tempMsg);

      chatInput.value = '';
      chatInput.disabled = true;
      sendBtn.disabled = true;

      try {
        const response = await fetch('/api/livestream/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            streamId: streamId,
            userId: currentUser.uid,
            userName: userName,
            userAvatar: userAvatar,
            message: message,
            type: 'text'
          })
        });

        if (!response.ok) {
          const err = await response.json();
          console.error('[LivestreamChat] Send failed:', err);
        }
      } catch (err) {
        console.error('[LivestreamChat] Send error:', err);
      } finally {
        chatInput.disabled = false;
        sendBtn.disabled = false;
        chatInput.focus();
      }
    };

    sendBtn.addEventListener('click', sendMessage);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
  }

  // Cleanup chat and switch to playlist-global when stream ends
  function cleanupLivestreamChat() {
    // Unsubscribe from current stream channel
    if (livestreamChatChannel) {
      livestreamChatChannel.unbind_all();
      window.livestreamPusher?.unsubscribe(livestreamChatChannel.name);
      livestreamChatChannel = null;
    }

    // Switch to playlist-global so DJs can monitor main page chat
    // (the main live page uses playlist-global when no stream is active)
    window.livestreamChatInitialized = false;
    window.currentStreamId = 'playlist-global';
    initLivestreamChat('playlist-global');
    console.log('[LivestreamChat] Switched to playlist-global for DJ waitlist monitoring');
  }
</script>
</body>
</html>
