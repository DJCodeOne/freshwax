---
// src/pages/account/dj-lobby.astro
// DJ-only lobby with stream preview, private chat, streaming instructions, and takeover system
import '../../styles/dj-lobby.css';
export const prerender = false;

// Pusher config for client-side (PUBLIC_ prefixed vars are safe to expose)
const pusherConfig = {
  key: import.meta.env.PUBLIC_PUSHER_KEY || '',
  cluster: import.meta.env.PUBLIC_PUSHER_CLUSTER || 'eu'
};
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DJ Lobby - Fresh Wax</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- HLS.js for video playback -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>

  <!-- Pusher configuration - must be set before dj-lobby-pusher.js loads -->
  <script define:vars={{ pusherConfig }}>
    window.PUSHER_CONFIG = pusherConfig;
  </script>
</head>
<body class="dj-lobby-page">
  <!-- Auth Gate -->
  <div id="authGate" class="auth-gate">
    <div class="auth-content">
      <div class="spinner"></div>
      <p>Checking DJ access...</p>
    </div>
  </div>
  
  <!-- Access Denied -->
  <div id="accessDenied" class="access-denied hidden">
    <div class="denied-content">
      <div class="denied-icon">üîí</div>
      <h1>DJ Access Only</h1>
      <p>This area is restricted to approved DJs.</p>
      <a href="/live" class="back-btn">Back to Live</a>
    </div>
  </div>
  
  <!-- Not Eligible - Needs mix with likes -->
  <div id="notEligible" class="not-eligible hidden">
    <div class="not-eligible-content">
      <div class="not-eligible-icon">üéß</div>
      <h1>ALMOST <span class="red">THERE</span></h1>
      <p id="eligibilityMessage">You need to build your reputation before accessing the DJ Lobby.</p>
      
      <!-- Two-column layout: Requirements on left, Access options on right -->
      <div class="eligibility-layout">
        <!-- Left column: Requirements -->
        <div class="eligibility-left">
          <div class="eligibility-requirements">
            <h3>To Access DJ Lobby, You Need:</h3>
            <div class="requirement-list">
              <div id="reqMixes" class="requirement">
                <span class="req-icon">‚ùå</span>
                <span class="req-text">At least 1 DJ mix uploaded</span>
              </div>
              <div id="reqLikes" class="requirement">
                <span class="req-icon">‚ùå</span>
                <span class="req-text">At least 10 likes on one of your mixes</span>
              </div>
            </div>

            <div id="progressInfo" class="progress-info">
              <p>Your best mix: <span id="bestMixLikes">0</span>/10 likes</p>
              <div class="progress-bar">
                <div id="likesProgress" class="progress-fill" style="width: 0%"></div>
              </div>
            </div>
          </div>

          <div class="eligibility-actions">
            <a href="/upload-mix" class="action-btn primary">Upload a Mix ‚Üí</a>
            <a href="/dj-mixes" class="action-btn secondary">View DJ Mixes</a>
            <a href="/live" class="action-btn secondary">Back to Live</a>
          </div>
        </div>

        <!-- Right column: Access options -->
        <div class="eligibility-right">
          <!-- Bypass Request Section -->
          <div id="bypassRequestSection" class="bypass-request-section">
            <!-- Request Form State -->
            <div id="bypassRequestForm" class="bypass-form-card">
              <div class="bypass-header">
                <span class="bypass-icon">‚ö°</span>
                <div>
                  <h4>Need access now?</h4>
                  <p>Request bypass access - an admin will review and approve.</p>
                </div>
              </div>
              <div class="bypass-form-inner">
                <textarea id="bypassReason" placeholder="Why do you need immediate access? (optional)" rows="2" maxlength="200"></textarea>
                <button id="submitBypassRequest" class="bypass-request-btn">
                  üé´ Request Bypass Access
                </button>
              </div>
            </div>

            <!-- Pending State -->
            <div id="bypassPending" class="bypass-status-card pending hidden">
              <div class="status-header">
                <span class="status-icon">‚è≥</span>
                <div>
                  <h4>Request Pending</h4>
                  <p>Your bypass request has been submitted. You'll get access once an admin approves it.</p>
                </div>
              </div>
              <button id="cancelBypassRequest" class="cancel-bypass-btn">Cancel Request</button>
            </div>

            <!-- Approved State -->
            <div id="bypassApproved" class="bypass-status-card approved hidden">
              <div class="status-header">
                <span class="status-icon">‚úÖ</span>
                <div>
                  <h4>Bypass Approved!</h4>
                  <p>Your request has been approved. Click below to enter the lobby.</p>
                </div>
              </div>
              <button id="continueWithBypass" class="continue-bypass-btn">Enter DJ Lobby ‚Üí</button>
            </div>

            <!-- Denied State -->
            <div id="bypassDenied" class="bypass-status-card denied hidden">
              <div class="status-header">
                <span class="status-icon">‚ùå</span>
                <div>
                  <h4>Request Denied</h4>
                  <p id="bypassDenialReason">Your request was not approved at this time.</p>
                </div>
              </div>
              <button id="resubmitBypassRequest" class="resubmit-bypass-btn">Submit New Request</button>
            </div>
          </div>

          <!-- Quick Access Key Section -->
          <div id="quickAccessSection" class="quick-access-section">
            <div class="quick-access-card">
              <div class="quick-access-header">
                <span class="quick-access-icon">üîë</span>
                <div>
                  <h4>Have an access code?</h4>
                  <p>Enter a quick access code to gain instant DJ lobby access.</p>
                </div>
              </div>
              <div class="quick-access-form">
                <input type="text" id="quickAccessCodeInput" placeholder="Enter access code" maxlength="10" autocomplete="off" />
                <button id="redeemAccessCodeBtn" class="redeem-code-btn">
                  <span class="btn-text">Redeem Code</span>
                  <span class="btn-spinner hidden">‚è≥</span>
                </button>
              </div>
              <p id="quickAccessError" class="quick-access-error hidden"></p>
              <p id="quickAccessSuccess" class="quick-access-success hidden"></p>
            </div>
          </div>
        </div>
      </div>

      <div class="eligibility-why">
        <h4>Why this requirement?</h4>
        <p>This helps ensure our livestreams feature genuine DJs who play jungle and drum & bass music. Upload a quality mix, get your fans to show some love, and you'll be in the lobby in no time! üîä</p>
      </div>
    </div>
  </div>
  
  <!-- Main Lobby -->
  <div id="mainLobby" class="lobby-container hidden">
    <header class="lobby-header">
      <div class="header-left">
        <a href="/live" class="back-link">
          <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
            <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
          </svg>
          Back to Live
        </a>
      </div>
      <div class="header-center">
        <h1>DJ <span class="red">LOBBY</span></h1>
        <p>Private space for Fresh Wax DJs</p>
      </div>
      <div class="header-right">
        <div class="user-info">
          <div class="header-avatar-container">
            <img id="headerAvatar" src="/place-holder.webp" alt="" class="header-avatar" />
            <div id="headerAvatarLetter" class="header-avatar-letter hidden">?</div>
          </div>
          <span id="headerName" class="header-name">Loading...</span>
        </div>
        <button id="signOutBtn" class="sign-out-btn">Sign Out</button>
      </div>
    </header>
    
    <div class="lobby-layout">
      <!-- Far Left Column: Stream Key -->
      <div class="key-column">
        <!-- Stream Control Card -->
        <div class="stream-control-card">
          <button id="goLiveBtn" class="go-live-btn">
            <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
              <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
            </svg>
            Go Live
          </button>
          <div class="control-divider"></div>
          <button id="lobbyEndStreamBtn" class="lobby-end-stream-btn disabled" disabled>
            <span class="end-icon">‚èπ</span>
            <span class="end-text">End Stream</span>
          </button>
          <p id="endStreamStatus" class="end-stream-status">No active stream</p>
        </div>
        
        <!-- Takeover Section -->
        <div class="takeover-section" id="takeoverBox">
          <div class="section-header">
            <h3>üîÑ Stream Takeover</h3>
          </div>
          
          <div id="takeoverRequest" class="takeover-content hidden">
            <p>Request to take over from <strong id="takeoverFromName">DJ</strong></p>
            <button id="requestTakeoverBtn" class="takeover-btn">Request Takeover</button>
            <p id="takeoverPending" class="takeover-pending hidden">‚è≥ Waiting for response... <span id="takeoverCountdown"></span></p>
            <p id="takeoverAttemptsLeft" class="takeover-attempts">3 requests remaining this session</p>
            <p id="takeoverLimitReached" class="takeover-limit hidden">‚ö†Ô∏è No requests remaining this session</p>
          </div>
          
          <div id="incomingTakeover" class="incoming-takeover hidden">
            <div class="incoming-badge">‚ö° TAKEOVER REQUEST</div>
            <div class="incoming-dj">
              <img id="incomingDjAvatar" src="/place-holder.webp" alt="" />
              <div>
                <strong id="incomingDjName">DJ Name</strong>
                <span>wants to take over</span>
              </div>
            </div>
            <div class="incoming-actions">
              <button id="acceptTakeoverBtn" class="accept-btn">‚úì Accept</button>
              <button id="declineTakeoverBtn" class="decline-btn">‚úï Decline</button>
            </div>
          </div>
          
          <div id="takeoverApproved" class="takeover-approved hidden">
            <div class="approved-badge">‚úì APPROVED</div>
            <p>Copy these into OBS:</p>
            <div class="takeover-creds">
              <div class="cred-row">
                <label>Server</label>
                <div class="cred-value">
                  <code id="takeoverServerUrl">-</code>
                  <button class="copy-btn" data-copy="takeoverServerUrl">Copy</button>
                </div>
              </div>
              <div class="cred-row">
                <label>Key</label>
                <div class="cred-value">
                  <code id="takeoverStreamKey">-</code>
                  <button class="copy-btn" data-copy="takeoverStreamKey">Copy</button>
                </div>
              </div>
            </div>
          </div>
          
          <div id="noStreamTakeover" class="no-stream-msg">
            <p>No active stream to take over.</p>
          </div>
        </div>
        
        <!-- Streaming Setup Link -->
        <div class="setup-link-section">
          <a href="/account/streaming-setup" class="setup-link-btn">
            <span class="setup-icon">üìñ</span>
            <span class="setup-text">Streaming Setup Guide</span>
            <span class="setup-arrow">‚Üí</span>
          </a>
        </div>

        <!-- OBS Setup -->
        <div class="obs-setup-section">
          <details class="obs-instructions-compact">
            <summary>üé¨ OBS Quick Setup</summary>
            <ol>
              <li>Settings ‚Üí Stream ‚Üí Custom</li>
              <li>Paste Server URL & Key</li>
              <li>Start Streaming in OBS</li>
              <li>Click Go Live below</li>
            </ol>
          </details>
        </div>

        <!-- DJs Online Box -->
        <div class="djs-online-box">
          <div class="box-header">
            <h3>üéß DJs in Lobby</h3>
            <span class="online-count"><span id="onlineDjCount">0</span> online</span>
          </div>
          <div id="djsList" class="djs-list">
            <p class="empty-state">No DJs online yet</p>
          </div>
        </div>
      </div>
      
      <!-- Middle Column: Preview Only -->
      <div class="main-column">
        <!-- Current Stream Preview -->
        <div class="preview-section">
          <div class="preview-header">
            <h2>Current Stream</h2>
            <div class="stream-status" id="streamStatus">
              <span class="status-dot offline"></span>
              <span id="statusText">No one streaming</span>
            </div>
          </div>
          
          <div class="preview-player" id="previewPlayer">
            <div id="offlineState" class="offline-state">
              <div class="offline-icon">üì°</div>
              <h3>No Live Stream</h3>
              <p>Be the first to go live!</p>
            </div>
            
            <div id="videoPreview" class="video-preview hidden">
              <video id="hlsVideo" playsinline autoplay></video>
            </div>

            <div id="audioPreview" class="audio-preview hidden">
              <div class="audio-visualizer">
                <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                <div class="viz-bar"></div><div class="viz-bar"></div>
              </div>
              <img id="streamCover" src="/place-holder.webp" alt="Stream" class="stream-cover" />
              <audio id="audioElement" crossorigin="anonymous" autoplay></audio>
            </div>
            
            <!-- Time Remaining Overlay -->
            <div id="timeRemaining" class="time-remaining hidden">
              <span class="time-label">Time Remaining</span>
              <span id="timeLeft" class="time-value">--:--</span>
            </div>
          </div>
          
          <div class="player-controls">
            <button id="playPauseBtn" class="control-btn">
              <svg id="playIcon" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                <path d="M8 5v14l11-7z"/>
              </svg>
              <svg id="pauseIcon" class="hidden" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
              </svg>
            </button>
            
            <div class="volume-control">
              <button id="muteBtn" class="control-btn small">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                  <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                </svg>
              </button>
              <input type="range" id="volumeSlider" min="0" max="100" value="80" />
            </div>
            
            <div class="stream-info-display">
              <img id="currentDjAvatar" src="/place-holder.webp" alt="" class="current-dj-avatar" />
              <div class="current-dj-details">
                <span id="currentDjName" class="dj-name">-</span>
                <span id="currentStreamTitle" class="stream-title">No stream</span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Stream Key Section (under video player) - Inline Go Live Info -->
        <div class="stream-key-section" id="streamKeySection">
          <div class="section-header">
            <h3>üéôÔ∏è Go Live Setup</h3>
            <span id="keyStatus" class="key-status ready">Ready</span>
          </div>

          <!-- Always visible Go Live controls - 2x2 Grid Layout -->
          <div id="keyAvailable" class="key-available">
            <div class="go-live-grid">
              <!-- Top Left: Stream Title -->
              <div class="grid-cell">
                <label for="inlineStreamTitle">Stream Title</label>
                <input type="text" id="inlineStreamTitle" placeholder="e.g., Friday Night Jungle Session" maxlength="60" />
              </div>

              <!-- Top Right: Genre -->
              <div class="grid-cell">
                <label for="inlineStreamGenre">Genre</label>
                <select id="inlineStreamGenre">
                  <option value="Jungle / D&B">Jungle / D&B</option>
                  <option value="Jungle">Jungle</option>
                  <option value="Drum & Bass">Drum & Bass</option>
                  <option value="Liquid D&B">Liquid D&B</option>
                  <option value="Ragga Jungle">Ragga Jungle</option>
                  <option value="Neurofunk">Neurofunk</option>
                  <option value="Jump Up">Jump Up</option>
                  <option value="Breakbeat">Breakbeat</option>
                </select>
              </div>

              <!-- Stream Credentials - Separate Containers -->
              <div class="credentials-row-split">
                <div class="cred-box">
                  <label>RTMP Server</label>
                  <div class="cred-value">
                    <code id="rtmpUrl">rtmp://rtmp.freshwax.co.uk/live</code>
                    <button class="copy-btn" data-copy="rtmpUrl">Copy</button>
                  </div>
                </div>
                <div class="cred-box">
                  <label>Stream Key</label>
                  <div class="cred-value">
                    <code id="myStreamKey">Loading...</code>
                    <button class="copy-btn" data-copy="myStreamKey">Copy</button>
                  </div>
                </div>
              </div>
            </div>

            <!-- Go Live Button - Full Width with Glow -->
            <div class="ready-section" id="readySection">
              <button id="setReadyBtn" class="ready-btn large glow">
                <span id="readyBtnText">üéØ I'm Ready - Go Live!</span>
              </button>
              <p id="readyStatus" class="ready-status hidden">‚úì You're set as ready.</p>
            </div>
          </div>

        </div>
      </div>
      
      <!-- Right Column: Chat + Viewers side by side -->
      <div class="right-column">
        <!-- Chat Section -->
        <div class="chat-section">
          <div class="chat-header">
            <h2>üí¨ DJ Chat</h2>
            <div class="chat-header-actions">
              <span class="chat-hint">Private</span>
              <button id="openDmBtn" class="dm-btn">DM</button>
            </div>
          </div>
          
          <div class="chat-messages" id="chatMessages">
            <div class="chat-welcome">
              <p>Welcome to the DJ Lobby! üëã</p>
              <p class="hint">Chat with other DJs, coordinate sets, and hang out.</p>
            </div>
          </div>
          
          <div class="chat-input-section">
            <div class="chat-input-wrapper">
              <input type="text" id="chatInput" placeholder="Message other DJs..." maxlength="500" autocomplete="off" />
              <button id="sendBtn" type="button">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                  <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                </svg>
              </button>
            </div>
          </div>
        </div>
        
        <!-- Relay Chat (shown when streaming via relay) -->
        <div id="relayChatSection" class="relay-chat-section hidden">
          <div class="relay-chat-header">
            <h3>üì∫ <span id="relayChatSourceName">Source Chat</span></h3>
            <button id="toggleRelayChatBtn" class="toggle-relay-chat-btn" title="Toggle chat">‚àí</button>
          </div>
          <div id="relayChatContainer" class="relay-chat-container">
            <iframe id="relayChatFrame" class="relay-chat-frame" allow="autoplay" allowfullscreen></iframe>
            <div id="relayChatUnsupported" class="relay-chat-unsupported hidden">
              <p>Chat embed not available for this platform.</p>
              <a id="relayChatExternalLink" href="#" target="_blank" rel="noopener" class="open-chat-link">Open Chat in New Tab ‚Üí</a>
            </div>
          </div>
        </div>

        <!-- Stream Viewers Column -->
        <div class="viewers-column">
          <div class="viewers-header">
            <span class="viewers-dot"></span>
            <span>Watching</span>
            <span class="viewers-count" id="viewerCount">0</span>
          </div>
          <div class="viewers-list" id="viewersList">
            <p class="no-viewers-msg">No viewers yet</p>
          </div>
        </div>
      </div>
    </div>

    <footer class="lobby-footer">
      <span>Fresh Wax</span>
      <span class="footer-dot">‚Ä¢</span>
      <span>DJ Lobby</span>
    </footer>
    
    <!-- Go Live Modal -->
    <div id="goLiveModal" class="go-live-modal hidden">
      <div class="go-live-modal-overlay"></div>
      <div class="go-live-modal-content">
        <div class="go-live-modal-header">
          <h2>üéôÔ∏è Go Live</h2>
          <button id="closeGoLiveBtn" class="close-go-live-btn">‚úï</button>
        </div>

        <div class="go-live-modal-body">
          <!-- Step 1: Stream Setup -->
          <div id="goLiveStep1" class="go-live-step">
            <div class="step-indicator">
              <span class="step-number active">1</span>
              <span class="step-line"></span>
              <span class="step-number">2</span>
            </div>

            <h3>Setup Your Stream</h3>

            <!-- Stream Source Selector (shown only if relay is approved) -->
            <div id="streamSourceSelector" class="stream-source-selector hidden">
              <label>Stream Source</label>
              <div class="source-options">
                <button type="button" class="source-option active" data-source="obs">
                  <span class="source-icon">üì°</span>
                  <span class="source-label">OBS / RTMP</span>
                  <span class="source-desc">Stream from your computer</span>
                </button>
                <button type="button" class="source-option" data-source="relay" id="relaySourceOption">
                  <span class="source-icon">üîÑ</span>
                  <span class="source-label" id="relaySourceLabel">Relay</span>
                  <span class="source-desc" id="relaySourceDesc">Relay from another station</span>
                </button>
              </div>
            </div>

            <!-- OBS Stream Setup (default) -->
            <div id="obsStreamSetup">
              <p class="step-desc">Copy these settings into OBS Studio or your streaming software:</p>

              <div class="stream-credentials">
              <div class="cred-row">
                <label>Server URL</label>
                <div class="cred-value">
                  <code id="goLiveServerUrl">rtmp://rtmp.freshwax.co.uk/live</code>
                  <button class="copy-btn" data-copy="goLiveServerUrl">Copy</button>
                </div>
              </div>
              <div class="cred-row">
                <label>Stream Key</label>
                <div class="cred-value">
                  <code id="goLiveStreamKey">Loading...</code>
                  <button class="copy-btn" data-copy="goLiveStreamKey">Copy</button>
                </div>
              </div>
            </div>

            <div class="stream-info-inputs">
              <div class="input-row">
                <label for="goLiveTitle">Stream Title</label>
                <input type="text" id="goLiveTitle" placeholder="e.g., Friday Night Jungle Session" maxlength="60" />
              </div>
              <div class="input-row">
                <label for="goLiveGenre">Genre</label>
                <select id="goLiveGenre">
                  <option value="Jungle / D&B">Jungle / D&B</option>
                  <option value="Jungle">Jungle</option>
                  <option value="Drum & Bass">Drum & Bass</option>
                  <option value="Liquid D&B">Liquid D&B</option>
                  <option value="Ragga Jungle">Ragga Jungle</option>
                  <option value="Neurofunk">Neurofunk</option>
                  <option value="Jump Up">Jump Up</option>
                  <option value="Breakbeat">Breakbeat</option>
                </select>
              </div>
            </div>

            <div class="step-instructions">
                <h4>Instructions:</h4>
                <ol>
                  <li>Open OBS Studio (or your streaming app)</li>
                  <li>Go to Settings ‚Üí Stream</li>
                  <li>Set Service to "Custom"</li>
                  <li>Paste the Server URL and Stream Key above</li>
                  <li>Click "Start Streaming" in OBS</li>
                  <li>Come back here and click "I'm Ready"</li>
                </ol>
              </div>
            </div>

            <!-- Relay Stream Setup (shown when relay source selected) -->
            <div id="relayStreamSetup" class="hidden">
              <div class="relay-info-card">
                <div class="relay-station-header">
                  <span class="relay-station-icon">üì°</span>
                  <div>
                    <h4 id="relayStationName">Station Name</h4>
                    <p class="relay-station-status">Approved relay source</p>
                  </div>
                </div>
                <p class="relay-station-desc">Your stream will be pulled from this external source and broadcast on Fresh Wax.</p>
                <div class="relay-url-display">
                  <label>Relay URL</label>
                  <code id="relayUrlDisplay">rtmp://...</code>
                </div>
              </div>

              <div class="stream-info-inputs">
                <div class="input-row">
                  <label for="relayStreamTitle">Stream Title</label>
                  <input type="text" id="relayStreamTitle" placeholder="e.g., Live from Kool FM" maxlength="60" />
                </div>
                <div class="input-row">
                  <label for="relayStreamGenre">Genre</label>
                  <select id="relayStreamGenre">
                    <option value="Jungle / D&B">Jungle / D&B</option>
                    <option value="Jungle">Jungle</option>
                    <option value="Drum & Bass">Drum & Bass</option>
                    <option value="Liquid D&B">Liquid D&B</option>
                    <option value="Ragga Jungle">Ragga Jungle</option>
                    <option value="Neurofunk">Neurofunk</option>
                    <option value="Jump Up">Jump Up</option>
                    <option value="Breakbeat">Breakbeat</option>
                  </select>
                </div>
              </div>

              <div class="step-instructions relay-instructions">
                <h4>How Relay Works:</h4>
                <ol>
                  <li>Make sure you're live on your external station</li>
                  <li>Ensure you have a booked slot on Fresh Wax at this time</li>
                  <li>Click "Start Relay" and we'll pull your stream</li>
                </ol>
              </div>
            </div>

            <div class="step-actions">
              <button id="goLiveReadyBtn" class="ready-btn">
                <span class="ready-icon">üéØ</span>
                I'm Ready - Go Live!
              </button>
              <p class="ready-hint" id="readyHint">Click once you've started streaming in OBS</p>
            </div>
          </div>

          <!-- Step 2: Connecting -->
          <div id="goLiveStep2" class="go-live-step hidden">
            <div class="connecting-state">
              <div class="connecting-spinner"></div>
              <h3>Connecting to your stream...</h3>
              <p>Verifying that OBS is streaming to Fresh Wax</p>
              <p id="connectionStatus" class="connection-status">Checking stream...</p>
            </div>
          </div>

          <!-- Step 3: Live! -->
          <div id="goLiveStep3" class="go-live-step hidden">
            <div class="live-state">
              <div class="live-badge">üî¥ LIVE</div>
              <h3>You're Live on Fresh Wax!</h3>
              <p>Your stream is now visible to everyone.</p>
              <button id="closeGoLiveSuccessBtn" class="close-success-btn">Close</button>
            </div>
          </div>

          <!-- Error State -->
          <div id="goLiveError" class="go-live-step hidden">
            <div class="error-state">
              <div class="error-icon">‚ö†Ô∏è</div>
              <h3>Stream Not Detected</h3>
              <p id="goLiveErrorMsg">We couldn't detect your stream. Make sure OBS is streaming with the correct key.</p>
              <button id="goLiveRetryBtn" class="retry-btn">Try Again</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- DM Modal -->
    <div id="dmModal" class="dm-modal hidden">
      <div class="dm-modal-overlay"></div>
      <div class="dm-modal-content">
        <div class="dm-modal-header">
          <h2>üì© Direct Message</h2>
          <button id="closeDmBtn" class="close-dm-btn">‚úï</button>
        </div>
        
        <!-- DJ Selection View -->
        <div id="dmSelectView" class="dm-view">
          <p class="dm-select-hint">Select a DJ to message privately:</p>
          <div id="dmDjList" class="dm-dj-list">
            <p class="empty-state">No other DJs online</p>
          </div>
          <div class="dm-notice">
            <span class="notice-icon">‚ö†Ô∏è</span>
            <span>Messages are not stored and will be deleted when this chat closes.</span>
          </div>
        </div>
        
        <!-- Chat View -->
        <div id="dmChatView" class="dm-view hidden">
          <div class="dm-chat-header">
            <button id="dmBackBtn" class="dm-back-btn">‚Üê Back</button>
            <div class="dm-chat-with">
              <span id="dmChatWithName">DJ Name</span>
            </div>
          </div>
          <div class="dm-messages" id="dmMessages">
            <div class="dm-welcome">
              <p>Start a private conversation</p>
              <p class="hint">Only you and this DJ can see these messages.</p>
            </div>
          </div>
          <div class="dm-input-section">
            <div class="dm-input-wrapper">
              <input type="text" id="dmInput" placeholder="Type a message..." maxlength="500" autocomplete="off" />
              <button id="dmSendBtn" type="button">
                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                  <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="dm-notice small">
            <span class="notice-icon">‚ö†Ô∏è</span>
            <span>This chat is temporary and not stored.</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- DM Notification -->
    <div id="dmNotification" class="dm-notification hidden">
      <div class="dm-notif-content">
        <span class="dm-notif-icon">üí¨</span>
        <span id="dmNotifText">New DM from DJ Name</span>
        <button id="dmNotifOpenBtn" class="dm-notif-open">Open</button>
        <button id="dmNotifDismissBtn" class="dm-notif-dismiss">‚úï</button>
      </div>
    </div>
  </div>


<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
  import { getAuth, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
  import { getFirestore, collection, query, orderBy, limit, addDoc, serverTimestamp, doc, setDoc, deleteDoc, getDocs, getDoc, where } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';
  
  // Pusher-based real-time features (replaces Firebase onSnapshot)
  import { 
    initDjLobbyPusher, 
    sendChatMessage, 
    requestTakeover, 
    approveTakeover, 
    declineTakeover,
    openDmConversation,
    sendDm,
    cleanup as cleanupPusher,
    getOnlineDjs
  } from '/dj-lobby-pusher.js?v=3';
  
  const app = initializeApp({
    apiKey: "AIzaSyBiZGsWdvA9ESm3OsUpZ-VQpwqMjMpBY6g",
    authDomain: "freshwax-store.firebaseapp.com",
    projectId: "freshwax-store"
  });

  const auth = getAuth(app);
  // Expose auth globally for pusher module to get idToken
  window.firebaseAuth = auth;
  const db = getFirestore(app);
  
  let currentUser = null;
  let userInfo = null;
  let currentStream = null;
  let mySlot = null;
  let presenceRef = null;
  let streamStartTime = null;
  let streamEndTime = null;

  // HLS Player state
  let hlsPlayer = null;
  let isVideoPlaying = false;
  let currentHlsUrl = null; // Track current URL to avoid re-initializing

  // Takeover limiting - max 3 attempts per session
  let takeoverAttempts = 0;
  const MAX_TAKEOVER_ATTEMPTS = 3;
  let takeoverTimeout = null;
  let takeoverPending = false;
  
  // DM System
  let dmTargetDj = null;
  let dmMessages = [];
  let dmUnsubscribe = null;
  let onlineDjsCache = [];
  let authInitialized = false;
  
  // Auth timeout - if auth check takes too long, offer refresh
  let authTimeout = setTimeout(() => {
    if (!authInitialized) {
      console.log('[DJLobby] Auth timeout - no response after 8 seconds');
      const authGate = document.getElementById('authGate');
      if (authGate) {
        authGate.innerHTML = `
          <div class="auth-content">
            <div class="not-eligible-icon">‚è≥</div>
            <h2 style="margin: 1rem 0 0.5rem; color: #fff;">Taking too long?</h2>
            <p style="color: #aaa; margin-bottom: 1.5rem;">Authentication is taking longer than expected.</p>
            <button onclick="location.reload()" class="action-btn primary">Refresh Page</button>
            <a href="/live" class="action-btn secondary" style="margin-top: 0.75rem; display: inline-block;">Back to Live</a>
          </div>
        `;
      }
    }
  }, 8000);
  
  onAuthStateChanged(auth, async (user) => {
    authInitialized = true;
    clearTimeout(authTimeout);
    if (!user) {
      window.location.href = '/login?redirect=/account/dj-lobby';
      return;
    }
    currentUser = user;
    
    // Set a timeout for the access check itself
    const accessCheckTimeout = setTimeout(() => {
      console.log('[DJLobby] Access check timeout - no response after 15 seconds');
      const authGate = document.getElementById('authGate');
      if (authGate && !authGate.classList.contains('hidden')) {
        authGate.innerHTML = `
          <div class="auth-content">
            <div class="not-eligible-icon">‚ö†Ô∏è</div>
            <h2 style="margin: 1rem 0 0.5rem; color: #fff;">Connection Issue</h2>
            <p style="color: #aaa; margin-bottom: 1.5rem;">Unable to verify DJ access. Please check your connection and try again.</p>
            <button onclick="location.reload()" class="action-btn primary">Try Again</button>
            <a href="/live" class="action-btn secondary" style="margin-top: 0.75rem; display: inline-block;">Back to Live</a>
          </div>
        `;
      }
    }, 15000);
    
    await checkDjAccess(user.uid);
    clearTimeout(accessCheckTimeout);
  });
  
  async function checkDjAccess(userId) {
    try {
      console.log('[DJ Lobby] Checking access for:', userId);
      
      // Helper function with timeout
      const fetchWithTimeout = async (url, timeout = 10000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          return response;
        } catch (e) {
          clearTimeout(timeoutId);
          throw e;
        }
      };
      
      // Check user type first - pass email for admin check
      const userEmail = currentUser?.email ? encodeURIComponent(currentUser.email) : '';
      let response;
      try {
        response = await fetchWithTimeout(`/api/get-user-type?uid=${userId}&email=${userEmail}`);
      } catch (e) {
        console.error('[DJ Lobby] get-user-type fetch failed:', e);
        showAccessDenied();
        return;
      }
      
      if (!response.ok) {
        console.error('[DJ Lobby] get-user-type returned', response.status);
        showAccessDenied();
        return;
      }
      
      const result = await response.json();
      console.log('[DJ Lobby] User type result:', result);
      
      if (!result.success) { 
        console.error('[DJ Lobby] get-user-type failed:', result.error);
        showAccessDenied(); 
        return; 
      }
      
      const isAdmin = result.isAdmin === true;
      // Use Firebase Auth displayName (same as Header.astro) - this is the public name
      const displayName = currentUser.displayName || result.partnerDisplayName || result.name || 'DJ';
      
      userInfo = {
        id: userId,
        uid: userId,  // Also add uid for bypass request compatibility
        name: displayName,
        firstName: displayName.split(' ')[0] || 'D',
        avatar: result.avatarUrl || currentUser.photoURL || null,
        email: currentUser.email,
        isAdmin: isAdmin
      };
      
      console.log('[DJ Lobby] User info set:', { displayName, firebaseDisplayName: currentUser.displayName, apiPartnerDisplayName: result.partnerDisplayName, avatarUrl: result.avatarUrl, photoURL: currentUser.photoURL, finalAvatar: userInfo.avatar });
      
      // Check eligibility (must have mix with 10+ likes OR have bypass approval)
      console.log('[DJ Lobby] Checking eligibility...');
      let eligibilityResponse;
      try {
        eligibilityResponse = await fetchWithTimeout(`/api/check-dj-eligibility?userId=${userId}`);
      } catch (e) {
        console.error('[DJ Lobby] check-dj-eligibility fetch failed:', e);
        showNotEligible({ reason: 'error', message: 'Could not verify eligibility. Please try again.' });
        return;
      }
      
      if (!eligibilityResponse.ok) {
        console.error('[DJ Lobby] check-dj-eligibility returned', eligibilityResponse.status);
        showNotEligible({ reason: 'error', message: 'Could not verify eligibility. Please try again.' });
        return;
      }
      
      const eligibility = await eligibilityResponse.json();
      console.log('[DJ Lobby] Eligibility result:', eligibility);
      
      if (!eligibility.success) {
        console.error('[DJ Lobby] Eligibility check failed:', eligibility.error);
        showNotEligible({ reason: 'error', message: 'Could not verify eligibility. Please try again.' });
        return;
      }
      
      if (!eligibility.eligible && !isAdmin) {
        console.log('[DJ Lobby] User not eligible, showing requirements');
        showNotEligible(eligibility);
        return;
      }
      
      console.log('[DJ Lobby] Access granted, showing lobby');
      showLobby();
      initLobby();
    } catch (e) {
      console.error('[DJ Lobby] Access check failed:', e);
      showAccessDenied();
    }
  }
  
  function showNotEligible(eligibility) {
    document.getElementById('authGate').classList.add('hidden');
    document.getElementById('accessDenied').classList.add('hidden');
    document.getElementById('notEligible').classList.remove('hidden');
    
    const icon = document.querySelector('.not-eligible-icon');
    const title = document.querySelector('.not-eligible-content h1');
    const requirements = document.querySelector('.eligibility-requirements');
    const actions = document.querySelector('.eligibility-actions');
    const whySection = document.querySelector('.eligibility-why');
    
    // Handle banned status
    if (eligibility.reason === 'banned') {
      icon.textContent = 'üö´';
      title.innerHTML = 'ACCESS <span class="red">SUSPENDED</span>';
      document.getElementById('eligibilityMessage').textContent = eligibility.message || 'Your account has been suspended from streaming.';
      requirements.innerHTML = `
        <div class="banned-notice">
          <p>Your streaming privileges have been suspended.</p>
          ${eligibility.bannedReason ? `<p class="ban-reason">Reason: ${eligibility.bannedReason}</p>` : ''}
          <p class="contact-info">If you believe this is a mistake, please contact us.</p>
        </div>
      `;
      actions.innerHTML = `
        <a href="/contact" class="action-btn primary">Contact Support</a>
        <a href="/live" class="action-btn secondary">Back to Live</a>
      `;
      whySection.classList.add('hidden');
      document.getElementById('bypassRequestSection')?.classList.add('hidden');
      return;
    }
    
    // Handle on-hold status
    if (eligibility.reason === 'on_hold') {
      icon.textContent = '‚è∏Ô∏è';
      title.innerHTML = 'ON <span class="red">HOLD</span>';
      document.getElementById('eligibilityMessage').textContent = eligibility.message || 'Your streaming access is temporarily on hold.';
      requirements.innerHTML = `
        <div class="hold-notice">
          <p>Your streaming access is temporarily restricted.</p>
          ${eligibility.holdReason ? `<p class="hold-reason">Reason: ${eligibility.holdReason}</p>` : ''}
          <p class="contact-info">Please contact us if you have questions.</p>
        </div>
      `;
      actions.innerHTML = `
        <a href="/contact" class="action-btn primary">Contact Support</a>
        <a href="/live" class="action-btn secondary">Back to Live</a>
      `;
      whySection.classList.add('hidden');
      document.getElementById('bypassRequestSection')?.classList.add('hidden');
      return;
    }
    
    // Default eligibility check (mixes/likes)
    icon.textContent = 'üéß';
    title.innerHTML = 'ALMOST <span class="red">THERE</span>';
    document.getElementById('eligibilityMessage').textContent = eligibility.message || 'You need to build your reputation before accessing the DJ Lobby.';
    
    // Update requirements
    const reqMixes = document.getElementById('reqMixes');
    const reqLikes = document.getElementById('reqLikes');
    
    if (reqMixes && eligibility.mixCount > 0) {
      reqMixes.classList.add('met');
      reqMixes.querySelector('.req-icon').textContent = '‚úÖ';
    }
    
    if (reqLikes && eligibility.qualifyingMixes > 0) {
      reqLikes.classList.add('met');
      reqLikes.querySelector('.req-icon').textContent = '‚úÖ';
    }
    
    // Always show progress - update values (defaults to 0 if not available)
    const bestLikes = eligibility.bestMixLikes || 0;
    const requiredLikes = eligibility.requiredLikes || 10;
    document.getElementById('bestMixLikes').textContent = bestLikes;
    const progress = Math.min(100, (bestLikes / requiredLikes) * 100);
    document.getElementById('likesProgress').style.width = progress + '%';
    
    whySection.classList.remove('hidden');
    
    // Check and show bypass request status
    checkBypassStatus(eligibility);
    startBypassPolling();
  }
  
  // ==========================================
  // BYPASS REQUEST FUNCTIONALITY
  // ==========================================
  
  let currentBypassStatus = null;
  let bypassPollInterval = null;
  
  async function checkBypassStatus(eligibility) {
    if (!userInfo?.uid) return;
    
    try {
      const response = await fetch(`/api/admin/bypass-requests?action=status&userId=${userInfo.uid}`);
      const result = await response.json();
      
      if (result.success) {
        currentBypassStatus = { ...result, ...eligibility };
        updateBypassUI(result);
      }
    } catch (error) {
      console.error('[Bypass] Error checking status:', error);
    }
  }
  
  function updateBypassUI(status) {
    const form = document.getElementById('bypassRequestForm');
    const pending = document.getElementById('bypassPending');
    const approved = document.getElementById('bypassApproved');
    const denied = document.getElementById('bypassDenied');
    
    form?.classList.add('hidden');
    pending?.classList.add('hidden');
    approved?.classList.add('hidden');
    denied?.classList.add('hidden');
    
    if (!status.hasRequest) {
      form?.classList.remove('hidden');
    } else if (status.request?.status === 'pending') {
      pending?.classList.remove('hidden');
    } else if (status.request?.status === 'approved') {
      approved?.classList.remove('hidden');
    } else if (status.request?.status === 'denied') {
      denied?.classList.remove('hidden');
      if (status.request?.denialReason) {
        const reasonEl = document.getElementById('bypassDenialReason');
        if (reasonEl) reasonEl.textContent = `Your request was not approved: ${status.request.denialReason}`;
      }
    }
  }
  
  function startBypassPolling() {
    if (bypassPollInterval) return;
    bypassPollInterval = setInterval(async () => {
      if (currentBypassStatus?.request?.status === 'pending') {
        await checkBypassStatus(currentBypassStatus);
        if (currentBypassStatus?.request?.status === 'approved') {
          stopBypassPolling();
        }
      }
    }, 30000);
  }
  
  function stopBypassPolling() {
    if (bypassPollInterval) {
      clearInterval(bypassPollInterval);
      bypassPollInterval = null;
    }
  }
  
  // Submit bypass request
  document.getElementById('submitBypassRequest')?.addEventListener('click', async () => {
    const btn = document.getElementById('submitBypassRequest');
    const reason = document.getElementById('bypassReason')?.value?.trim() || '';
    
    if (!userInfo?.uid) {
      alert('Please sign in first');
      return;
    }
    
    btn.disabled = true;
    btn.textContent = 'Submitting...';
    
    try {
      const response = await fetch('/api/admin/bypass-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'request',
          userId: userInfo.uid,
          djName: userInfo.name || userInfo.email?.split('@')[0],
          email: userInfo.email,
          reason: reason || null,
          mixCount: currentBypassStatus?.mixCount || 0,
          bestMixLikes: currentBypassStatus?.bestMixLikes || 0
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        await checkBypassStatus(currentBypassStatus || {});
      } else {
        alert(result.error || 'Failed to submit request');
        btn.disabled = false;
        btn.textContent = 'üé´ Request Bypass Access';
      }
    } catch (error) {
      console.error('[Bypass] Submit error:', error);
      alert('Failed to submit request. Please try again.');
      btn.disabled = false;
      btn.textContent = 'üé´ Request Bypass Access';
    }
  });
  
  // Cancel bypass request
  document.getElementById('cancelBypassRequest')?.addEventListener('click', async () => {
    if (!confirm('Cancel your bypass request?')) return;
    
    try {
      const response = await fetch('/api/admin/bypass-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancel',
          userId: userInfo.uid,
          adminKey: 'fresh-wax-admin-2024'
        })
      });
      
      const result = await response.json();
      if (result.success) {
        await checkBypassStatus(currentBypassStatus || {});
      } else {
        alert(result.error || 'Failed to cancel request');
      }
    } catch (error) {
      console.error('[Bypass] Cancel error:', error);
    }
  });
  
  // Continue with bypass (after approval)
  document.getElementById('continueWithBypass')?.addEventListener('click', () => {
    location.reload();
  });
  
  // Resubmit after denial
  document.getElementById('resubmitBypassRequest')?.addEventListener('click', async () => {
    try {
      await fetch('/api/admin/bypass-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'cancel',
          userId: userInfo.uid,
          adminKey: 'fresh-wax-admin-2024'
        })
      });
      await checkBypassStatus(currentBypassStatus || {});
    } catch (error) {
      console.error('[Bypass] Resubmit error:', error);
    }
  });

  // Quick Access Code Redemption
  document.getElementById('redeemAccessCodeBtn')?.addEventListener('click', async () => {
    const codeInput = document.getElementById('quickAccessCodeInput');
    const btn = document.getElementById('redeemAccessCodeBtn');
    const errorEl = document.getElementById('quickAccessError');
    const successEl = document.getElementById('quickAccessSuccess');
    const btnText = btn?.querySelector('.btn-text');
    const btnSpinner = btn?.querySelector('.btn-spinner');

    const code = codeInput?.value?.trim();
    if (!code) {
      errorEl.textContent = 'Please enter an access code';
      errorEl.classList.remove('hidden');
      successEl.classList.add('hidden');
      return;
    }

    // Show loading state
    btn.disabled = true;
    btnText?.classList.add('hidden');
    btnSpinner?.classList.remove('hidden');
    errorEl.classList.add('hidden');
    successEl.classList.add('hidden');

    try {
      const response = await fetch('/api/redeem-access-key', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          code: code,
          userId: userInfo.uid,
          userEmail: userInfo.email,
          userName: userInfo.name
        })
      });

      const result = await response.json();

      if (result.success) {
        successEl.textContent = result.message || 'Access granted! Redirecting to lobby...';
        successEl.classList.remove('hidden');
        errorEl.classList.add('hidden');

        // Brief delay then reload to show lobby
        setTimeout(() => {
          window.location.reload();
        }, 1500);
      } else {
        errorEl.textContent = result.error || 'Invalid access code';
        errorEl.classList.remove('hidden');
        successEl.classList.add('hidden');

        // Reset button
        btn.disabled = false;
        btnText?.classList.remove('hidden');
        btnSpinner?.classList.add('hidden');
      }
    } catch (error) {
      console.error('[QuickAccess] Redeem error:', error);
      errorEl.textContent = 'Failed to redeem code. Please try again.';
      errorEl.classList.remove('hidden');
      successEl.classList.add('hidden');

      // Reset button
      btn.disabled = false;
      btnText?.classList.remove('hidden');
      btnSpinner?.classList.add('hidden');
    }
  });

  // Allow Enter key to submit the quick access code
  document.getElementById('quickAccessCodeInput')?.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      document.getElementById('redeemAccessCodeBtn')?.click();
    }
  });

  function showAccessDenied() {
    document.getElementById('authGate').classList.add('hidden');
    document.getElementById('accessDenied').classList.remove('hidden');
  }
  
  function showLobby() {
    document.getElementById('authGate').classList.add('hidden');
    document.getElementById('mainLobby').classList.remove('hidden');
    
    // Populate header with user info
    document.getElementById('headerName').textContent = userInfo.name;
    
    // Handle avatar with letter fallback
    const avatarImg = document.getElementById('headerAvatar');
    const avatarLetter = document.getElementById('headerAvatarLetter');
    
    if (userInfo.avatar && userInfo.avatar !== '/place-holder.webp') {
      // Try to load the image
      avatarImg.onload = () => {
        avatarImg.classList.remove('hidden');
        avatarLetter.classList.add('hidden');
      };
      avatarImg.onerror = () => {
        // Image failed, show letter
        avatarImg.classList.add('hidden');
        avatarLetter.classList.remove('hidden');
        avatarLetter.textContent = getAvatarLetter(userInfo.name, userInfo.firstName);
      };
      avatarImg.src = userInfo.avatar;
    } else {
      // No avatar URL, show letter
      avatarImg.classList.add('hidden');
      avatarLetter.classList.remove('hidden');
      avatarLetter.textContent = getAvatarLetter(userInfo.name, userInfo.firstName);
    }
  }
  
  function getAvatarLetter(displayName, firstName) {
    // Try display name first, then firstName
    const name = displayName || firstName || 'D';
    return name.charAt(0).toUpperCase();
  }
  
  async function initLobby() {
    // Load initial data from API
    await loadStreamStatus();
    await checkAndCleanupChat();
    await loadMySlot();
    
    // Initialize Pusher-based real-time features (replaces Firebase onSnapshot)
    // This handles: presence, chat, takeover, DMs
    await initDjLobbyPusher(currentUser, userInfo);
    
    // Setup UI event listeners
    setupEventListeners();
    
    // Polling for non-realtime data
    setInterval(loadStreamStatus, 10000);
    setInterval(updateTimeRemaining, 1000);
    setInterval(checkStreamKeyAvailability, 30000);
  }
  
  // Page cleanup - called when leaving
  function setupPageCleanup() {
    window.addEventListener('beforeunload', async () => {
      try {
        await cleanupPusher();
      } catch(e) {
        console.error('Cleanup error:', e);
      }
    });
  }
  
  // Call setup after initLobby
  setupPageCleanup();
  
  // Check if chat should be cleaned up (2 hours since last stream ended and no one is live)
  async function checkAndCleanupChat() {
    try {
      // Get chat settings doc - this may fail due to permissions, that's ok
      const settingsRef = doc(db, 'djLobbySettings', 'chatCleanup');
      const settingsSnap = await getDoc(settingsRef);
      
      if (!settingsSnap.exists()) return; // No settings, skip cleanup
      
      const settings = settingsSnap.data();
      const lastStreamEndTime = settings.lastStreamEndTime?.toMillis() || 0;
      const now = Date.now();
      const twoHoursMs = 2 * 60 * 60 * 1000; // 2 hours in milliseconds
      
      // If no one is currently streaming AND 2 hours have passed since last stream ended
      if (!currentStream && lastStreamEndTime > 0 && (now - lastStreamEndTime) > twoHoursMs) {
        console.log('Chat cleanup: 2+ hours since last stream, clearing chat history...');
        
        // Delete all DJ lobby chat messages
        const chatSnapshot = await getDocs(collection(db, 'djLobbyChat'));
        const deletePromises = [];
        chatSnapshot.forEach(document => {
          deletePromises.push(deleteDoc(doc(db, 'djLobbyChat', document.id)));
        });
        await Promise.all(deletePromises);
        
        // Reset the lastStreamEndTime so we don't keep deleting
        await setDoc(settingsRef, { 
          lastStreamEndTime: null,
          lastCleanup: serverTimestamp()
        }, { merge: true });
        
        console.log('Chat cleanup complete');
      }
    } catch (e) {
      // Permissions error is expected if rules don't allow reading djLobbySettings
      // This is non-critical, just skip cleanup silently
      if (e.code !== 'permission-denied') {
        console.warn('Chat cleanup skipped:', e.message);
      }
    }
  }
  
  // Call this when a stream ends to record the time
  async function recordStreamEnd() {
    try {
      const settingsRef = doc(db, 'djLobbySettings', 'chatCleanup');
      await setDoc(settingsRef, { 
        lastStreamEndTime: serverTimestamp()
      }, { merge: true });
    } catch (e) {
      console.error('Record stream end error:', e);
    }
  }
  
  // REPLACED BY PUSHER MODULE - presence events now handled via Pusher channel
  // function subscribeToOnlineDjs() { ... }
  
  function updateOnlineDjsList(djs) {
    document.getElementById('onlineDjCount').textContent = djs.length;
    
    const list = document.getElementById('djsList');
    if (djs.length === 0) {
      list.innerHTML = '<p class="empty-state">No DJs online yet</p>';
      return;
    }
    
    list.innerHTML = djs.map(dj => {
      const isLive = currentStream && currentStream.djId === dj.odamiMa;
      const isMe = dj.odamiMa === currentUser?.uid;
      const isReady = dj.isReady === true;
      const avatarLetter = dj.avatarLetter || (dj.name ? dj.name.charAt(0).toUpperCase() : 'D');
      const hasAvatar = dj.avatar && dj.avatar !== '/place-holder.webp';
      
      return `
        <div class="dj-item ${isLive ? 'is-live' : ''} ${isReady && !isLive ? 'is-ready' : ''}">
          ${hasAvatar 
            ? `<img src="${dj.avatar}" alt="" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="dj-avatar-letter" style="display:none;">${avatarLetter}</span>`
            : `<span class="dj-avatar-letter">${avatarLetter}</span>`
          }
          <span>${dj.name}${isMe ? ' (you)' : ''}</span>
        </div>
      `;
    }).join('');
  }

  // Setup HLS player for video streams
  function setupHlsPlayer(stream) {
    const videoElement = document.getElementById('hlsVideo');
    // Use hlsUrl (from status API) or fall back to videoStreamUrl/streamUrl
    const hlsUrl = stream?.hlsUrl || stream?.videoStreamUrl || stream?.streamUrl;

    if (!videoElement || !hlsUrl) {
      console.log('[HLS] No video element or stream URL. Stream:', stream);
      return;
    }

    // If same stream URL and player exists, check if actually playing
    if (currentHlsUrl === hlsUrl && hlsPlayer) {
      // Only skip if actually playing, otherwise try to play
      if (!videoElement.paused && isVideoPlaying) {
        console.log('[HLS] Already playing this stream, skipping re-init');
        return;
      }
      // Not playing yet, try to play
      console.log('[HLS] Same stream but not playing, attempting to play...');
      videoElement.play().catch(e => {
        console.log('[HLS] Auto-play blocked, user interaction required:', e.message);
      });
      return;
    }

    console.log('[HLS] Setting up player for:', hlsUrl);
    currentHlsUrl = hlsUrl;

    // Clean up existing player
    if (hlsPlayer) {
      console.log('[HLS] Destroying existing player');
      hlsPlayer.destroy();
      hlsPlayer = null;
    }

    const nativeHlsSupport = videoElement.canPlayType('application/vnd.apple.mpegurl');

    // Only use native HLS if "probably" - "maybe" means browser might not actually support it
    if (nativeHlsSupport === 'probably') {
      console.log('[HLS] Using native HLS support');
      videoElement.src = hlsUrl;
      // Auto-play for native HLS
      videoElement.play().catch(e => {
        console.log('[HLS] Auto-play blocked (native), user interaction required:', e.message);
      });
    } else if (window.Hls && Hls.isSupported()) {
      console.log('[HLS] Using HLS.js library');
      hlsPlayer = new Hls({
        enableWorker: true,
        lowLatencyMode: true,
        backBufferLength: 90,
        maxBufferLength: 30,
        maxMaxBufferLength: 60
      });

      hlsPlayer.loadSource(hlsUrl);
      hlsPlayer.attachMedia(videoElement);

      hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
        console.log('[HLS] Manifest parsed, auto-playing...');
        // Auto-play when manifest is ready
        videoElement.play().catch(e => {
          console.log('[HLS] Auto-play blocked, user interaction required:', e.message);
        });
      });

      hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
        console.error('[HLS] Error:', data.type, data.details);
        if (data.fatal) {
          if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
            console.log('[HLS] Network error, will retry...');
            setTimeout(() => {
              if (hlsPlayer) {
                hlsPlayer.loadSource(hlsUrl);
              }
            }, 3000);
          } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
            console.log('[HLS] Media error, recovering...');
            hlsPlayer.recoverMediaError();
          }
        }
      });
    } else {
      console.error('[HLS] Not supported');
    }

    // Sync video events with UI
    videoElement.addEventListener('play', () => {
      isVideoPlaying = true;
      document.getElementById('playIcon')?.classList.add('hidden');
      document.getElementById('pauseIcon')?.classList.remove('hidden');
    });

    videoElement.addEventListener('pause', () => {
      isVideoPlaying = false;
      document.getElementById('playIcon')?.classList.remove('hidden');
      document.getElementById('pauseIcon')?.classList.add('hidden');
    });
  }

  // Cleanup HLS player
  function cleanupHlsPlayer() {
    if (hlsPlayer) {
      hlsPlayer.destroy();
      hlsPlayer = null;
    }
    isVideoPlaying = false;
    currentHlsUrl = null;
    const videoElement = document.getElementById('hlsVideo');
    if (videoElement) {
      videoElement.src = '';
    }
  }

  async function loadStreamStatus() {
    try {
      // Add cache buster to prevent stale cached responses
      const cacheBuster = Date.now();
      const response = await fetch(`/api/livestream/status?_t=${cacheBuster}`);
      const result = await response.json();
      
      const statusDot = document.querySelector('.status-dot');
      const statusText = document.getElementById('statusText');
      const offlineState = document.getElementById('offlineState');
      const videoPreview = document.getElementById('videoPreview');
      const audioPreview = document.getElementById('audioPreview');
      const timeRemaining = document.getElementById('timeRemaining');
      const takeoverRequest = document.getElementById('takeoverRequest');
      const noStreamTakeover = document.getElementById('noStreamTakeover');

      if (result.success && result.isLive && result.primaryStream) {
        currentStream = result.primaryStream;

        statusDot.classList.remove('offline');
        statusDot.classList.add('live');
        statusText.textContent = `${currentStream.djName} is LIVE`;

        offlineState.classList.add('hidden');
        timeRemaining.classList.remove('hidden');

        // Parse stream times
        if (currentStream.startedAt) {
          streamStartTime = new Date(currentStream.startedAt);
        }
        if (currentStream.endTime) {
          streamEndTime = new Date(currentStream.endTime);
        } else if (currentStream.duration) {
          streamEndTime = new Date(streamStartTime.getTime() + currentStream.duration * 60000);
        }

        document.getElementById('currentDjName').textContent = currentStream.djName || 'DJ';
        document.getElementById('currentStreamTitle').textContent = currentStream.title || 'Live Stream';
        if (currentStream.djAvatar) {
          document.getElementById('currentDjAvatar').src = currentStream.djAvatar;
        }

        // Check if this is a video stream (HLS/Red5) or audio-only (Icecast)
        const isVideoStream = currentStream.hlsUrl || currentStream.streamSource === 'red5' ||
                             (currentStream.streamType !== 'audio' && !currentStream.audioStreamUrl?.includes('8000'));

        if (isVideoStream) {
          videoPreview.classList.remove('hidden');
          audioPreview.classList.add('hidden');
          // Setup HLS video player (includes auto-play)
          setupHlsPlayer(currentStream);
        } else {
          audioPreview.classList.remove('hidden');
          videoPreview.classList.add('hidden');
          cleanupHlsPlayer();
          if (currentStream.djAvatar) document.getElementById('streamCover').src = currentStream.djAvatar;
          // Setup audio stream with auto-play
          const audioEl = document.getElementById('audioElement');
          const audioUrl = currentStream.audioStreamUrl || currentStream.streamUrl;
          if (audioEl && audioUrl) {
            audioEl.src = audioUrl;
            audioEl.play().catch(e => {
              console.log('[Audio] Auto-play blocked, user interaction required:', e.message);
            });
          }
        }

        // Handle takeover UI and End Stream button based on who is streaming
        if (currentStream.djId === currentUser?.uid) {
          takeoverRequest.classList.add('hidden');
          noStreamTakeover.classList.add('hidden');
          // Enable End Stream button for current streamer
          updateEndStreamButton(true, true);
        } else {
          takeoverRequest.classList.remove('hidden');
          noStreamTakeover.classList.add('hidden');
          document.getElementById('takeoverFromName').textContent = currentStream.djName || 'current DJ';
          // Disable End Stream button - not your stream (unless admin)
          updateEndStreamButton(true, false);
        }

        // Hide Go Live setup section when someone is streaming (gives more space to video)
        document.getElementById('streamKeySection')?.classList.add('hidden');

        // Check for relay chat
        updateRelayChatSection(currentStream);
      } else {
        currentStream = null;
        streamStartTime = null;
        streamEndTime = null;
        statusDot.classList.add('offline');
        statusDot.classList.remove('live');
        statusText.textContent = 'No one streaming';
        offlineState.classList.remove('hidden');
        videoPreview.classList.add('hidden');
        audioPreview.classList.add('hidden');
        timeRemaining.classList.add('hidden');
        takeoverRequest.classList.add('hidden');
        noStreamTakeover.classList.remove('hidden');

        // Cleanup HLS player when stream ends
        cleanupHlsPlayer();

        document.getElementById('currentDjName').textContent = '-';
        document.getElementById('currentStreamTitle').textContent = 'No stream';
        document.getElementById('currentDjAvatar').src = '/place-holder.webp';

        // Disable End Stream button - no active stream
        updateEndStreamButton(false, false);

        // Show Go Live setup section when no one is streaming
        document.getElementById('streamKeySection')?.classList.remove('hidden');

        // Hide relay chat when no stream
        updateRelayChatSection(null);
      }
    } catch (e) {
      console.error('Stream status error:', e);
    }
  }

  // Fetch and display stream viewers (users on live page)
  async function loadStreamViewers() {
    try {
      const viewersList = document.getElementById('viewersList');
      const viewerCount = document.getElementById('viewerCount');

      // Need a current stream to show viewers
      if (!currentStream || !currentStream.id) {
        viewerCount.textContent = '0';
        viewerCount.style.background = '#6b7280';
        viewersList.innerHTML = '<p class="no-viewers-msg">No active stream</p>';
        return;
      }

      const response = await fetch(`/api/livestream/listeners?streamId=${currentStream.id}`);
      const result = await response.json();

      if (result.success && result.listeners && result.listeners.length > 0) {
        const listeners = result.listeners;
        viewerCount.textContent = listeners.length;
        viewerCount.style.background = '#22c55e';

        viewersList.innerHTML = listeners.map(listener => `
          <div class="viewer-item">
            <img class="viewer-avatar" src="${listener.avatarUrl || '/place-holder.webp'}" alt="" onerror="this.src='/place-holder.webp'" />
            <span class="viewer-name">${listener.name || 'Viewer'}</span>
          </div>
        `).join('');
      } else {
        viewerCount.textContent = '0';
        viewerCount.style.background = '#6b7280';
        viewersList.innerHTML = '<p class="no-viewers-msg">No viewers yet</p>';
      }
    } catch (e) {
      console.error('Failed to load viewers:', e);
    }
  }

  // Load viewers initially and on interval
  loadStreamViewers();
  setInterval(loadStreamViewers, 15000);

  // Relay Chat Helper - shows chat from relay source (Twitch, YouTube, etc.)
  function updateRelayChatSection(stream) {
    const section = document.getElementById('relayChatSection');
    const frame = document.getElementById('relayChatFrame');
    const unsupported = document.getElementById('relayChatUnsupported');
    const sourceName = document.getElementById('relayChatSourceName');
    const externalLink = document.getElementById('relayChatExternalLink');

    // Hide if no stream or not a relay
    if (!stream || !stream.relayUrl) {
      section?.classList.add('hidden');
      if (frame) frame.src = '';
      return;
    }

    const relayUrl = stream.relayUrl;
    const chatEmbed = getRelayChatEmbed(relayUrl);

    if (chatEmbed) {
      section?.classList.remove('hidden');
      sourceName.textContent = chatEmbed.name + ' Chat';
      frame.src = chatEmbed.embedUrl;
      frame.classList.remove('hidden');
      unsupported?.classList.add('hidden');
    } else {
      // Show unsupported message with link to original
      section?.classList.remove('hidden');
      sourceName.textContent = 'Source Chat';
      frame.src = '';
      frame.classList.add('hidden');
      unsupported?.classList.remove('hidden');
      externalLink.href = relayUrl;
    }
  }

  function getRelayChatEmbed(url) {
    const host = window.location.hostname;

    // Twitch
    const twitchMatch = url.match(/twitch\.tv\/([^\/\?]+)/i);
    if (twitchMatch) {
      const channel = twitchMatch[1];
      return {
        name: 'Twitch',
        embedUrl: `https://www.twitch.tv/embed/${channel}/chat?parent=${host}&darkpopout`
      };
    }

    // YouTube Live (multiple URL formats)
    const ytVideoMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\/\?]+)/i);
    const ytLiveMatch = url.match(/youtube\.com\/live\/([^\/\?]+)/i);
    const ytChannelMatch = url.match(/youtube\.com\/(?:channel|c)\/([^\/\?]+)/i);

    if (ytVideoMatch || ytLiveMatch) {
      const videoId = ytVideoMatch ? ytVideoMatch[1] : ytLiveMatch[1];
      return {
        name: 'YouTube',
        embedUrl: `https://www.youtube.com/live_chat?v=${videoId}&embed_domain=${host}`
      };
    }

    // Kick.com
    const kickMatch = url.match(/kick\.com\/([^\/\?]+)/i);
    if (kickMatch) {
      const channel = kickMatch[1];
      return {
        name: 'Kick',
        embedUrl: `https://kick.com/${channel}/chatroom`
      };
    }

    // No supported embed found
    return null;
  }

  // Toggle relay chat visibility
  document.getElementById('toggleRelayChatBtn')?.addEventListener('click', () => {
    const container = document.getElementById('relayChatContainer');
    const btn = document.getElementById('toggleRelayChatBtn');
    if (container?.classList.toggle('collapsed')) {
      btn.textContent = '+';
    } else {
      btn.textContent = '‚àí';
    }
  });
  
  function updateTimeRemaining() {
    const timeLeft = document.getElementById('timeLeft');
    
    if (!streamEndTime) {
      timeLeft.textContent = '--:--';
      return;
    }
    
    const now = new Date();
    const diff = streamEndTime - now;
    
    if (diff <= 0) {
      timeLeft.textContent = '00:00';
      timeLeft.style.color = '#dc2626';
      return;
    }
    
    const mins = Math.floor(diff / 60000);
    const secs = Math.floor((diff % 60000) / 1000);
    timeLeft.textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    
    if (mins < 5) {
      timeLeft.style.color = '#dc2626';
    } else {
      timeLeft.style.color = '#fff';
    }
  }
  
  async function loadMySlot() {
    try {
      const now = new Date();
      const end = new Date(now.getTime() + 24 * 60 * 60 * 1000);
      
      const response = await fetch(`/api/livestream/slots?start=${now.toISOString()}&end=${end.toISOString()}&djId=${currentUser.uid}`);
      const result = await response.json();
      
      if (result.success && result.slots && result.slots.length > 0) {
        // Sort by startTime to get the earliest upcoming slot
        const sortedSlots = result.slots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
        mySlot = sortedSlots[0];
        checkStreamKeyAvailability();
      } else {
        mySlot = null;
        showKeyNotAvailable();
      }
    } catch (e) {
      console.error('Load slot error:', e);
    }
  }
  
  // Format duration in days, hours, minutes
  function formatDuration(totalMinutes) {
    if (totalMinutes <= 0) return '0 minutes';
    
    const days = Math.floor(totalMinutes / 1440);
    const hours = Math.floor((totalMinutes % 1440) / 60);
    const mins = totalMinutes % 60;
    
    const parts = [];
    if (days > 0) parts.push(`${days} day${days !== 1 ? 's' : ''}`);
    if (hours > 0) parts.push(`${hours} hour${hours !== 1 ? 's' : ''}`);
    if (mins > 0 || parts.length === 0) parts.push(`${mins} minute${mins !== 1 ? 's' : ''}`);
    
    return parts.join(', ');
  }
  
  function checkStreamKeyAvailability() {
    const keyStatus = document.getElementById('keyStatus');
    const slotTimeDisplay = document.getElementById('slotTimeDisplay');
    const countdownEl = document.getElementById('countdownToSlot');
    const streamKeyEl = document.getElementById('myStreamKey');

    // If user has a booked slot, show slot info
    if (mySlot) {
      const now = new Date();
      const slotStart = new Date(mySlot.startTime);
      const slotEnd = new Date(mySlot.endTime);

      if (slotTimeDisplay) {
        slotTimeDisplay.textContent =
          `Your slot: ${slotStart.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })} - ${slotEnd.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })}`;
      }

      const minsUntil = Math.ceil((slotStart - now) / 60000);
      if (countdownEl) {
        if (minsUntil > 0) {
          countdownEl.textContent = `Starts in ${formatDuration(minsUntil)}`;
        } else if (now < slotEnd) {
          countdownEl.textContent = `Your slot is NOW!`;
        } else {
          countdownEl.textContent = '';
        }
      }

      // If slot has a stream key, use it
      if (mySlot.streamKey) {
        if (streamKeyEl) streamKeyEl.textContent = mySlot.streamKey;
        currentStreamKey = mySlot.streamKey;
      }
    } else {
      if (slotTimeDisplay) slotTimeDisplay.textContent = 'Your slot: --:-- - --:--';
      if (countdownEl) countdownEl.textContent = '';
    }

    // Always generate a stream key if we don't have one
    if (!currentStreamKey) {
      loadStreamKeyForGoLive();
    } else {
      // Display existing key
      if (streamKeyEl) streamKeyEl.textContent = currentStreamKey;
    }

    if (keyStatus) {
      keyStatus.textContent = 'Ready';
      keyStatus.className = 'key-status ready';
    }
  }
  
  async function fetchStreamKey() {
    try {
      const token = await currentUser.getIdToken();
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify({ action: 'getStreamKey', slotId: mySlot.id, djId: currentUser.uid })
      });
      
      const result = await response.json();
      if (result.success && result.streamKey) {
        document.getElementById('myStreamKey').textContent = result.streamKey;
        mySlot.streamKey = result.streamKey;
      }
    } catch (e) {
      console.error('Fetch key error:', e);
    }
  }
  
  // REPLACED BY PUSHER MODULE - takeover events now handled via private Pusher channel
  // function subscribeToTakeover() { ... }
  
  function showIncomingTakeover(data) {
    const div = document.getElementById('incomingTakeover');
    document.getElementById('incomingDjName').textContent = data.requesterName || 'A DJ';
    document.getElementById('incomingDjAvatar').src = data.requesterAvatar || '/place-holder.webp';
    div.classList.remove('hidden');
    div.dataset.requesterId = data.requesterId;
  }
  
  function hideIncomingTakeover() {
    document.getElementById('incomingTakeover').classList.add('hidden');
  }
  
  function showTakeoverApproved(data) {
    const div = document.getElementById('takeoverApproved');
    document.getElementById('takeoverServerUrl').textContent = data.serverUrl || 'rtmp://rtmp.freshwax.co.uk/live';
    document.getElementById('takeoverStreamKey').textContent = data.streamKey || '-';
    div.classList.remove('hidden');
    document.getElementById('takeoverRequest').classList.add('hidden');
    document.getElementById('noStreamTakeover').classList.add('hidden');
  }
  
  // REPLACED BY PUSHER MODULE - chat messages now handled via Pusher channel
  // function subscribeToChat() { ... }
  
  function renderMessages(messages) {
    const container = document.getElementById('chatMessages');
    
    if (messages.length === 0) {
      container.innerHTML = `
        <div class="chat-welcome">
          <p>Welcome to the DJ Lobby! üëã</p>
          <p class="hint">Chat with other DJs, coordinate sets, and hang out.</p>
        </div>
      `;
      return;
    }
    
    container.innerHTML = messages.map(msg => {
      const time = msg.createdAt?.toDate ? 
        msg.createdAt.toDate().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : '';
      
      return `
        <div class="chat-message">
          <div class="chat-message-content">
            <div class="chat-message-header">
              <span class="chat-message-name">${escapeHtml(msg.name || 'DJ')}</span>
              <span class="chat-message-time">${time}</span>
            </div>
            <div class="chat-message-text">${escapeHtml(msg.text)}</div>
          </div>
        </div>
      `;
    }).join('');
    
    container.scrollTop = container.scrollHeight;
  }
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // ============================================
  // DM SYSTEM
  // ============================================
  
  function getDmChannelId(uid1, uid2) {
    // Create consistent channel ID regardless of who initiates
    return [uid1, uid2].sort().join('_');
  }
  
  function openDmModal() {
    document.getElementById('dmModal').classList.remove('hidden');
    document.getElementById('dmSelectView').classList.remove('hidden');
    document.getElementById('dmChatView').classList.add('hidden');
    populateDmDjList();
  }
  
  function closeDmModal() {
    document.getElementById('dmModal').classList.add('hidden');
    
    // Clean up DM messages from Firestore
    if (dmTargetDj && currentUser) {
      cleanupDmMessages();
    }
    
    // Unsubscribe from DM listener
    if (dmUnsubscribe) {
      dmUnsubscribe();
      dmUnsubscribe = null;
    }
    
    // Reset state
    dmTargetDj = null;
    dmMessages = [];
    document.getElementById('dmMessages').innerHTML = `
      <div class="dm-welcome">
        <p>Start a private conversation</p>
        <p class="hint">Only you and this DJ can see these messages.</p>
      </div>
    `;
  }
  
  function populateDmDjList() {
    const list = document.getElementById('dmDjList');
    const otherDjs = onlineDjsCache.filter(dj => dj.odamiMa !== currentUser?.uid);
    
    if (otherDjs.length === 0) {
      list.innerHTML = '<p class="empty-state">No other DJs online</p>';
      return;
    }
    
    list.innerHTML = otherDjs.map(dj => {
      const avatarLetter = dj.avatarLetter || (dj.name ? dj.name.charAt(0).toUpperCase() : 'D');
      const hasAvatar = dj.avatar && dj.avatar !== '/place-holder.webp';
      const isLive = currentStream && currentStream.djId === dj.odamiMa;
      
      return `
        <div class="dm-dj-item" data-dj-id="${dj.odamiMa}" data-dj-name="${escapeHtml(dj.name || 'DJ')}" data-dj-avatar="${dj.avatar || ''}" data-dj-letter="${avatarLetter}">
          ${hasAvatar 
            ? `<img src="${dj.avatar}" alt="" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="dm-dj-avatar-letter" style="display:none;">${avatarLetter}</span>`
            : `<span class="dm-dj-avatar-letter">${avatarLetter}</span>`
          }
          <div class="dm-dj-info">
            <div class="dm-dj-name">${escapeHtml(dj.name || 'DJ')}</div>
            <div class="dm-dj-status">${isLive ? 'üî¥ Live now' : 'Online'}</div>
          </div>
        </div>
      `;
    }).join('');
    
    // Add click handlers
    list.querySelectorAll('.dm-dj-item').forEach(item => {
      item.addEventListener('click', () => {
        const djId = item.dataset.djId;
        const djName = item.dataset.djName;
        const djAvatar = item.dataset.djAvatar;
        const djLetter = item.dataset.djLetter;
        selectDmTarget(djId, djName, djAvatar, djLetter);
      });
    });
  }
  
  function selectDmTarget(djId, djName, djAvatar, djLetter) {
    // Use Pusher module to handle DM conversation
    openDmConversation({ id: djId, name: djName, avatar: djAvatar, letter: djLetter });
    
    // Update local reference for UI
    dmTargetDj = { id: djId, name: djName, avatar: djAvatar, letter: djLetter };
    
    // Switch to chat view
    document.getElementById('dmSelectView').classList.add('hidden');
    document.getElementById('dmChatView').classList.remove('hidden');
    document.getElementById('dmChatWithName').textContent = djName;
  }
  
  function goBackToDmList() {
    // Use Pusher module to close DM
    closeDmModal();
    
    dmTargetDj = null;
    
    // Switch to selection view
    document.getElementById('dmChatView').classList.add('hidden');
    document.getElementById('dmSelectView').classList.remove('hidden');
    populateDmDjList();
  }
  
  // REPLACED BY PUSHER MODULE - DM messages now handled via Pusher channel
  // function subscribeToDmChannel() { ... }
  
  // REPLACED BY PUSHER MODULE - DM rendering now handled by dj-lobby-pusher.js
  // function renderDmMessages() { ... }
  
  function renderDmMessages() {
    const container = document.getElementById('dmMessages');
    
    if (dmMessages.length === 0) {
      container.innerHTML = `
        <div class="dm-welcome">
          <p>Start a private conversation</p>
          <p class="hint">Only you and this DJ can see these messages.</p>
        </div>
      `;
      return;
    }
    
    container.innerHTML = dmMessages.map(msg => {
      const isSent = msg.senderId === currentUser?.uid;
      const time = msg.createdAt?.toDate ? 
        msg.createdAt.toDate().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : '';
      
      return `
        <div class="dm-message ${isSent ? 'sent' : ''}">
          <div class="dm-message-content">
            <div class="dm-message-name">${isSent ? 'You' : escapeHtml(msg.senderName || 'DJ')}</div>
            <div class="dm-message-text">${escapeHtml(msg.text)}</div>
            <div class="dm-message-time">${time}</div>
          </div>
        </div>
      `;
    }).join('');
    
    container.scrollTop = container.scrollHeight;
  }
  
  async function sendDmMessage() {
    const input = document.getElementById('dmInput');
    const text = input.value.trim();
    if (!text) return;
    
    input.value = '';
    
    try {
      // Use Pusher module to send DM (handles API + Pusher broadcast)
      await sendDm(text);
    } catch (e) {
      console.error('DM send error:', e);
      input.value = text;
    }
  }
  
  async function cleanupDmMessages() {
    if (!dmTargetDj || !currentUser) return;
    
    try {
      const channelId = getDmChannelId(currentUser.uid, dmTargetDj.id);
      
      // Delete all messages in the channel
      const messagesRef = collection(db, 'djDirectMessages', channelId, 'messages');
      const snapshot = await getDocs(messagesRef);
      
      const deletePromises = [];
      snapshot.forEach(document => {
        deletePromises.push(deleteDoc(doc(db, 'djDirectMessages', channelId, 'messages', document.id)));
      });
      
      await Promise.all(deletePromises);
      
      // Delete channel doc
      await deleteDoc(doc(db, 'djDirectMessages', channelId));
      
    } catch (e) {
      console.error('DM cleanup error:', e);
    }
  }
  
  // REPLACED BY PUSHER MODULE - DM notifications now handled via private Pusher channel
  // function subscribeToIncomingDms() { ... }
  
  function showDmNotification(senderId, senderName, message) {
    const notif = document.getElementById('dmNotification');
    const text = document.getElementById('dmNotifText');
    
    text.textContent = `New DM from ${senderName}`;
    notif.dataset.senderId = senderId;
    notif.dataset.senderName = senderName;
    notif.classList.remove('hidden');
    
    // Auto-hide after 10 seconds
    setTimeout(() => {
      notif.classList.add('hidden');
    }, 10000);
  }
  
  function openDmFromNotification() {
    const notif = document.getElementById('dmNotification');
    const senderId = notif.dataset.senderId;
    const senderName = notif.dataset.senderName;
    
    notif.classList.add('hidden');
    
    // Find the sender in online DJs cache
    const senderDj = onlineDjsCache.find(dj => dj.odamiMa === senderId);
    if (senderDj) {
      openDmModal();
      const avatarLetter = senderDj.avatarLetter || (senderDj.name ? senderDj.name.charAt(0).toUpperCase() : 'D');
      selectDmTarget(senderId, senderDj.name || senderName, senderDj.avatar || '', avatarLetter);
    } else {
      // DJ went offline, just open modal
      openDmModal();
    }
  }

  // ==========================================
  // GO LIVE MODAL
  // ==========================================

  let currentStreamKey = null;
  let streamKeyValidUntil = null;
  let currentStreamSource = 'obs'; // 'obs' or 'relay'
  let approvedRelayData = null;

  async function openGoLiveInline() {
    // Check if someone else is already streaming
    if (currentStream && currentStream.djId !== currentUser.uid) {
      alert('Someone is already live! Use the Takeover feature if you want to take over.');
      return;
    }

    // Generate/fetch stream key if needed
    if (!currentStreamKey) {
      document.getElementById('keyStatus').textContent = 'Loading...';
      await loadStreamKeyForGoLive();
    }

    // Scroll to the Go Live section
    const keySection = document.getElementById('streamKeySection');
    keySection?.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Update status
    document.getElementById('keyStatus').textContent = 'Ready';
    document.getElementById('keyStatus').className = 'key-status ready';
  }

  // Keep old function name for backwards compatibility
  async function openGoLiveModal() {
    return openGoLiveInline();
  }

  async function checkApprovedRelay() {
    const selector = document.getElementById('streamSourceSelector');
    const obsSetup = document.getElementById('obsStreamSetup');
    const relaySetup = document.getElementById('relayStreamSetup');

    try {
      // Fetch user data to check for approved relay
      const userResponse = await fetch(`/api/user/profile?userId=${currentUser.uid}`);
      const userData = await userResponse.json();

      if (userData.success && userData.user?.approvedRelay?.relayUrl) {
        approvedRelayData = userData.user.approvedRelay;

        // Update relay UI
        document.getElementById('relaySourceLabel').textContent = approvedRelayData.stationName || 'Relay';
        document.getElementById('relaySourceDesc').textContent = `Relay from ${approvedRelayData.stationName || 'external station'}`;
        document.getElementById('relayStationName').textContent = approvedRelayData.stationName || 'External Station';
        document.getElementById('relayUrlDisplay').textContent = approvedRelayData.relayUrl;

        // Show the stream source selector
        selector.classList.remove('hidden');
      } else {
        // No approved relay - hide selector
        approvedRelayData = null;
        selector.classList.add('hidden');
        selectStreamSource('obs');
      }
    } catch (error) {
      console.warn('Could not check relay status:', error);
      selector.classList.add('hidden');
      selectStreamSource('obs');
    }
  }

  function selectStreamSource(source) {
    currentStreamSource = source;

    const obsSetup = document.getElementById('obsStreamSetup');
    const relaySetup = document.getElementById('relayStreamSetup');
    const readyBtn = document.getElementById('goLiveReadyBtn');
    const readyHint = document.getElementById('readyHint');

    // Update button states
    document.querySelectorAll('.source-option').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.source === source);
    });

    if (source === 'obs') {
      obsSetup.classList.remove('hidden');
      relaySetup.classList.add('hidden');
      readyBtn.innerHTML = '<span class="ready-icon">üéØ</span> I\'m Ready - Go Live!';
      readyHint.textContent = 'Click once you\'ve started streaming in OBS';
    } else if (source === 'relay') {
      obsSetup.classList.add('hidden');
      relaySetup.classList.remove('hidden');
      readyBtn.innerHTML = '<span class="ready-icon">üì°</span> Start Relay';
      readyHint.textContent = 'Make sure you\'re live on your external station';
    }
  }

  function closeGoLiveModal() {
    document.getElementById('goLiveModal').classList.add('hidden');
    showGoLiveStep(1); // Reset to step 1 for next time
  }

  function showGoLiveStep(step) {
    // Hide all steps
    document.getElementById('goLiveStep1').classList.add('hidden');
    document.getElementById('goLiveStep2').classList.add('hidden');
    document.getElementById('goLiveStep3').classList.add('hidden');
    document.getElementById('goLiveError').classList.add('hidden');

    // Show requested step
    const stepEl = document.getElementById(`goLiveStep${step}`);
    if (stepEl) {
      stepEl.classList.remove('hidden');
    }
  }

  function showGoLiveError(message) {
    document.getElementById('goLiveStep1').classList.add('hidden');
    document.getElementById('goLiveStep2').classList.add('hidden');
    document.getElementById('goLiveStep3').classList.add('hidden');
    document.getElementById('goLiveError').classList.remove('hidden');
    document.getElementById('goLiveErrorMsg').textContent = message;
  }

  async function loadStreamKeyForGoLive() {
    // Update both modal element (if exists) and inline element
    const modalKeyEl = document.getElementById('goLiveStreamKey');
    const inlineKeyEl = document.getElementById('myStreamKey');

    // Check if we already have a valid stream key
    if (currentStreamKey && streamKeyValidUntil) {
      const validUntil = new Date(streamKeyValidUntil);
      const now = new Date();
      // If key is still valid (with 2 min buffer), reuse it
      if (validUntil.getTime() - now.getTime() > 2 * 60 * 1000) {
        console.log('[GoLive] Reusing existing stream key, valid until:', streamKeyValidUntil);
        if (modalKeyEl) modalKeyEl.textContent = currentStreamKey;
        if (inlineKeyEl) inlineKeyEl.textContent = currentStreamKey;
        return;
      }
    }

    if (modalKeyEl) modalKeyEl.textContent = 'Generating...';
    if (inlineKeyEl) inlineKeyEl.textContent = 'Generating...';

    try {
      const token = await currentUser.getIdToken();

      // Request a new stream key for go-live
      const response = await fetch('/api/livestream/slots', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          action: 'generate_key',
          djId: currentUser.uid,
          djName: userInfo.name
        })
      });

      const result = await response.json();

      if (result.success && result.streamKey) {
        currentStreamKey = result.streamKey;
        streamKeyValidUntil = result.validUntil;
        if (modalKeyEl) modalKeyEl.textContent = result.streamKey;
        if (inlineKeyEl) inlineKeyEl.textContent = result.streamKey;
        console.log('[GoLive] New stream key generated, valid until:', result.validUntil);
      } else {
        if (modalKeyEl) modalKeyEl.textContent = 'Error - try again';
        if (inlineKeyEl) inlineKeyEl.textContent = 'Error - try again';
        console.error('[GoLive] Failed to generate key:', result.error);
      }
    } catch (error) {
      console.error('[GoLive] Error loading stream key:', error);
      if (modalKeyEl) modalKeyEl.textContent = 'Error - try again';
      if (inlineKeyEl) inlineKeyEl.textContent = 'Error - try again';
    }
  }

  async function handleGoLiveReady() {
    // Get title and genre - check inline fields first, then modal fields
    let title, genre;

    if (currentStreamSource === 'relay') {
      title = document.getElementById('relayStreamTitle')?.value?.trim() || `Live from ${approvedRelayData?.stationName || 'External Station'}`;
      genre = document.getElementById('relayStreamGenre')?.value || 'Jungle / D&B';
    } else {
      // Try inline fields first, then fall back to modal fields
      title = document.getElementById('inlineStreamTitle')?.value?.trim()
           || document.getElementById('goLiveTitle')?.value?.trim()
           || 'Live Session';
      genre = document.getElementById('inlineStreamGenre')?.value
           || document.getElementById('goLiveGenre')?.value
           || 'Jungle / D&B';
    }

    // For OBS mode, check stream key
    if (currentStreamSource === 'obs' && !currentStreamKey) {
      throw new Error('No stream key available. Please refresh and try again.');
    }

    // For relay mode, check approved relay data
    if (currentStreamSource === 'relay' && !approvedRelayData?.relayUrl) {
      throw new Error('No approved relay URL found. Please contact admin.');
    }

    console.log('[GoLive] Starting go live with key:', currentStreamKey?.substring(0, 10) + '...');

    const token = await currentUser.getIdToken();

    // Build request body based on source type
    const requestBody = {
      action: currentStreamSource === 'relay' ? 'start_relay' : 'go_live',
      djId: currentUser.uid,
      djName: userInfo.name,
      title: title,
      genre: genre
    };

    if (currentStreamSource === 'relay') {
      requestBody.relayUrl = approvedRelayData.relayUrl;
      requestBody.stationName = approvedRelayData.stationName;
    } else {
      requestBody.streamKey = currentStreamKey;
    }

    // Send request
    const response = await fetch('/api/livestream/slots', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(requestBody)
    });

    const result = await response.json();

    if (result.success) {
      // Stream is live!
      console.log('[GoLive] Successfully went live!', result);

      // Refresh stream status
      await loadStreamStatus();

      // Update UI to show we're live
      updateEndStreamButton(true, true);

      // Hide ready section since we're now live
      document.getElementById('readySection')?.classList.add('hidden');

      return true;
    } else {
      // Log full error for debugging
      console.error('[GoLive] API Error:', result);

      // Throw error so caller knows it failed
      let errorMsg = result.error || 'Failed to go live';
      if (result.details) errorMsg += ': ' + result.details;
      if (result.error === 'stream_not_detected') {
        errorMsg = 'Stream not detected. Make sure OBS is streaming with the correct key.';
      } else if (result.error === 'relay_failed') {
        errorMsg = 'Failed to connect to relay stream.';
      }

      throw new Error(errorMsg);
    }
  }

  async function sendMessage() {
    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    if (!text) return;

    input.value = '';

    try {
      // Use Pusher module's sendChatMessage (handles API + Pusher broadcast)
      await sendChatMessage(text);
    } catch (e) {
      console.error('Send error:', e);
      input.value = text;
    }
  }
  
  function updateEndStreamButton(isLive, isMyStream) {
    const btn = document.getElementById('lobbyEndStreamBtn');
    const status = document.getElementById('endStreamStatus');
    const canEnd = isMyStream || userInfo?.isAdmin;
    
    if (isLive && canEnd) {
      btn.classList.remove('disabled');
      btn.disabled = false;
      btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
      if (isMyStream) {
        status.textContent = 'You are currently live';
        status.classList.add('live');
      } else {
        status.textContent = `Admin: End ${currentStream?.djName || 'DJ'}'s stream`;
        status.classList.add('live');
      }
    } else if (isLive) {
      btn.classList.add('disabled');
      btn.disabled = true;
      btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
      status.textContent = `${currentStream?.djName || 'Another DJ'} is streaming`;
      status.classList.remove('live');
    } else {
      btn.classList.add('disabled');
      btn.disabled = true;
      btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
      status.textContent = 'No active stream';
      status.classList.remove('live');
    }
  }
  
  function updateTakeoverAttemptsUI() {
    const attemptsLeft = MAX_TAKEOVER_ATTEMPTS - takeoverAttempts;
    const attemptsEl = document.getElementById('takeoverAttemptsLeft');
    const limitEl = document.getElementById('takeoverLimitReached');
    const btn = document.getElementById('requestTakeoverBtn');
    
    if (attemptsLeft <= 0) {
      attemptsEl.classList.add('hidden');
      limitEl.classList.remove('hidden');
      btn.classList.add('disabled');
      btn.disabled = true;
    } else {
      attemptsEl.classList.remove('hidden');
      limitEl.classList.add('hidden');
      attemptsEl.textContent = `${attemptsLeft} request${attemptsLeft !== 1 ? 's' : ''} remaining this session`;
      if (!takeoverPending) {
        btn.classList.remove('disabled');
        btn.disabled = false;
      }
    }
  }
  
  function clearTakeoverTimeout() {
    if (takeoverTimeout) {
      clearInterval(takeoverTimeout);
      takeoverTimeout = null;
    }
    takeoverPending = false;
  }
  
  function setupEventListeners() {
    // DM Modal
    document.getElementById('openDmBtn').addEventListener('click', openDmModal);
    document.getElementById('closeDmBtn').addEventListener('click', closeDmModal);
    document.querySelector('.dm-modal-overlay').addEventListener('click', closeDmModal);
    document.getElementById('dmBackBtn').addEventListener('click', goBackToDmList);
    
    document.getElementById('dmSendBtn').addEventListener('click', sendDmMessage);
    document.getElementById('dmInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendDmMessage();
    });
    
    // DM Notification
    document.getElementById('dmNotifOpenBtn').addEventListener('click', openDmFromNotification);
    document.getElementById('dmNotifDismissBtn').addEventListener('click', () => {
      document.getElementById('dmNotification').classList.add('hidden');
    });

    // Go Live Modal
    document.getElementById('goLiveBtn').addEventListener('click', openGoLiveModal);
    document.getElementById('closeGoLiveBtn').addEventListener('click', closeGoLiveModal);
    document.querySelector('.go-live-modal-overlay').addEventListener('click', closeGoLiveModal);
    document.getElementById('goLiveReadyBtn').addEventListener('click', handleGoLiveReady);
    document.getElementById('goLiveRetryBtn').addEventListener('click', () => {
      showGoLiveStep(1);
    });
    document.getElementById('closeGoLiveSuccessBtn').addEventListener('click', closeGoLiveModal);

    // Stream source selector
    document.querySelectorAll('.source-option').forEach(btn => {
      btn.addEventListener('click', () => {
        selectStreamSource(btn.dataset.source);
      });
    });

    // Copy buttons in Go Live modal
    document.querySelectorAll('.go-live-modal .copy-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const targetId = btn.dataset.copy;
        const text = document.getElementById(targetId).textContent;
        navigator.clipboard.writeText(text);
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 2000);
      });
    });

    // Sign out
    document.getElementById('signOutBtn').addEventListener('click', async () => {
      try {
        if (presenceRef) {
          await deleteDoc(presenceRef);
        }
        await signOut(auth);
        window.location.href = '/live';
      } catch (e) {
        console.error('Sign out error:', e);
        window.location.href = '/live';
      }
    });
    
    // Lobby End Stream button
    document.getElementById('lobbyEndStreamBtn').addEventListener('click', async () => {
      const btn = document.getElementById('lobbyEndStreamBtn');
      if (btn.classList.contains('disabled')) return;
      
      if (!confirm('Are you sure you want to end your stream?')) return;
      
      try {
        btn.disabled = true;
        btn.innerHTML = '<span class="end-icon">‚è≥</span><span class="end-text">Ending...</span>';
        
        // Use current stream's DJ ID (for admin ending someone else's stream)
        const targetDjId = currentStream?.djId || currentUser.uid;
        
        const token = await currentUser.getIdToken();
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            action: 'endStream',
            djId: targetDjId,
            isAdmin: userInfo?.isAdmin || false
          })
        });
        
        const result = await response.json();
        if (result.success) {
          updateEndStreamButton(false, false);
          await recordStreamEnd(); // Record when stream ended for chat cleanup
          await loadStreamStatus();
        } else {
          alert('Failed to end stream: ' + (result.error || 'Unknown error'));
          btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
          btn.disabled = false;
        }
      } catch (e) {
        console.error('End stream error:', e);
        alert('Failed to end stream');
        btn.innerHTML = '<span class="end-icon">‚èπ</span><span class="end-text">End Stream</span>';
        btn.disabled = false;
      }
    });
    
    // Chat
    document.getElementById('sendBtn').addEventListener('click', sendMessage);
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });
    
    // Play/Pause - handles both audio and video
    document.getElementById('playPauseBtn').addEventListener('click', () => {
      const audio = document.getElementById('audioElement');
      const video = document.getElementById('hlsVideo');
      const playIcon = document.getElementById('playIcon');
      const pauseIcon = document.getElementById('pauseIcon');

      // Determine which media element is active
      const isVideoStream = currentStream && currentStream.streamType !== 'audio' && !currentStream.streamUrl?.includes('8000');
      const media = isVideoStream ? video : audio;

      if (!media) return;

      if (isVideoStream) {
        // Video stream - HLS player handles the source
        if (isVideoPlaying) {
          media.pause();
        } else {
          media.play().catch(err => console.error('[HLS] Play error:', err));
        }
      } else {
        // Audio stream
        if (!audio.src && currentStream?.streamUrl) {
          audio.src = currentStream.streamUrl;
          audio.play();
        } else if (audio.paused) {
          audio.play();
        } else {
          audio.pause();
        }
        playIcon.classList.toggle('hidden', !audio.paused);
        pauseIcon.classList.toggle('hidden', audio.paused);
      }
    });

    // Volume - controls both audio and video
    document.getElementById('volumeSlider').addEventListener('input', (e) => {
      const volume = e.target.value / 100;
      document.getElementById('audioElement').volume = volume;
      document.getElementById('hlsVideo').volume = volume;
    });

    document.getElementById('muteBtn').addEventListener('click', () => {
      const audio = document.getElementById('audioElement');
      const video = document.getElementById('hlsVideo');
      const isVideoStream = currentStream && currentStream.streamType !== 'audio' && !currentStream.streamUrl?.includes('8000');
      const media = isVideoStream ? video : audio;

      if (media) {
        media.muted = !media.muted;
        document.getElementById('volumeSlider').value = media.muted ? 0 : media.volume * 100;
      }
    });
    
    // Ready button - Go Live! Sets ready status AND starts stream
    document.getElementById('setReadyBtn')?.addEventListener('click', async () => {
      if (!currentUser) return;

      const btn = document.getElementById('setReadyBtn');
      const btnText = document.getElementById('readyBtnText');

      // Disable button and show processing
      btn.disabled = true;
      btn.classList.remove('glow');
      btnText.textContent = '‚è≥ Going Live...';

      try {
        // First set ready status
        await fetch('/api/dj-lobby/presence', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'heartbeat',
            userId: currentUser.uid,
            isReady: true
          })
        });

        // Then start the stream
        await handleGoLiveReady();

        // Show success state
        btn.classList.add('is-ready');
        btn.style.background = '#10b981';
        btnText.textContent = 'üî¥ YOU ARE LIVE!';
        document.getElementById('readyStatus')?.classList.remove('hidden');
      } catch (e) {
        console.error('Go Live error:', e);
        // Show error message
        alert(e.message || 'Failed to go live. Please check OBS is streaming and try again.');
        // Reset button
        btnText.textContent = 'üéØ I\'m Ready - Go Live!';
        btn.disabled = false;
        btn.classList.add('glow');
      }
    });
    
    // Takeover
    document.getElementById('requestTakeoverBtn')?.addEventListener('click', async () => {
      if (!currentStream || !currentUser) return;
      if (takeoverPending) return;
      
      // Check if limit reached
      if (takeoverAttempts >= MAX_TAKEOVER_ATTEMPTS) {
        return;
      }
      
      try {
        // Increment attempts
        takeoverAttempts++;
        takeoverPending = true;
        updateTakeoverAttemptsUI();
        
        await setDoc(doc(db, 'djTakeoverRequests', currentStream.djId), {
          requesterId: currentUser.uid,
          requesterName: userInfo.name,
          requesterAvatar: userInfo.avatar,
          targetDjId: currentStream.djId,
          targetDjName: currentStream.djName,
          status: 'pending',
          createdAt: serverTimestamp()
        });
        
        await setDoc(doc(db, 'djTakeoverRequests', `request_${currentUser.uid}`), {
          requesterId: currentUser.uid,
          targetDjId: currentStream.djId,
          status: 'pending',
          createdAt: serverTimestamp()
        });
        
        document.getElementById('requestTakeoverBtn').classList.add('hidden');
        document.getElementById('takeoverPending').classList.remove('hidden');
        
        // Start 20-second timeout countdown
        let countdown = 20;
        const countdownEl = document.getElementById('takeoverCountdown');
        countdownEl.textContent = `(${countdown}s)`;
        
        takeoverTimeout = setInterval(() => {
          countdown--;
          countdownEl.textContent = `(${countdown}s)`;
          
          if (countdown <= 0) {
            clearInterval(takeoverTimeout);
            takeoverTimeout = null;
            takeoverPending = false;
            
            // Reset UI - timeout expired
            document.getElementById('takeoverPending').classList.add('hidden');
            
            // Check if more attempts available
            if (takeoverAttempts < MAX_TAKEOVER_ATTEMPTS) {
              document.getElementById('requestTakeoverBtn').classList.remove('hidden');
              document.getElementById('requestTakeoverBtn').classList.remove('disabled');
            }
            
            updateTakeoverAttemptsUI();
            
            // Clean up the pending request
            deleteDoc(doc(db, 'djTakeoverRequests', currentStream.djId)).catch(() => {});
            deleteDoc(doc(db, 'djTakeoverRequests', `request_${currentUser.uid}`)).catch(() => {});
          }
        }, 1000);
        
      } catch (e) {
        console.error('Takeover error:', e);
        alert('Failed to send takeover request');
        takeoverPending = false;
      }
    });
    
    document.getElementById('acceptTakeoverBtn')?.addEventListener('click', async () => {
      const div = document.getElementById('incomingTakeover');
      const requesterId = div.dataset.requesterId;
      if (!requesterId || !currentUser) return;

      try {
        // Get current stream key from the live stream or generated key
        let streamKeyToPass = currentStreamKey;
        let serverUrl = 'rtmp://rtmp.freshwax.co.uk/live';

        // If we have a current stream, use its key
        if (currentStream && currentStream.djId === currentUser.uid && currentStream.streamKey) {
          streamKeyToPass = currentStream.streamKey;
        }

        // If no stream key available, try to fetch it
        if (!streamKeyToPass) {
          const token = await currentUser.getIdToken();
          const response = await fetch('/api/livestream/slots?action=checkStreamKey&djId=' + currentUser.uid, {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          const result = await response.json();
          if (result.success && result.streamKey) {
            streamKeyToPass = result.streamKey;
          }
        }

        // Use the Pusher module to approve takeover (handles API + Pusher broadcast)
        const approved = await approveTakeover(requesterId, streamKeyToPass, serverUrl);

        if (approved) {
          hideIncomingTakeover();
          alert('Takeover approved! The new DJ can now use your stream key.');
        } else {
          alert('Failed to approve takeover. Please try again.');
        }
      } catch (e) {
        console.error('Accept error:', e);
        alert('Failed to approve takeover');
      }
    });
    
    document.getElementById('declineTakeoverBtn')?.addEventListener('click', async () => {
      const div = document.getElementById('incomingTakeover');
      const requesterId = div.dataset.requesterId;
      if (!requesterId) return;

      try {
        // Use the Pusher module to decline takeover (handles API + Pusher broadcast)
        const declined = await declineTakeover(requesterId);

        if (declined) {
          hideIncomingTakeover();
        } else {
          alert('Failed to decline takeover');
        }
      } catch (e) {
        console.error('Decline error:', e);
        alert('Failed to decline takeover');
      }
    });
    
    // End stream
    document.getElementById('endStreamBtn')?.addEventListener('click', async () => {
      if (!confirm('End your stream?')) return;
      
      try {
        const token = await currentUser.getIdToken();
        const response = await fetch('/api/livestream/slots', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ action: 'endStream', djId: currentUser.uid })
        });
        
        const result = await response.json();
        if (result.success) {
          alert('Stream ended');
          loadStreamStatus();
        } else {
          alert(result.error || 'Failed');
        }
      } catch (e) {
        console.error('End error:', e);
      }
    });
    
    // Copy buttons
    document.querySelectorAll('.copy-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const code = document.getElementById(btn.dataset.copy);
        if (code) {
          navigator.clipboard.writeText(code.textContent);
          btn.textContent = 'Copied!';
          setTimeout(() => { btn.textContent = 'Copy'; }, 2000);
        }
      });
    });
  }
</script>
</body>
</html>
