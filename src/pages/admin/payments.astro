---
// /src/pages/admin/payments.astro
// Fresh Wax Payments Admin - Disputes, Refunds, and Failed Payouts

import AdminLayout from '../../layouts/AdminLayout.astro';
import { queryCollection } from '../../lib/firebase-rest';
import { saQueryCollection } from '../../lib/firebase-service-account';

// Get service account config for payouts collection (requires auth)
const runtimeEnv = (Astro.locals as any)?.runtime?.env;
const projectId = runtimeEnv?.FIREBASE_PROJECT_ID || import.meta.env.FIREBASE_PROJECT_ID;
const clientEmail = runtimeEnv?.FIREBASE_CLIENT_EMAIL || import.meta.env.FIREBASE_CLIENT_EMAIL;
const privateKey = runtimeEnv?.FIREBASE_PRIVATE_KEY || import.meta.env.FIREBASE_PRIVATE_KEY;

const serviceAccountKey = JSON.stringify({
  type: 'service_account',
  project_id: projectId,
  private_key_id: 'auto',
  private_key: privateKey?.replace(/\\n/g, '\n'),
  client_email: clientEmail,
  client_id: '',
  auth_uri: 'https://accounts.google.com/o/oauth2/auth',
  token_uri: 'https://oauth2.googleapis.com/token'
});

// Fetch disputes
const disputes = await queryCollection('disputes', {
  orderBy: { field: 'createdAt', direction: 'DESCENDING' },
  limit: 50
});

// Fetch refunds
const refunds = await queryCollection('refunds', {
  orderBy: { field: 'createdAt', direction: 'DESCENDING' },
  limit: 50
});

// Fetch failed/pending payouts (for the Pending tab)
const pendingPayouts = await queryCollection('pendingPayouts', {
  filters: [
    { field: 'status', op: 'IN', value: ['retry_pending', 'awaiting_connect', 'processing'] }
  ],
  orderBy: { field: 'createdAt', direction: 'DESCENDING' },
  limit: 50
});

// Fetch all pending payouts with status 'pending' (for manual review)
// Use service account auth to ensure we can read the pendingPayouts collection
let manualPendingPayouts: Record<string, any>[] = [];
try {
  manualPendingPayouts = await saQueryCollection(serviceAccountKey, projectId, 'pendingPayouts', {
    filters: [
      { field: 'status', op: 'EQUAL', value: 'pending' }
    ],
    orderBy: { field: 'createdAt', direction: 'DESCENDING' },
    limit: 100
  });
  console.log('[payments] Found', manualPendingPayouts.length, 'pending artist payouts');
} catch (err) {
  console.error('[payments] Error fetching manualPendingPayouts:', err);
}

// Fetch pending supplier payouts
let pendingSupplierPayouts: Record<string, any>[] = [];
try {
  pendingSupplierPayouts = await saQueryCollection(serviceAccountKey, projectId, 'pendingSupplierPayouts', {
    orderBy: { field: 'createdAt', direction: 'DESCENDING' },
    limit: 100
  });
  console.log('[payments] Found', pendingSupplierPayouts.length, 'pending supplier payouts');
} catch (err) {
  // Collection might not exist yet
  console.log('[payments] No pending supplier payouts collection');
}

// Fetch pending seller payouts (vinyl crate)
let pendingSellerPayouts: Record<string, any>[] = [];
try {
  pendingSellerPayouts = await saQueryCollection(serviceAccountKey, projectId, 'pendingSellerPayouts', {
    orderBy: { field: 'createdAt', direction: 'DESCENDING' },
    limit: 100
  });
  console.log('[payments] Found', pendingSellerPayouts.length, 'pending seller payouts');
} catch (err) {
  // Collection might not exist yet
  console.log('[payments] No pending seller payouts collection');
}

// Define payee type for unified tracking
type PayeeInfo = {
  type: 'artist' | 'supplier' | 'seller';
  id: string;
  name: string;
  email: string;
  amount: number;
  items?: string[];
  status?: string;
};

// Create a unified map of orderId -> payees (all types)
const orderPayeesMap: Record<string, PayeeInfo[]> = {};
const seenPayouts = new Set<string>();

// Add artist payouts
for (const payout of manualPendingPayouts) {
  if (!payout.orderId) continue;
  const uniqueKey = `artist_${payout.orderId}_${payout.artistId || payout.artistEmail}`;
  if (seenPayouts.has(uniqueKey)) continue;
  seenPayouts.add(uniqueKey);

  if (!orderPayeesMap[payout.orderId]) {
    orderPayeesMap[payout.orderId] = [];
  }
  orderPayeesMap[payout.orderId].push({
    type: 'artist',
    id: payout.artistId || '',
    name: payout.artistName || 'Unknown Artist',
    email: payout.artistEmail || '',
    amount: payout.amount || 0,
    items: payout.items,
    status: payout.status
  });
}

// Add supplier payouts
for (const payout of pendingSupplierPayouts) {
  if (!payout.orderId) continue;
  const uniqueKey = `supplier_${payout.orderId}_${payout.supplierId || payout.supplierEmail}`;
  if (seenPayouts.has(uniqueKey)) continue;
  seenPayouts.add(uniqueKey);

  if (!orderPayeesMap[payout.orderId]) {
    orderPayeesMap[payout.orderId] = [];
  }
  orderPayeesMap[payout.orderId].push({
    type: 'supplier',
    id: payout.supplierId || '',
    name: payout.supplierName || 'Unknown Supplier',
    email: payout.supplierEmail || '',
    amount: payout.amount || 0,
    items: payout.items,
    status: payout.status
  });
}

// Add seller payouts (vinyl crate)
for (const payout of pendingSellerPayouts) {
  if (!payout.orderId) continue;
  const uniqueKey = `seller_${payout.orderId}_${payout.sellerId || payout.sellerEmail}`;
  if (seenPayouts.has(uniqueKey)) continue;
  seenPayouts.add(uniqueKey);

  if (!orderPayeesMap[payout.orderId]) {
    orderPayeesMap[payout.orderId] = [];
  }
  orderPayeesMap[payout.orderId].push({
    type: 'seller',
    id: payout.sellerId || '',
    name: payout.sellerName || 'Unknown Seller',
    email: payout.sellerEmail || '',
    amount: payout.amount || 0,
    items: payout.items,
    status: payout.status
  });
}

// Legacy: keep orderArtistMap for backwards compatibility
const orderArtistMap = orderPayeesMap;

// Fetch completed payouts using service account auth (payouts collection requires auth)
let completedPayouts: Record<string, any>[] = [];
try {
  completedPayouts = await saQueryCollection(serviceAccountKey, projectId, 'payouts', {
    orderBy: { field: 'createdAt', direction: 'DESCENDING' },
    limit: 100
  });
} catch (err) {
  console.error('[payments] Error fetching payouts:', err);
}

// Fetch recent orders to check which need payouts
const recentOrders = await queryCollection('orders', {
  orderBy: { field: 'createdAt', direction: 'DESCENDING' },
  limit: 100
});

// Query salesLedger for accurate fee and payout data (source of truth)
let ledgerEntries: Record<string, any>[] = [];
const ledgerByOrderId: Record<string, any> = {};
try {
  ledgerEntries = await saQueryCollection(serviceAccountKey, projectId, 'salesLedger', {
    orderBy: { field: 'timestamp', direction: 'DESCENDING' },
    limit: 500
  });
  // Index by orderId for quick lookups
  for (const entry of ledgerEntries) {
    if (entry.orderId) {
      ledgerByOrderId[entry.orderId] = entry;
    }
  }
  console.log('[payments] Loaded', ledgerEntries.length, 'ledger entries');
} catch (err) {
  console.error('[payments] Error fetching ledger:', err);
}

// Fetch artists to map artistId -> artistName
const artists = await queryCollection('artists', { limit: 200 });
const artistMap: Record<string, string> = {};
for (const artist of artists) {
  artistMap[artist.id] = artist.artistName || artist.name || 'Unknown';
}

// Fetch releases to map releaseId -> artistId
const releases = await queryCollection('releases', { limit: 500 });
const releaseArtistMap: Record<string, string> = {};
for (const release of releases) {
  const artistId = release.artistId || release.userId;
  if (artistId && artistMap[artistId]) {
    releaseArtistMap[release.id] = artistMap[artistId];
  }
}

// Find orders needing payouts
const orderIdsWithPendingPayouts = new Set(Object.keys(orderArtistMap));
const paidOrderIds = new Set(completedPayouts.map(p => p.orderId));

// Get orders that need payouts - either have pending payout records OR are unpaid orders with payable items
const ordersNeedingPayouts = recentOrders.filter(order => {
  // Skip if already marked as paid
  if (paidOrderIds.has(order.id)) return false;

  // Include if has a pending payout record (any type: artist, supplier, seller)
  if (orderIdsWithPendingPayouts.has(order.id)) return true;

  // Also include older orders that don't have payout records yet
  // Skip test mode and free download orders
  if (order.paymentMethod === 'test_mode' || order.paymentMethod === 'free_download') return false;
  // Skip orders with zero total
  if (order.totals?.total === 0 || order.total === 0) return false;
  // Skip if no items
  if (!order.items || order.items.length === 0) return false;
  // Skip if payment not completed
  if (order.paymentStatus !== 'completed' && order.status !== 'completed' && order.orderStatus !== 'completed') return false;
  // Check if has items that need payouts (digital, merch, or crate)
  const hasPayableItems = order.items.some(item =>
    item.type === 'digital' || item.type === 'release' || item.type === 'track' || !item.type ||
    item.type === 'merch' || item.type === 'crate' || item.type === 'vinyl-crate'
  );
  return hasPayableItems;
});

// Stats
const openDisputes = disputes.filter(d => d.status === 'open' || d.status === 'needs_response').length;
const wonDisputes = disputes.filter(d => d.outcome === 'won').length;
const lostDisputes = disputes.filter(d => d.outcome === 'lost').length;
const totalRefunded = refunds.reduce((sum, r) => sum + (r.amountRefunded || 0), 0);
const pendingPayoutTotal = pendingPayouts.reduce((sum, p) => sum + (p.amount || 0), 0);

// Only count real payouts (exclude test mode)
const realPayouts = completedPayouts.filter(p => !p.isTestMode);
const completedPayoutTotal = realPayouts.reduce((sum, p) => sum + (p.amount || 0), 0);
// Calculate total from all pending payout types
const pendingArtistTotal = manualPendingPayouts.reduce((sum, p) => sum + (p.amount || 0), 0);
const pendingSupplierTotal = pendingSupplierPayouts.reduce((sum, p) => sum + (p.amount || 0), 0);
const pendingSellerTotal = pendingSellerPayouts.reduce((sum, p) => sum + (p.amount || 0), 0);
const pendingPayoutRecordsTotal = pendingArtistTotal + pendingSupplierTotal + pendingSellerTotal;
const ordersWithoutRecordsTotal = ordersNeedingPayouts
  .filter(o => !orderIdsWithPendingPayouts.has(o.id))
  .reduce((sum, o) => {
    const itemTotal = (o.items || []).reduce((s, i) => s + ((i.price || 0) * (i.quantity || 1)), 0);
    return sum + itemTotal;
  }, 0);
const ordersNeedingPayoutTotal = pendingPayoutRecordsTotal + ordersWithoutRecordsTotal;

const stats = [
  { label: 'Orders Need Payout', value: ordersNeedingPayouts.length, type: ordersNeedingPayouts.length > 0 ? 'warning' : 'default', detail: `~¬£${ordersNeedingPayoutTotal.toFixed(2)}` },
  { label: 'Pending/Failed', value: pendingPayouts.length, type: pendingPayouts.length > 0 ? 'danger' : 'default', detail: `¬£${pendingPayoutTotal.toFixed(2)}` },
  { label: 'Completed Payouts', value: realPayouts.length, type: 'success', detail: `¬£${completedPayoutTotal.toFixed(2)}` },
  { label: 'Open Disputes', value: openDisputes, type: openDisputes > 0 ? 'danger' : 'default' },
];

// Format currency
const formatCurrency = (amount) => {
  return new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(amount || 0);
};

// Format date
const formatDate = (date) => {
  if (!date) return '-';
  return new Date(date).toLocaleDateString('en-GB', {
    day: 'numeric',
    month: 'short',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
};

// Get status badge class
const getStatusClass = (status) => {
  const s = (status || '').toLowerCase();
  if (s === 'won' || s === 'completed') return 'success';
  if (s === 'lost' || s === 'failed') return 'danger';
  if (s === 'open' || s === 'needs_response' || s === 'processing') return 'warning';
  if (s === 'awaiting_connect' || s === 'retry_pending') return 'pending';
  return 'default';
};

export const prerender = false;
---

<AdminLayout title="Payments" activeNav="payments" showStats={true} stats={stats}>
  <Fragment slot="actions">
    <button class="btn btn-outline" onclick="window.location.reload()">
      ‚Üª Refresh
    </button>
  </Fragment>

  <!-- Tab Navigation -->
  <div class="tabs">
    <button class="tab active" data-tab="trigger">
      üí∞ Trigger Payouts ({ordersNeedingPayouts.length})
    </button>
    <button class="tab" data-tab="completed">
      ‚úÖ Completed ({completedPayouts.length})
    </button>
    <button class="tab" data-tab="pending">
      ‚è≥ Pending ({pendingPayouts.length})
    </button>
    <button class="tab" data-tab="disputes">
      ‚ö†Ô∏è Disputes ({disputes.length})
    </button>
    <button class="tab" data-tab="refunds">
      üí∏ Refunds ({refunds.length})
    </button>
  </div>

  <!-- Trigger Payouts Tab -->
  <div class="tab-content" id="trigger-tab">
    <div class="card">
      <div class="card-header">
        <h2>Orders Needing Artist Payouts</h2>
        <span class="text-muted">{ordersNeedingPayouts.length} orders</span>
      </div>
      <div class="table-wrapper">
        <table class="data-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Order</th>
              <th>Customer</th>
              <th>To Pay</th>
              <th>Total</th>
              <th>Fees</th>
              <th>Payment</th>
              <th class="text-right">Actions</th>
            </tr>
          </thead>
          <tbody>
            {ordersNeedingPayouts.length === 0 ? (
              <tr>
                <td colspan="8" class="text-center text-muted" style="padding: 3rem;">
                  All orders have been paid out!
                </td>
              </tr>
            ) : (
              ordersNeedingPayouts.map(order => {
                const itemTotal = (order.items || []).reduce((s, i) => s + ((i.price || 0) * (i.quantity || 1)), 0);
                // Get all payees from unified map
                const payees = (orderPayeesMap[order.id] || []) as PayeeInfo[];
                const totalPayoutAmount = payees.reduce((sum, p) => sum + (p.amount || 0), 0);

                // If no payees in map, try fallback lookup for digital items
                let fallbackPayees: PayeeInfo[] = [];
                if (payees.length === 0) {
                  for (const i of (order.items || [])) {
                    const releaseId = i.releaseId || i.productId || i.id;
                    let foundName = releaseArtistMap[releaseId];
                    if (!foundName && i.artistId && artistMap[i.artistId]) {
                      foundName = artistMap[i.artistId];
                    }
                    if (!foundName && i.downloads?.artistName) {
                      foundName = i.downloads.artistName;
                    }
                    if (foundName && !fallbackPayees.find(p => p.name === foundName)) {
                      const itemPrice = (i.price || 0) * (i.quantity || 1);
                      const estimated = itemPrice * 0.81;
                      fallbackPayees.push({
                        type: i.type === 'merch' ? 'supplier' : i.type === 'crate' ? 'seller' : 'artist',
                        id: i.artistId || '',
                        name: foundName,
                        email: '',
                        amount: estimated
                      });
                    }
                  }
                }
                const allPayees = payees.length > 0 ? payees : fallbackPayees;
                const displayPayoutTotal = payees.length > 0 ? totalPayoutAmount : fallbackPayees.reduce((s, p) => s + p.amount, 0);

                // Type colors and icons
                const typeStyles = {
                  artist: { color: '#dc2626', bg: '#fef2f2', icon: 'üéµ' },
                  supplier: { color: '#2563eb', bg: '#eff6ff', icon: 'üëï' },
                  seller: { color: '#7c3aed', bg: '#f5f3ff', icon: 'üì¶' }
                };

                return (
                  <tr data-order-id={order.id}>
                    <td class="cell-secondary">{formatDate(order.createdAt)}</td>
                    <td>
                      <span class="cell-mono">#{(order.orderNumber || order.id || '').slice(-8).toUpperCase()}</span>
                    </td>
                    <td>
                      <div class="item-info">
                        <h4 style="font-size: 0.875rem;">{order.customer?.firstName && order.customer?.lastName
                          ? `${order.customer.firstName} ${order.customer.lastName}`
                          : order.customer?.name || order.customerName || 'Customer'}</h4>
                        <p style="font-size: 0.75rem;">{order.customer?.email || order.email || ''}</p>
                      </div>
                    </td>
                    <td>
                      {allPayees.length === 0 ? (
                        <span style="color: #dc2626; font-size: 0.875rem;">Unknown</span>
                      ) : (
                        <div style="display: flex; flex-direction: column; gap: 0.35rem;">
                          {allPayees.map(payee => {
                            const style = typeStyles[payee.type];
                            return (
                              <div style={`display: flex; align-items: center; gap: 0.5rem; padding: 0.25rem 0.5rem; background: ${style.bg}; border-radius: 4px; font-size: 0.8rem;`}>
                                <span style="font-size: 0.75rem;">{style.icon}</span>
                                <span style={`color: ${style.color}; font-weight: 600; flex: 1;`}>{payee.name}</span>
                                <span style={`color: #16a34a; font-weight: 700;`}>{formatCurrency(payee.amount)}</span>
                                <button
                                  class="btn btn-primary btn-xs trigger-payee-btn"
                                  style="padding: 0.15rem 0.5rem; font-size: 0.7rem; margin-left: 0.25rem;"
                                  data-order-id={order.id}
                                  data-order-number={order.orderNumber}
                                  data-payee-type={payee.type}
                                  data-payee-id={payee.id}
                                  data-payee-name={payee.name}
                                  data-payee-email={payee.email}
                                  data-payee-amount={payee.amount}
                                >
                                  üí∏ Pay
                                </button>
                              </div>
                            );
                          })}
                          {allPayees.length > 1 && (
                            <div style="display: flex; justify-content: flex-end; padding-top: 0.25rem; border-top: 1px dashed #e5e5e5; margin-top: 0.25rem;">
                              <span style="font-size: 0.75rem; color: #666;">Total:</span>
                              <span style="font-size: 0.875rem; font-weight: 700; color: #16a34a; margin-left: 0.5rem;">{formatCurrency(displayPayoutTotal)}</span>
                            </div>
                          )}
                        </div>
                      )}
                    </td>
                    <td class="font-bold">{formatCurrency(itemTotal)}</td>
                    <td>
                      {(() => {
                        // Use ledger data if available (source of truth)
                        const ledger = ledgerByOrderId[order.id];
                        const freshWaxFee = ledger?.freshWaxFee ?? order.totals?.freshWaxFee ?? (itemTotal * 0.01);
                        const stripeFee = ledger?.stripeFee ?? order.totals?.stripeFee ?? 0;
                        const paypalFee = ledger?.actualPaypalFee ?? ledger?.paypalFee ?? order.totals?.paypalFee ?? 0;
                        const processingFee = order.paymentMethod === 'paypal' ? paypalFee : stripeFee;
                        return (
                          <div style="font-size: 0.75rem; line-height: 1.4;">
                            <div style="color: #666;">FW: {formatCurrency(freshWaxFee)}</div>
                            <div style="color: #666;">{order.paymentMethod === 'stripe' ? 'Stripe' : 'PayPal'}: {formatCurrency(processingFee)}</div>
                            {ledger && <div style="color: #16a34a; font-size: 0.65rem;">‚úì Ledger</div>}
                          </div>
                        );
                      })()}
                    </td>
                    <td>
                      <span class="badge badge-info">{order.paymentMethod || 'unknown'}</span>
                    </td>
                    <td class="text-right">
                      <button
                        class="btn btn-outline btn-sm mark-paid-btn"
                        data-order-id={order.id}
                        data-order-number={order.orderNumber}
                        title="Mark all payees as paid"
                      >
                        ‚úì All Paid
                      </button>
                    </td>
                  </tr>
                );
              })
            )}
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Completed Payouts Tab -->
  <div class="tab-content" id="completed-tab" style="display: none;">
    <div class="card">
      <div class="card-header">
        <h2>Completed Payouts</h2>
        <span class="text-muted">{completedPayouts.length} payouts - {formatCurrency(completedPayoutTotal)} total</span>
      </div>
      <div class="table-wrapper">
        <table class="data-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Artist</th>
              <th>Order</th>
              <th>Amount</th>
              <th>Method</th>
              <th>Batch ID</th>
            </tr>
          </thead>
          <tbody>
            {completedPayouts.length === 0 ? (
              <tr>
                <td colspan="6" class="text-center text-muted" style="padding: 3rem;">
                  No completed payouts yet
                </td>
              </tr>
            ) : (
              completedPayouts.map(payout => (
                <tr>
                  <td class="cell-secondary">{formatDate(payout.completedAt || payout.createdAt)}</td>
                  <td>
                    <div class="item-info">
                      <h4 style="font-size: 0.875rem;">{payout.artistName || 'Unknown'}</h4>
                      <p style="font-size: 0.75rem;">{payout.paypalEmail || payout.artistEmail || ''}</p>
                    </div>
                  </td>
                  <td>
                    <span class="cell-mono">#{(payout.orderNumber || payout.orderId || '').slice(-8).toUpperCase()}</span>
                  </td>
                  <td class="font-bold" style="color: #16a34a;">{formatCurrency(payout.amount)}</td>
                  <td>
                    <span class="badge badge-success">{payout.payoutMethod || 'paypal'}</span>
                  </td>
                  <td class="cell-mono" style="font-size: 0.75rem;">
                    {payout.paypalBatchId || payout.stripeTransferId || '-'}
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Disputes Tab -->
  <div class="tab-content" id="disputes-tab" style="display: none;">
    <div class="card">
      <div class="card-header">
        <h2>Payment Disputes</h2>
        <span class="text-muted">{disputes.length} disputes</span>
      </div>
      <div class="table-wrapper">
        <table class="data-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Order</th>
              <th>Amount</th>
              <th>Reason</th>
              <th>Status</th>
              <th>Recovered</th>
              <th class="text-right">Actions</th>
            </tr>
          </thead>
          <tbody>
            {disputes.length === 0 ? (
              <tr>
                <td colspan="7" class="text-center text-muted" style="padding: 3rem;">
                  No disputes found - that's good news!
                </td>
              </tr>
            ) : (
              disputes.map(dispute => (
                <tr>
                  <td class="cell-secondary">{formatDate(dispute.createdAt)}</td>
                  <td>
                    <span class="cell-mono">#{(dispute.orderNumber || dispute.orderId || '').slice(-8).toUpperCase()}</span>
                  </td>
                  <td class="font-bold">{formatCurrency(dispute.amount)}</td>
                  <td>
                    <span class="badge badge-info">{dispute.reason || 'Unknown'}</span>
                  </td>
                  <td>
                    <span class={`badge badge-${getStatusClass(dispute.status || dispute.outcome)}`}>
                      {dispute.outcome || dispute.status || 'Open'}
                    </span>
                  </td>
                  <td>
                    {dispute.amountRecovered ? formatCurrency(dispute.amountRecovered) : '-'}
                    {dispute.retransferCount > 0 && (
                      <span class="text-muted" style="font-size: 0.75rem;"> ({dispute.retransferCount} re-transferred)</span>
                    )}
                  </td>
                  <td class="text-right">
                    <button
                      class="btn btn-ghost btn-sm view-dispute-btn"
                      data-dispute={JSON.stringify(dispute)}
                      title="View Details"
                    >
                      üëÅÔ∏è
                    </button>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Refunds Tab -->
  <div class="tab-content" id="refunds-tab" style="display: none;">
    <div class="card">
      <div class="card-header">
        <h2>Refunds</h2>
        <span class="text-muted">{refunds.length} refunds</span>
      </div>
      <div class="table-wrapper">
        <table class="data-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Order</th>
              <th>Amount</th>
              <th>Type</th>
              <th>Transfers Reversed</th>
              <th>Total Clawed Back</th>
              <th class="text-right">Actions</th>
            </tr>
          </thead>
          <tbody>
            {refunds.length === 0 ? (
              <tr>
                <td colspan="7" class="text-center text-muted" style="padding: 3rem;">
                  No refunds processed yet
                </td>
              </tr>
            ) : (
              refunds.map(refund => (
                <tr>
                  <td class="cell-secondary">{formatDate(refund.createdAt)}</td>
                  <td>
                    <span class="cell-mono">#{(refund.orderNumber || refund.orderId || '').slice(-8).toUpperCase()}</span>
                  </td>
                  <td class="font-bold" style="color: #dc2626;">{formatCurrency(refund.amountRefunded)}</td>
                  <td>
                    <span class={`badge badge-${refund.isFullRefund ? 'danger' : 'warning'}`}>
                      {refund.isFullRefund ? 'Full' : `${((refund.refundPercentage || 0) * 100).toFixed(0)}%`}
                    </span>
                  </td>
                  <td>
                    {refund.transfersReversed?.filter(t => !t.failed).length || 0} of {refund.transfersReversed?.length || 0}
                  </td>
                  <td>{formatCurrency(refund.totalReversed)}</td>
                  <td class="text-right">
                    <button
                      class="btn btn-ghost btn-sm view-refund-btn"
                      data-refund={JSON.stringify(refund)}
                      title="View Details"
                    >
                      üëÅÔ∏è
                    </button>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Pending Payouts Tab -->
  <div class="tab-content" id="pending-tab" style="display: none;">
    <div class="card">
      <div class="card-header">
        <h2>Pending & Failed Payouts</h2>
        <span class="text-muted">{pendingPayouts.length} payouts waiting</span>
      </div>
      <div class="table-wrapper">
        <table class="data-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Artist</th>
              <th>Order</th>
              <th>Amount</th>
              <th>Status</th>
              <th>Reason</th>
              <th class="text-right">Actions</th>
            </tr>
          </thead>
          <tbody>
            {pendingPayouts.length === 0 ? (
              <tr>
                <td colspan="7" class="text-center text-muted" style="padding: 3rem;">
                  No pending payouts - all artists are paid up!
                </td>
              </tr>
            ) : (
              pendingPayouts.map(payout => (
                <tr data-id={payout.id}>
                  <td class="cell-secondary">{formatDate(payout.createdAt)}</td>
                  <td>
                    <div class="item-info">
                      <h4 style="font-size: 0.875rem;">{payout.artistName || 'Unknown Artist'}</h4>
                      <p style="font-size: 0.75rem;">{payout.artistEmail || ''}</p>
                    </div>
                  </td>
                  <td>
                    <span class="cell-mono">#{(payout.orderNumber || payout.orderId || '').slice(-8).toUpperCase()}</span>
                  </td>
                  <td class="font-bold">{formatCurrency(payout.amount)}</td>
                  <td>
                    <span class={`badge badge-${getStatusClass(payout.status)}`}>
                      {payout.status === 'awaiting_connect' ? 'Awaiting Stripe' :
                       payout.status === 'retry_pending' ? 'Retry Needed' :
                       payout.status}
                    </span>
                  </td>
                  <td class="cell-secondary" style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">
                    {payout.failureReason || payout.reason || '-'}
                  </td>
                  <td class="text-right">
                    <div class="flex gap-1 justify-end">
                      <button
                        class="btn btn-ghost btn-sm view-payout-btn"
                        data-payout={JSON.stringify(payout)}
                        title="View Details"
                      >
                        üëÅÔ∏è
                      </button>
                      {payout.status === 'retry_pending' && (
                        <button
                          class="btn btn-primary btn-sm retry-btn"
                          data-id={payout.id}
                          title="Retry Payout"
                        >
                          üîÑ
                        </button>
                      )}
                    </div>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Dispute Details Modal -->
  <div id="disputeModal" class="modal-overlay" slot="modals">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h2>Dispute Details</h2>
        <button class="modal-close" onclick="closeModal('disputeModal')">&times;</button>
      </div>
      <div class="modal-body" id="disputeModalContent">
        <!-- Populated by JS -->
      </div>
      <div class="modal-footer">
        <button class="btn btn-outline" onclick="closeModal('disputeModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Refund Details Modal -->
  <div id="refundModal" class="modal-overlay" slot="modals">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h2>Refund Details</h2>
        <button class="modal-close" onclick="closeModal('refundModal')">&times;</button>
      </div>
      <div class="modal-body" id="refundModalContent">
        <!-- Populated by JS -->
      </div>
      <div class="modal-footer">
        <button class="btn btn-outline" onclick="closeModal('refundModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Payout Details Modal -->
  <div id="payoutModal" class="modal-overlay" slot="modals">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h2>Payout Details</h2>
        <button class="modal-close" onclick="closeModal('payoutModal')">&times;</button>
      </div>
      <div class="modal-body" id="payoutModalContent">
        <!-- Populated by JS -->
      </div>
      <div class="modal-footer">
        <button class="btn btn-outline" onclick="closeModal('payoutModal')">Close</button>
      </div>
    </div>
  </div>

  <Fragment slot="scripts">
    <script is:inline>
      const formatCurrency = (amount) => {
        return new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(amount || 0);
      };

      const formatDate = (date) => {
        if (!date) return '-';
        return new Date(date).toLocaleString('en-GB', {
          day: 'numeric',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      };

      // Tab switching
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');

          tab.classList.add('active');
          const tabId = tab.dataset.tab + '-tab';
          document.getElementById(tabId).style.display = 'block';
        });
      });

      // View dispute details
      document.querySelectorAll('.view-dispute-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const dispute = JSON.parse(btn.dataset.dispute);
          showDisputeDetails(dispute);
        });
      });

      function showDisputeDetails(dispute) {
        const content = document.getElementById('disputeModalContent');

        const transfersHtml = (dispute.transfersReversed || []).map(t => `
          <div style="display: flex; justify-content: space-between; padding: 0.5rem; background: #f5f5f5; margin-bottom: 0.25rem;">
            <span>${t.artistName || 'Unknown'}</span>
            <span style="font-weight: 600;">${formatCurrency(t.amount)}</span>
          </div>
        `).join('') || '<div style="color: #888;">No transfers reversed</div>';

        const retransfersHtml = (dispute.retransfersCreated || []).map(t => `
          <div style="display: flex; justify-content: space-between; padding: 0.5rem; background: #e8f5e9; margin-bottom: 0.25rem;">
            <span>${t.artistName || 'Unknown'}</span>
            <span style="font-weight: 600; color: #16a34a;">+${formatCurrency(t.amount)}</span>
          </div>
        `).join('') || '';

        content.innerHTML = `
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Dispute ID</div>
              <div style="font-family: monospace; font-size: 0.875rem;">${dispute.stripeDisputeId || dispute.id}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Status</div>
              <div style="font-weight: 600;">${dispute.outcome || dispute.status || 'Open'}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Amount</div>
              <div style="font-weight: 700; font-size: 1.25rem;">${formatCurrency(dispute.amount)}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Reason</div>
              <div>${dispute.reason || 'Unknown'}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Created</div>
              <div>${formatDate(dispute.createdAt)}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Resolved</div>
              <div>${formatDate(dispute.resolvedAt) || 'Pending'}</div>
            </div>
          </div>

          <div style="margin-bottom: 1.5rem;">
            <div style="font-size: 0.7rem; color: #888; text-transform: uppercase; margin-bottom: 0.5rem;">Transfers Reversed (Clawed Back)</div>
            ${transfersHtml}
            ${dispute.amountRecovered ? `
              <div style="display: flex; justify-content: space-between; padding: 0.5rem; background: #000; color: #fff; margin-top: 0.5rem;">
                <span>Total Recovered</span>
                <span style="font-weight: 700;">${formatCurrency(dispute.amountRecovered)}</span>
              </div>
            ` : ''}
          </div>

          ${retransfersHtml ? `
            <div style="margin-bottom: 1.5rem;">
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase; margin-bottom: 0.5rem;">Re-Transfers After Win</div>
              ${retransfersHtml}
            </div>
          ` : ''}

          ${dispute.netImpact !== undefined ? `
            <div style="background: ${dispute.netImpact > 0 ? '#fee2e2' : '#e8f5e9'}; border: 1px solid ${dispute.netImpact > 0 ? '#fca5a5' : '#a5d6a7'}; padding: 1rem;">
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Net Platform Impact</div>
              <div style="font-weight: 700; font-size: 1.25rem; color: ${dispute.netImpact > 0 ? '#dc2626' : '#16a34a'};">
                ${dispute.netImpact > 0 ? '-' : ''}${formatCurrency(Math.abs(dispute.netImpact))}
              </div>
            </div>
          ` : ''}
        `;

        openModal('disputeModal');
      }

      // View refund details
      document.querySelectorAll('.view-refund-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const refund = JSON.parse(btn.dataset.refund);
          showRefundDetails(refund);
        });
      });

      function showRefundDetails(refund) {
        const content = document.getElementById('refundModalContent');

        const transfersHtml = (refund.transfersReversed || []).map(t => `
          <div style="display: flex; justify-content: space-between; padding: 0.5rem; background: ${t.failed ? '#fee2e2' : '#f5f5f5'}; margin-bottom: 0.25rem;">
            <span>
              ${t.artistName || 'Unknown'}
              ${t.failed ? '<span style="color: #dc2626; font-size: 0.75rem;"> (Failed)</span>' : ''}
            </span>
            <span style="font-weight: 600; color: ${t.failed ? '#dc2626' : '#000'};">
              ${t.failed ? 'Error' : formatCurrency(t.amount)}
            </span>
          </div>
          ${t.error ? `<div style="font-size: 0.75rem; color: #dc2626; padding: 0 0.5rem 0.5rem;">${t.error}</div>` : ''}
        `).join('') || '<div style="color: #888;">No transfers reversed</div>';

        content.innerHTML = `
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Order</div>
              <div style="font-family: monospace;">#${(refund.orderNumber || refund.orderId || '').slice(-8).toUpperCase()}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Type</div>
              <div style="font-weight: 600;">${refund.isFullRefund ? 'Full Refund' : 'Partial Refund'}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Order Total</div>
              <div>${formatCurrency(refund.totalAmount)}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Amount Refunded</div>
              <div style="font-weight: 700; font-size: 1.25rem; color: #dc2626;">${formatCurrency(refund.amountRefunded)}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Refund %</div>
              <div>${((refund.refundPercentage || 0) * 100).toFixed(1)}%</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Date</div>
              <div>${formatDate(refund.createdAt)}</div>
            </div>
          </div>

          <div style="margin-bottom: 1.5rem;">
            <div style="font-size: 0.7rem; color: #888; text-transform: uppercase; margin-bottom: 0.5rem;">Artist Transfers Reversed</div>
            ${transfersHtml}
            <div style="display: flex; justify-content: space-between; padding: 0.5rem; background: #000; color: #fff; margin-top: 0.5rem;">
              <span>Total Clawed Back</span>
              <span style="font-weight: 700;">${formatCurrency(refund.totalReversed)}</span>
            </div>
          </div>

          ${refund.pendingPayoutsAffected > 0 ? `
            <div style="background: #fef3c7; border: 1px solid #fcd34d; padding: 1rem;">
              <div style="font-size: 0.875rem;">
                <strong>${refund.pendingPayoutsAffected}</strong> pending payout(s) were also ${refund.isFullRefund ? 'cancelled' : 'reduced'}
              </div>
            </div>
          ` : ''}
        `;

        openModal('refundModal');
      }

      // View payout details
      document.querySelectorAll('.view-payout-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const payout = JSON.parse(btn.dataset.payout);
          showPayoutDetails(payout);
        });
      });

      function showPayoutDetails(payout) {
        const content = document.getElementById('payoutModalContent');

        content.innerHTML = `
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Artist</div>
              <div style="font-weight: 600;">${payout.artistName || 'Unknown'}</div>
              <div style="font-size: 0.875rem; color: #666;">${payout.artistEmail || ''}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Status</div>
              <div style="font-weight: 600;">${payout.status}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Order</div>
              <div style="font-family: monospace;">#${(payout.orderNumber || payout.orderId || '').slice(-8).toUpperCase()}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Amount</div>
              <div style="font-weight: 700; font-size: 1.25rem;">${formatCurrency(payout.amount)}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Created</div>
              <div>${formatDate(payout.createdAt)}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase;">Artist ID</div>
              <div style="font-size: 0.75rem; font-family: monospace;">${payout.artistId || '-'}</div>
            </div>
          </div>

          ${payout.failureReason ? `
            <div style="background: #fee2e2; border: 1px solid #fca5a5; padding: 1rem; margin-bottom: 1.5rem;">
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase; margin-bottom: 0.25rem;">Failure Reason</div>
              <div style="color: #dc2626;">${payout.failureReason}</div>
            </div>
          ` : ''}

          ${payout.status === 'awaiting_connect' ? `
            <div style="background: #fef3c7; border: 1px solid #fcd34d; padding: 1rem; margin-bottom: 1.5rem;">
              <div style="font-size: 0.875rem;">
                This artist hasn't completed Stripe Connect setup. Once they do, this payout will be processed automatically.
              </div>
              ${payout.notificationSent ? `
                <div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem;">
                  ‚úì Notification email sent ${payout.notificationSentAt ? 'on ' + formatDate(payout.notificationSentAt) : ''}
                </div>
              ` : `
                <div style="font-size: 0.75rem; color: #d97706; margin-top: 0.5rem;">
                  ‚ö†Ô∏è Notification email not sent
                </div>
              `}
            </div>
          ` : ''}

          ${payout.reason ? `
            <div style="margin-bottom: 1.5rem;">
              <div style="font-size: 0.7rem; color: #888; text-transform: uppercase; margin-bottom: 0.25rem;">Reason/Source</div>
              <div>${payout.reason}</div>
            </div>
          ` : ''}

          ${payout.status === 'retry_pending' ? `
            <button class="btn btn-primary" style="width: 100%;" onclick="retryPayout('${payout.id}')">
              üîÑ Retry This Payout
            </button>
          ` : ''}
        `;

        openModal('payoutModal');
      }

      // Retry payout
      document.querySelectorAll('.retry-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          retryPayout(btn.dataset.id);
        });
      });

      async function retryPayout(payoutId) {
        if (!confirm('Retry this payout? This will attempt to transfer funds to the artist.')) return;

        try {
          const response = await fetch('/api/admin/retry-payout', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ payoutId })
          });

          const result = await response.json();

          if (result.success) {
            showToast('Payout retry initiated');
            setTimeout(() => location.reload(), 1500);
          } else {
            showToast(result.error || 'Failed to retry payout', 'error');
          }
        } catch (error) {
          console.error(error);
          showToast('Failed to retry payout', 'error');
        }
      }

      window.retryPayout = retryPayout;

      // Trigger payout for individual payee
      document.querySelectorAll('.trigger-payee-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          triggerPayeePayout(
            btn.dataset.orderId,
            btn.dataset.orderNumber,
            btn.dataset.payeeType,
            btn.dataset.payeeId,
            btn.dataset.payeeName,
            btn.dataset.payeeEmail,
            parseFloat(btn.dataset.payeeAmount),
            btn
          );
        });
      });

      async function triggerPayeePayout(orderId, orderNumber, payeeType, payeeId, payeeName, payeeEmail, amount, btn) {
        const typeLabel = payeeType === 'artist' ? 'Artist' : payeeType === 'supplier' ? 'Supplier' : 'Seller';
        if (!confirm(`Pay ${payeeName} (${typeLabel})?\n\nAmount: ¬£${amount.toFixed(2)}\nEmail: ${payeeEmail}\nOrder: ${orderNumber}`)) return;

        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '‚è≥...';

        try {
          let adminKey = localStorage.getItem('adminKey');
          if (!adminKey) {
            adminKey = prompt('Enter admin key:');
            if (!adminKey) {
              btn.disabled = false;
              btn.innerHTML = originalText;
              return;
            }
            localStorage.setItem('adminKey', adminKey);
          }

          const response = await fetch('/api/admin/trigger-payout', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              orderId,
              adminKey,
              payeeType,
              payeeId,
              payeeName,
              payeeEmail,
              amount
            })
          });

          const result = await response.json();

          if (result.success) {
            btn.innerHTML = '‚úì Paid';
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-success');
            btn.style.background = '#16a34a';
            btn.style.borderColor = '#16a34a';
            showToast(`Paid ¬£${amount.toFixed(2)} to ${payeeName}`);

            // Remove just this payee row after short delay
            setTimeout(() => {
              const payeeRow = btn.closest('div[style*="background"]');
              if (payeeRow) {
                payeeRow.style.opacity = '0.5';
                payeeRow.style.textDecoration = 'line-through';
              }
            }, 1000);
          } else {
            showToast(result.error || 'Payout failed', 'error');
            btn.disabled = false;
            btn.innerHTML = originalText;
          }
        } catch (error) {
          console.error(error);
          showToast('Failed to trigger payout', 'error');
          btn.disabled = false;
          btn.innerHTML = originalText;
        }
      }

      // Trigger payout for an order (legacy - kept for backwards compatibility)
      document.querySelectorAll('.trigger-payout-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          triggerPayout(btn.dataset.orderId, btn.dataset.orderNumber, btn);
        });
      });

      async function triggerPayout(orderId, orderNumber, btn) {
        if (!confirm(`Trigger payout for order ${orderNumber}?\n\nThis will send money to the artist(s) via PayPal.`)) return;

        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '‚è≥ Processing...';

        try {
          // Get admin key from localStorage or prompt
          let adminKey = localStorage.getItem('adminKey');
          if (!adminKey) {
            adminKey = prompt('Enter admin key:');
            if (!adminKey) {
              btn.disabled = false;
              btn.innerHTML = originalText;
              return;
            }
            localStorage.setItem('adminKey', adminKey);
          }

          const response = await fetch('/api/admin/trigger-payout', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ orderId, adminKey })
          });

          const result = await response.json();

          if (result.success) {
            const payouts = result.payouts || [];
            const successful = payouts.filter(p => p.status === 'success').length;
            const failed = payouts.filter(p => p.status === 'failed' || p.status === 'error').length;
            const skipped = payouts.filter(p => p.status === 'skipped').length;

            let message = `Payout results for ${orderNumber}:\n`;
            payouts.forEach(p => {
              message += `\n${p.artistName}: ¬£${p.amount?.toFixed(2)} - ${p.status}`;
              if (p.error) message += ` (${p.error})`;
              if (p.reason) message += ` (${p.reason})`;
            });

            alert(message);

            if (successful > 0) {
              // Remove row from table
              const row = btn.closest('tr');
              if (row) row.remove();
              showToast(`${successful} payout(s) completed`);
            } else if (failed > 0) {
              btn.innerHTML = '‚ùå Failed';
              btn.classList.remove('btn-primary');
              btn.classList.add('btn-danger');
            }
          } else {
            showToast(result.error || 'Payout failed', 'error');
            btn.disabled = false;
            btn.innerHTML = originalText;
          }
        } catch (error) {
          console.error(error);
          showToast('Failed to trigger payout', 'error');
          btn.disabled = false;
          btn.innerHTML = originalText;
        }
      }

      // Mark as paid (manual payout record)
      document.querySelectorAll('.mark-paid-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          markAsPaid(btn.dataset.orderId, btn.dataset.orderNumber, btn);
        });
      });

      async function markAsPaid(orderId, orderNumber, btn) {
        if (!confirm(`Mark order ${orderNumber} as already paid?\n\nThis records the payout without sending money.`)) return;

        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '‚è≥...';

        try {
          let adminKey = localStorage.getItem('adminKey');
          if (!adminKey) {
            adminKey = prompt('Enter admin key:');
            if (!adminKey) {
              btn.disabled = false;
              btn.innerHTML = originalText;
              return;
            }
            localStorage.setItem('adminKey', adminKey);
          }

          const response = await fetch('/api/admin/record-payout', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ orderId, adminKey, notes: 'Manual payout - already paid outside system' })
          });

          const result = await response.json();

          if (result.success) {
            showToast(result.message || 'Marked as paid');
            const row = btn.closest('tr');
            if (row) row.remove();
          } else {
            showToast(result.error || 'Failed to record', 'error');
            btn.disabled = false;
            btn.innerHTML = originalText;
          }
        } catch (error) {
          console.error(error);
          showToast('Failed to record payout', 'error');
          btn.disabled = false;
          btn.innerHTML = originalText;
        }
      }
    </script>
  </Fragment>
</AdminLayout>

<style>
  .tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    border-bottom: 2px solid #e5e5e5;
    padding-bottom: 0;
  }

  .tab {
    padding: 0.75rem 1.5rem;
    background: transparent;
    border: none;
    border-bottom: 3px solid transparent;
    margin-bottom: -2px;
    cursor: pointer;
    font-weight: 600;
    color: #666;
    font-size: 0.9375rem;
    transition: all 0.2s;
  }

  .tab:hover {
    color: #000;
  }

  .tab.active {
    color: #000;
    border-bottom-color: #dc2626;
  }

  .item-info h4 {
    margin: 0;
    font-weight: 600;
  }

  .item-info p {
    margin: 0;
    color: #666;
  }
</style>
