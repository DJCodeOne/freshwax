---
// src/pages/admin/releases/manage.astro
// Fresh Wax Releases Management - Unified Admin Design

import AdminLayout from '../../../layouts/AdminLayout.astro';
import { queryCollection } from '../../../lib/firebase-rest';

export const prerender = false;

// Get admin key for authenticated API calls
const runtimeEnv = (Astro.locals as any)?.runtime?.env;
const adminKey = runtimeEnv?.ADMIN_KEY || import.meta.env.ADMIN_KEY || '';

let releases: any[] = [];
let errorMessage = '';

try {
  // Query releases with limit to prevent runaway - skipCache to ensure fresh data
  releases = await queryCollection('releases', { skipCache: true, limit: 500 });

  // Sort by processedAt or createdAt (newest first), pending releases at top
  releases.sort((a, b) => {
    // Put pending releases first
    if (a.status === 'pending' && b.status !== 'pending') return -1;
    if (b.status === 'pending' && a.status !== 'pending') return 1;

    const dateA = new Date(a.processedAt || a.createdAt || 0);
    const dateB = new Date(b.processedAt || b.createdAt || 0);
    return dateB.getTime() - dateA.getTime();
  });

  console.log('[MANAGE] Loaded releases:', releases.length, 'Pending:', releases.filter(r => r.status === 'pending').length);

} catch (error) {
  console.error('[MANAGE] Error loading releases:', error);
  errorMessage = error instanceof Error ? error.message : 'Unknown error';
}

// Stats
const totalReleases = releases.length;
const liveReleases = releases.filter(r => r.status === 'live').length;
const pendingReleases = releases.filter(r => r.status === 'pending').length;
const draftReleases = releases.filter(r => r.status === 'draft').length;
const vinylReleases = releases.filter(r => r.vinylRelease === true).length;

const stats = [
  { label: 'Total', value: totalReleases },
  { label: 'Live', value: liveReleases, type: 'success' },
  { label: 'Pending', value: pendingReleases, type: pendingReleases > 0 ? 'warning' : 'default' },
  { label: 'Draft', value: draftReleases },
  { label: 'Vinyl', value: vinylReleases, type: 'info' },
];

// Format date
const formatDate = (dateStr) => {
  if (!dateStr) return '-';
  const date = new Date(dateStr);
  return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
};

// Format currency
const formatCurrency = (amount) => {
  return new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(amount || 0);
};
---

<AdminLayout title="Releases" activeNav="releases" showStats={true} stats={stats}>
  <Fragment slot="actions">
    <a href="/admin/releases/process" class="btn btn-outline">Process Submissions</a>
    <a href="/admin/sync-release" class="btn btn-primary">+ Upload New Release</a>
  </Fragment>

  <!-- Filters -->
  <div class="toolbar">
    <div class="filter-tabs">
      <button class="filter-tab active" data-filter="all">All</button>
      <button class="filter-tab" data-filter="live">Live</button>
      <button class="filter-tab" data-filter="pending">Pending</button>
      <button class="filter-tab" data-filter="draft">Draft</button>
    </div>
    
    <div class="filter-group" style="margin-left: auto;">
      <label class="filter-label">Format</label>
      <select id="formatFilter" class="form-select" style="width: auto; padding: 0.5rem 1rem;">
        <option value="">All</option>
        <option value="vinyl">Vinyl Only</option>
        <option value="digital">Digital Only</option>
      </select>
    </div>
    
    <div class="search-wrapper" style="max-width: 250px;">
      <span class="search-icon">üîç</span>
      <input 
        type="text" 
        id="searchInput" 
        class="form-input" 
        placeholder="Search releases..."
      >
    </div>
  </div>

  <!-- Error State -->
  {errorMessage && (
    <div class="card mb-3" style="border-color: var(--accent-red);">
      <div class="card-body" style="background: #fef2f2; color: var(--accent-red);">
        <strong>Error loading releases:</strong> {errorMessage}
      </div>
    </div>
  )}

  <!-- Releases Table -->
  <div class="card">
    <div class="card-header">
      <h2>All Releases</h2>
      <span class="text-muted">{releases.length} releases</span>
    </div>
    <div class="table-wrapper">
      <table class="data-table" id="releasesTable">
        <thead>
          <tr>
            <th>Release</th>
            <th>Artist</th>
            <th>Format</th>
            <th>Price</th>
            <th>Status</th>
            <th>Added</th>
            <th class="text-right">Actions</th>
          </tr>
        </thead>
        <tbody>
          {releases.length === 0 ? (
            <tr>
              <td colspan="7" class="text-center text-muted" style="padding: 3rem;">
                {errorMessage ? 'Error loading releases' : 'No releases found'}
              </td>
            </tr>
          ) : (
            releases.map(release => (
              <tr 
                data-status={release.status || 'draft'}
                data-format={release.vinylRelease ? 'vinyl' : 'digital'}
                data-search={`${release.releaseName || ''} ${release.artistName || ''}`.toLowerCase()}
              >
                <td>
                  <div class="item-cell">
                    {release.coverArtUrl ? (
                      <img src={release.coverArtUrl} alt="" loading="lazy">
                    ) : (
                      <div style="width: 48px; height: 48px; background: #e5e5e5; display: flex; align-items: center; justify-content: center;">üíø</div>
                    )}
                    <div class="item-info">
                      <h4>{release.releaseName || 'Untitled'}</h4>
                      <p class="cell-mono">{release.catalogNumber || release.r2FolderName || '-'}</p>
                    </div>
                  </div>
                </td>
                <td class="cell-primary">
                  {release.artistName || 'Unknown'}
                </td>
                <td>
                  <div class="flex gap-1">
                    <span class="badge badge-info">üíø Digital</span>
                    {release.vinylRelease && (
                      <span class="badge badge-pending">üìÄ Vinyl</span>
                    )}
                  </div>
                </td>
                <td class="font-bold">
                  {formatCurrency(release.pricePerSale || release.pricing?.digital || release.digitalPrice || release.price || 0)}
                  {release.vinylRelease && (release.vinylPrice || release.pricing?.vinyl) && (
                    <div class="cell-secondary">Vinyl: {formatCurrency(release.vinylPrice || release.pricing?.vinyl)}</div>
                  )}
                </td>
                <td>
                  <span class={`badge badge-${release.status || 'draft'}`}>
                    {release.status || 'draft'}
                  </span>
                </td>
                <td class="cell-secondary">
                  {formatDate(release.processedAt || release.createdAt)}
                </td>
                <td class="text-right">
                  <div class="flex gap-1 justify-end">
                    <a 
                      href={`/item/${release.id}`}
                      target="_blank"
                      class="btn btn-ghost btn-sm"
                      title="View on Store"
                    >
                      üëÅÔ∏è
                    </a>
                    <a 
                      href={`/admin/releases/edit/${release.id}`}
                      class="btn btn-outline btn-sm"
                      title="Edit"
                    >
                      ‚úèÔ∏è
                    </a>
                    <button
                      class={`btn btn-sm process-audio-btn ${release.audioProcessed ? 'btn-audio-done' : 'btn-outline'}`}
                      data-id={release.id}
                      data-name={release.releaseName}
                      data-processed={release.audioProcessed ? 'true' : 'false'}
                      title={release.audioProcessed ? 'Audio processed (MP3+WAV ready) - Click to reprocess' : 'Process Audio (generate MP3+WAV)'}
                    >
                      {release.audioProcessed ? '‚úì' : 'üéµ'}
                    </button>
                    {release.status !== 'live' && (
                      <button
                        class="btn btn-success btn-sm publish-btn"
                        data-id={release.id}
                        title="Publish"
                      >
                        üöÄ
                      </button>
                    )}
                    <button 
                      class="btn btn-danger btn-sm delete-btn"
                      data-id={release.id}
                      data-name={release.releaseName}
                      title="Delete"
                    >
                      üóëÔ∏è
                    </button>
                  </div>
                </td>
              </tr>
            ))
          )}
        </tbody>
      </table>
    </div>
  </div>

  <!-- Delete Confirmation Modal -->
  <div id="deleteModal" class="delete-modal hidden">
    <div class="delete-modal-overlay"></div>
    <div class="delete-modal-content">
      <div class="delete-modal-icon">‚ö†Ô∏è</div>
      <h3>Delete Release?</h3>
      <p id="deleteModalText">Are you sure you want to delete this release?</p>
      <p class="delete-warning">This will delete all associated files and cannot be undone.</p>
      <div class="delete-modal-actions">
        <button id="cancelDeleteBtn" class="btn btn-outline">Cancel</button>
        <button id="confirmDeleteBtn" class="btn btn-danger">Delete</button>
      </div>
    </div>
  </div>

  <Fragment slot="scripts">
    <script define:vars={{ adminKey }}>
      // Filter functionality
      const filterTabs = document.querySelectorAll('.filter-tab');
      const formatFilter = document.getElementById('formatFilter');
      const searchInput = document.getElementById('searchInput');
      const tableRows = document.querySelectorAll('#releasesTable tbody tr');
      
      let currentStatusFilter = 'all';

      function filterReleases() {
        const format = formatFilter?.value || '';
        const search = searchInput?.value?.toLowerCase() || '';

        tableRows.forEach(row => {
          const rowStatus = row.dataset.status || '';
          const rowFormat = row.dataset.format || '';
          const rowSearch = row.dataset.search || '';

          const matchStatus = currentStatusFilter === 'all' || rowStatus === currentStatusFilter;
          const matchFormat = !format || rowFormat === format;
          const matchSearch = !search || rowSearch.includes(search);

          row.style.display = (matchStatus && matchFormat && matchSearch) ? '' : 'none';
        });
      }

      filterTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          filterTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          currentStatusFilter = tab.dataset.filter;
          filterReleases();
        });
      });

      formatFilter?.addEventListener('change', filterReleases);
      searchInput?.addEventListener('input', filterReleases);

      // Process audio for a release
      const AUDIO_PROCESSOR_URL = 'http://localhost:8089';

      async function checkAudioProcessor() {
        try {
          const response = await fetch(`${AUDIO_PROCESSOR_URL}/health`, {
            method: 'GET',
            signal: AbortSignal.timeout(2000)
          });
          if (!response.ok) return false;
          const data = await response.json();
          return data.status === 'healthy' && data.r2Configured;
        } catch (e) {
          return false;
        }
      }

      document.querySelectorAll('.process-audio-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const id = btn.dataset.id;
          const name = btn.dataset.name || 'this release';
          const alreadyProcessed = btn.dataset.processed === 'true';

          // Check if audio processor is available
          const isAvailable = await checkAudioProcessor();
          if (!isAvailable) {
            showToast('Audio processor not running. Start it with: node scripts/audio-processor.cjs', 'error');
            return;
          }

          // Different confirmation message if already processed
          const confirmMsg = alreadyProcessed
            ? `Audio already processed for "${name}". Reprocess all tracks? This will regenerate MP3+WAV formats.`
            : `Process audio for "${name}"? This will generate MP3+WAV formats for all tracks.`;

          if (!confirm(confirmMsg)) return;

          btn.disabled = true;
          btn.textContent = '‚è≥';

          try {
            // Get release details
            const releaseRes = await fetch(`/api/get-release?id=${id}&nocache=1`);
            const releaseData = await releaseRes.json();

            if (!releaseData.success || !releaseData.release) {
              throw new Error('Failed to fetch release details');
            }

            const release = releaseData.release;
            const baseFolder = `releases/${id}`;
            const processedTracks = [];

            // Process each track
            for (const track of release.tracks || []) {
              try {
                // Get the R2 key from the track URL
                const url = track.url || track.mp3Url || track.wavUrl;
                if (!url) continue;

                const urlParts = new URL(url);
                const sourceKey = urlParts.pathname.substring(1);

                // Use displayTrackNumber (1-indexed) or fallback to trackNumber+1
                const trackNum = track.displayTrackNumber || (track.trackNumber + 1);
                const trackTitle = track.trackName || track.title || `Track ${trackNum}`;

                const response = await fetch(`${AUDIO_PROCESSOR_URL}/process-track`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    sourceKey: sourceKey,
                    releaseFolder: baseFolder,
                    trackNumber: trackNum,
                    trackTitle: trackTitle
                  })
                });

                const result = await response.json();
                if (result.success) {
                  processedTracks.push({
                    trackNumber: track.trackNumber, // Keep original index for Firebase update
                    mp3Url: result.mp3Url,
                    wavUrl: result.wavUrl,
                    previewUrl: result.previewUrl
                  });
                } else {
                  console.error(`Track ${trackNum} processing failed:`, result.error);
                }
              } catch (err) {
                console.error(`Track processing error:`, err);
              }
            }

            if (processedTracks.length > 0) {
              // Update release with processed URLs
              await fetch('/api/releases/update-tracks', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Admin-Key': adminKey
                },
                body: JSON.stringify({
                  releaseId: id,
                  tracks: processedTracks
                })
              });

              showToast(`Processed ${processedTracks.length} tracks!`);
              setTimeout(() => location.reload(), 1500);
            } else {
              showToast('No tracks were processed', 'error');
              btn.disabled = false;
              btn.textContent = alreadyProcessed ? '‚úì' : 'üéµ';
            }

          } catch (error) {
            console.error(error);
            showToast('Audio processing failed', 'error');
            btn.disabled = false;
            btn.textContent = alreadyProcessed ? '‚úì' : 'üéµ';
          }
        });
      });

      // Publish release
      document.querySelectorAll('.publish-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const id = btn.dataset.id;
          
          if (!confirm('Publish this release and make it live on the store?')) return;
          
          btn.disabled = true;
          btn.textContent = '...';
          
          try {
            const response = await fetch('/api/approve-release', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Admin-Key': adminKey },
              body: JSON.stringify({ releaseId: id, action: 'approve' })
            });
            
            if (!response.ok) throw new Error('Failed to publish');
            
            showToast('Release published successfully!');
            setTimeout(() => location.reload(), 1000);
            
          } catch (error) {
            console.error(error);
            showToast('Failed to publish release', 'error');
            btn.disabled = false;
            btn.textContent = 'üöÄ';
          }
        });
      });

      // Delete release - with custom confirmation modal
      let pendingDeleteId = null;
      let pendingDeleteBtn = null;
      const deleteModal = document.getElementById('deleteModal');
      const deleteModalText = document.getElementById('deleteModalText');
      const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
      const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');

      document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.dataset.id;
          const name = btn.dataset.name || 'this release';

          // Store pending delete info
          pendingDeleteId = id;
          pendingDeleteBtn = btn;

          // Update modal text and show
          deleteModalText.textContent = `Are you sure you want to delete "${name}"?`;
          deleteModal.classList.remove('hidden');
        });
      });

      // Cancel delete
      cancelDeleteBtn?.addEventListener('click', () => {
        deleteModal.classList.add('hidden');
        pendingDeleteId = null;
        pendingDeleteBtn = null;
      });

      // Click overlay to cancel
      deleteModal?.querySelector('.delete-modal-overlay')?.addEventListener('click', () => {
        deleteModal.classList.add('hidden');
        pendingDeleteId = null;
        pendingDeleteBtn = null;
      });

      // Confirm delete
      confirmDeleteBtn?.addEventListener('click', async () => {
        if (!pendingDeleteId || !pendingDeleteBtn) return;

        const btn = pendingDeleteBtn;
        const id = pendingDeleteId;

        // Hide modal and disable button
        deleteModal.classList.add('hidden');
        btn.disabled = true;
        btn.textContent = '...';
        confirmDeleteBtn.disabled = true;
        confirmDeleteBtn.textContent = 'Deleting...';

        try {
          const response = await fetch('/api/delete-release', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Admin-Key': adminKey },
            body: JSON.stringify({ releaseId: id })
          });

          if (!response.ok) throw new Error('Failed to delete');

          const row = btn.closest('tr');
          row.style.opacity = '0';
          row.style.transition = 'opacity 0.3s';
          setTimeout(() => row.remove(), 300);

          showToast('Release deleted');

        } catch (error) {
          console.error(error);
          showToast('Failed to delete release', 'error');
          btn.disabled = false;
          btn.textContent = 'üóëÔ∏è';
        } finally {
          // Reset modal state
          pendingDeleteId = null;
          pendingDeleteBtn = null;
          confirmDeleteBtn.disabled = false;
          confirmDeleteBtn.textContent = 'Delete';
        }
      });
    </script>
  </Fragment>
</AdminLayout>

<style>
  /* Delete Confirmation Modal */
  .delete-modal {
    position: fixed;
    inset: 0;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .delete-modal.hidden {
    display: none;
  }

  .delete-modal-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(4px);
  }

  .delete-modal-content {
    position: relative;
    background: #1a1a2e;
    border: 1px solid #333;
    border-radius: 12px;
    padding: 2rem;
    max-width: 400px;
    width: 90%;
    text-align: center;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
  }

  .delete-modal-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
  }

  .delete-modal-content h3 {
    font-family: 'Inter', sans-serif; font-weight: 700;
    font-size: 1.75rem;
    color: #fff;
    margin: 0 0 0.5rem;
  }

  .delete-modal-content p {
    color: #9ca3af;
    margin: 0 0 0.5rem;
    font-size: 1rem;
  }

  .delete-warning {
    color: #ef4444 !important;
    font-size: 0.9rem !important;
    margin-bottom: 1.5rem !important;
  }

  .delete-modal-actions {
    display: flex;
    gap: 1rem;
    justify-content: center;
  }

  .delete-modal-actions .btn {
    min-width: 100px;
    padding: 0.75rem 1.5rem;
    font-weight: 600;
  }

  .delete-modal-actions .btn-danger {
    background: #dc2626;
    color: #fff;
    border: none;
  }

  .delete-modal-actions .btn-danger:hover {
    background: #b91c1c;
  }

  .delete-modal-actions .btn-outline {
    background: transparent;
    border: 1px solid #555;
    color: #fff;
  }

  .delete-modal-actions .btn-outline:hover {
    background: #333;
  }

  /* Audio processed button - green tick */
  .btn-audio-done {
    background: #16a34a !important;
    border-color: #16a34a !important;
    color: #fff !important;
    cursor: pointer;
  }

  .btn-audio-done:hover {
    background: #15803d !important;
    border-color: #15803d !important;
  }
</style>
