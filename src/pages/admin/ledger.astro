---
// src/pages/admin/ledger.astro
// Sales Ledger - Source of truth for all transactions
// D1 primary, Firebase backup

import AdminLayout from '../../layouts/AdminLayout.astro';
import { saQueryCollection } from '../../lib/firebase-service-account';
import { d1GetLedgerEntries } from '../../lib/d1-catalog';
import { getAdminUids } from '../../lib/admin';

export const prerender = false;
const adminUids = getAdminUids();

// Get environment variables
const env = Astro.locals?.runtime?.env;
const projectId = env?.FIREBASE_PROJECT_ID || import.meta.env.FIREBASE_PROJECT_ID || 'freshwax-store';
const clientEmail = env?.FIREBASE_CLIENT_EMAIL || import.meta.env.FIREBASE_CLIENT_EMAIL;
const privateKey = env?.FIREBASE_PRIVATE_KEY || import.meta.env.FIREBASE_PRIVATE_KEY;

// Build service account key
const serviceAccountKey = clientEmail && privateKey ? JSON.stringify({
  type: 'service_account',
  project_id: projectId,
  private_key_id: 'auto',
  private_key: privateKey.replace(/\\n/g, '\n'),
  client_email: clientEmail,
  client_id: '',
  auth_uri: 'https://accounts.google.com/o/oauth2/auth',
  token_uri: 'https://oauth2.googleapis.com/token'
}) : null;

// Get date ranges
const now = new Date();
const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
const startOfLastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
const endOfLastMonth = new Date(now.getFullYear(), now.getMonth(), 0);
const startOfYear = new Date(now.getFullYear(), 0, 1);

// Fetch ledger entries
let ledgerEntries: any[] = [];
let totals = {
  allTime: { orders: 0, gross: 0, net: 0, stripeFees: 0, ppProcFees: 0, ppPayoutFees: 0, fwFees: 0 },
  thisMonth: { orders: 0, gross: 0, net: 0, stripeFees: 0, ppProcFees: 0, ppPayoutFees: 0, fwFees: 0 },
  lastMonth: { orders: 0, gross: 0, net: 0, stripeFees: 0, ppProcFees: 0, ppPayoutFees: 0, fwFees: 0 },
  thisYear: { orders: 0, gross: 0, net: 0, stripeFees: 0, ppProcFees: 0, ppPayoutFees: 0, fwFees: 0 }
};

// PayPal balance tracking (using actual values)
let paypalBalance = {
  actualGross: 0,      // Total received from customers
  actualFees: 0,       // PayPal transaction fees
  actualNet: 0,        // Net deposited to account
  artistPayouts: 0,    // Total paid to artists
  payoutFees: 0,       // Fees to send payouts
  pendingPayouts: 0,   // Pending artist payouts
  currentBalance: 0    // What should be in PayPal now
};

try {
  // Try D1 first (primary read source)
  const db = env?.DB;
  if (db) {
    try {
      ledgerEntries = await d1GetLedgerEntries(db, { limit: 2000 });
      console.log('[ledger] D1 read:', ledgerEntries.length, 'entries');
    } catch (d1Error) {
      console.error('[ledger] D1 read failed:', d1Error);
    }
  }

  // Fallback to Firebase if D1 empty or failed
  if (ledgerEntries.length === 0 && serviceAccountKey) {
    ledgerEntries = await saQueryCollection(serviceAccountKey, projectId, 'salesLedger', {
      orderBy: { field: 'timestamp', direction: 'DESCENDING' },
      limit: 2000
    });
    console.log('[ledger] Firebase fallback:', ledgerEntries.length, 'entries');
  }

  // Calculate totals
  ledgerEntries.forEach((entry: any) => {
    const timestamp = new Date(entry.timestamp);
    const gross = entry.grossTotal || 0;
    const net = entry.netRevenue || 0;
    const stripeFee = entry.stripeFee || 0;
    const paypalFee = entry.paypalFee || 0;
    const fwFee = entry.freshWaxFee || 0;

    // Use actual values for PayPal balance (fall back to adjusted if no actual)
    const actualGross = entry.actualGrossTotal ?? entry.grossTotal ?? 0;
    const actualPaypalFee = entry.actualPaypalFee ?? entry.paypalFee ?? 0;
    const actualNet = entry.actualNetRevenue ?? entry.netRevenue ?? 0;

    // PayPal balance (only for PayPal transactions)
    if (entry.paymentMethod === 'paypal') {
      paypalBalance.actualGross += actualGross;
      paypalBalance.actualFees += actualPaypalFee;
      paypalBalance.actualNet += actualNet;

      // Track payouts
      if (entry.artistPayoutStatus === 'paid') {
        paypalBalance.artistPayouts += entry.artistPayout || 0;
        paypalBalance.payoutFees += entry.artistPayoutFee || 0;
      } else if (entry.artistPayoutStatus === 'pending') {
        paypalBalance.pendingPayouts += entry.artistPayout || 0;
      }
    }

    // PayPal payout fee (only if paid via PayPal)
    const ppPayoutFee = (entry.artistPayoutMethod === 'paypal' && entry.artistPayoutFee) ? entry.artistPayoutFee : 0;

    // All time
    totals.allTime.orders++;
    totals.allTime.gross += actualGross;
    totals.allTime.net += actualNet;
    totals.allTime.stripeFees += stripeFee;
    totals.allTime.ppProcFees += actualPaypalFee;
    totals.allTime.ppPayoutFees += ppPayoutFee;
    totals.allTime.fwFees += fwFee;

    // This month
    if (timestamp >= startOfMonth) {
      totals.thisMonth.orders++;
      totals.thisMonth.gross += actualGross;
      totals.thisMonth.net += actualNet;
      totals.thisMonth.stripeFees += stripeFee;
      totals.thisMonth.ppProcFees += actualPaypalFee;
      totals.thisMonth.ppPayoutFees += ppPayoutFee;
      totals.thisMonth.fwFees += fwFee;
    }

    // Last month
    if (timestamp >= startOfLastMonth && timestamp <= endOfLastMonth) {
      totals.lastMonth.orders++;
      totals.lastMonth.gross += actualGross;
      totals.lastMonth.net += actualNet;
      totals.lastMonth.stripeFees += stripeFee;
      totals.lastMonth.ppProcFees += actualPaypalFee;
      totals.lastMonth.ppPayoutFees += ppPayoutFee;
      totals.lastMonth.fwFees += fwFee;
    }

    // This year
    if (timestamp >= startOfYear) {
      totals.thisYear.orders++;
      totals.thisYear.gross += actualGross;
      totals.thisYear.net += actualNet;
      totals.thisYear.stripeFees += stripeFee;
      totals.thisYear.ppProcFees += actualPaypalFee;
      totals.thisYear.ppPayoutFees += ppPayoutFee;
      totals.thisYear.fwFees += fwFee;
    }
  });

  // Calculate current PayPal balance
  paypalBalance.currentBalance = paypalBalance.actualNet - paypalBalance.artistPayouts - paypalBalance.payoutFees;
} catch (e) {
  console.error('Error fetching ledger:', e);
}

// Format currency
const formatCurrency = (amount: number) => {
  return new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(amount || 0);
};

// Format date
const formatDate = (dateStr: string) => {
  return new Date(dateStr).toLocaleDateString('en-GB', {
    day: '2-digit',
    month: 'short',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
};
---

<AdminLayout title="Sales Ledger" activeNav="analytics">
  <Fragment slot="actions">
    <a href="/admin/analytics" class="btn btn-outline">
      Back to Analytics
    </a>
    <button class="btn btn-primary" id="migrateBtn">
      Migrate Orders
    </button>
  </Fragment>

  <!-- PayPal Account Balance -->
  <div class="card mb-4">
    <div class="card-header">
      <h2>PayPal Account</h2>
    </div>
    <div class="card-body">
      <div class="ledger-summary">
        <div class="ledger-row">
          <div class="ledger-item">
            <span class="ledger-label">Received</span>
            <span class="ledger-value">{formatCurrency(paypalBalance.actualGross)}</span>
          </div>
          <div class="ledger-item">
            <span class="ledger-label">PP Proc</span>
            <span class="ledger-value muted">-{formatCurrency(paypalBalance.actualFees)}</span>
          </div>
          <div class="ledger-item">
            <span class="ledger-label">PP Payout</span>
            <span class="ledger-value muted">-{formatCurrency(paypalBalance.payoutFees)}</span>
          </div>
          <div class="ledger-item">
            <span class="ledger-label">Paid Artists</span>
            <span class="ledger-value muted">-{formatCurrency(paypalBalance.artistPayouts)}</span>
          </div>
          <div class="ledger-item highlight-green">
            <span class="ledger-label">Balance</span>
            <span class="ledger-value">{formatCurrency(paypalBalance.currentBalance)}</span>
          </div>
          <div class="ledger-item highlight-yellow">
            <span class="ledger-label">Pending</span>
            <span class="ledger-value">{formatCurrency(paypalBalance.pendingPayouts)}</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Summary Stats -->
  <div class="stats-grid cols-4 mb-4">
    <div class="stat-card compact">
      <div class="stat-label">All Time</div>
      <div class="stat-value">{formatCurrency(totals.allTime.gross)}</div>
      <div class="stat-detail">{totals.allTime.orders} orders</div>
    </div>
    <div class="stat-card compact success">
      <div class="stat-label">Paid to Artists</div>
      <div class="stat-value">{formatCurrency(paypalBalance.artistPayouts)}</div>
      <div class="stat-detail">Total payouts</div>
    </div>
    <div class="stat-card compact">
      <div class="stat-label">Total PP Fees</div>
      <div class="stat-value">{formatCurrency(totals.allTime.ppProcFees + totals.allTime.ppPayoutFees)}</div>
      <div class="stat-detail">Proc + Payout</div>
    </div>
    <div class="stat-card compact highlight">
      <div class="stat-label">FreshWax Tax</div>
      <div class="stat-value">{formatCurrency(totals.allTime.fwFees)}</div>
      <div class="stat-detail">Platform revenue</div>
    </div>
  </div>

  <!-- Fee Breakdown - Compact -->
  <div class="card mb-4">
    <div class="card-header" style="padding: 0.75rem 1rem;">
      <h2 style="font-size: 0.9rem;">Fee Breakdown (All Time)</h2>
    </div>
    <div class="card-body" style="padding: 0.75rem 1rem;">
      <div class="ledger-row">
        <div class="ledger-item">
          <span class="ledger-label">Stripe</span>
          <span class="ledger-value" style="font-size: 1rem;">{formatCurrency(totals.allTime.stripeFees)}</span>
        </div>
        <div class="ledger-item">
          <span class="ledger-label">PP Proc</span>
          <span class="ledger-value" style="font-size: 1rem;">{formatCurrency(totals.allTime.ppProcFees)}</span>
        </div>
        <div class="ledger-item">
          <span class="ledger-label">PP Payout</span>
          <span class="ledger-value" style="font-size: 1rem;">{formatCurrency(totals.allTime.ppPayoutFees)}</span>
        </div>
        <div class="ledger-item highlight-red">
          <span class="ledger-label">FW Revenue</span>
          <span class="ledger-value" style="font-size: 1rem;">{formatCurrency(totals.allTime.fwFees)}</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Ledger Entries Table -->
  <div class="card">
    <div class="card-header">
      <h2>Ledger Entries ({ledgerEntries.length})</h2>
    </div>
    <div class="card-body">
      {ledgerEntries.length === 0 ? (
        <div class="empty-state">
          <div class="empty-state-icon">ðŸ“’</div>
          <div class="empty-state-title">No ledger entries yet</div>
          <p class="empty-state-text">Click "Migrate Orders" to import existing orders, or new orders will be added automatically.</p>
        </div>
      ) : (
        <div class="table-wrapper" style="max-height: 600px; overflow-y: auto;">
          <table class="data-table">
            <thead style="position: sticky; top: 0; background: var(--bg-card);">
              <tr>
                <th class="text-center">Date</th>
                <th class="text-center">Order</th>
                <th class="text-center">Actual Gross</th>
                <th class="text-center">Actual Net</th>
                <th class="text-center">Pay To</th>
                <th class="text-center">PP Proc</th>
                <th class="text-center">PP Pay</th>
                <th class="text-center">FW Fee</th>
                <th class="text-center">Payout</th>
                <th class="text-center">Status</th>
                <th class="text-center">Notes</th>
              </tr>
            </thead>
            <tbody>
              {ledgerEntries.slice(0, 100).map((entry: any) => {
                const hasActual = entry.actualGrossTotal !== undefined;
                const actualGross = hasActual ? entry.actualGrossTotal : entry.grossTotal;
                const actualNet = hasActual ? entry.actualNetRevenue : entry.netRevenue;
                const isAdjusted = hasActual && (actualGross !== entry.grossTotal || actualNet !== entry.netRevenue);
                const payoutStatus = entry.artistPayoutStatus || 'n/a';
                return (
                <tr class={isAdjusted ? 'adjusted-row' : ''}>
                  <td class="text-center" style="white-space: nowrap; font-size: 0.75rem;">
                    {formatDate(entry.timestamp)}
                  </td>
                  <td class="text-center" style="font-size: 0.7rem; white-space: nowrap;">
                    <div style="color: var(--text-muted); margin-bottom: 2px;">{entry.customerName || (entry.customerEmail ? entry.customerEmail.split('@')[0] : '-')}</div>
                    <a href={`/admin/orders?search=${entry.orderNumber}`} class="link">
                      {entry.orderNumber || entry.orderId?.slice(0, 8)}
                    </a>
                  </td>
                  <td class="text-center" style="color: var(--text-muted);">
                    {formatCurrency(actualGross)}
                  </td>
                  <td class="text-center" style="color: var(--accent-green);">
                    {formatCurrency(actualGross - (entry.actualPaypalFee || entry.paypalFee || 0) - (entry.freshWaxFee || 0))}
                  </td>
                  <td class="text-center" style="font-size: 0.8rem;">
                    <div>{entry.submitterName || entry.artistName || '-'}</div>
                    {entry.submitterEmail && <div style="font-size: 0.7rem; color: var(--text-muted);" title={entry.submitterEmail}>{entry.submitterEmail.length > 15 ? entry.submitterEmail.slice(0, 15) + '...' : entry.submitterEmail}</div>}
                  </td>
                  <td class="text-center" style="font-size: 0.8rem; color: var(--text-muted);">
                    {entry.paymentMethod === 'paypal' && (entry.actualPaypalFee || entry.paypalFee) ? formatCurrency(entry.actualPaypalFee || entry.paypalFee) : '-'}
                  </td>
                  <td class="text-center" style="font-size: 0.8rem; color: var(--accent-yellow, #eab308);">
                    {entry.artistPayoutFee && entry.artistPayoutMethod === 'paypal' ? formatCurrency(entry.artistPayoutFee) : '-'}
                  </td>
                  <td class="text-center" style="font-size: 0.8rem; color: var(--accent-red, #ef4444);">
                    {entry.freshWaxFee ? formatCurrency(entry.freshWaxFee) : '-'}
                  </td>
                  <td class="text-center">
                    {entry.artistPayout ? formatCurrency(entry.artistPayout) : '-'}
                  </td>
                  <td class="text-center">
                    <span class={`badge ${payoutStatus === 'paid' ? 'badge-success' : payoutStatus === 'pending' ? 'badge-warning' : 'badge-default'}`}>
                      {payoutStatus}
                    </span>
                    <div style="margin-top: 4px;">
                      <span class={`badge ${entry.paymentMethod === 'stripe' ? 'badge-info' : entry.paymentMethod === 'paypal' ? 'badge-info' : 'badge-default'}`}>
                        {entry.paymentMethod}
                      </span>
                    </div>
                  </td>
                  <td class="text-center" style="font-size: 0.65rem; max-width: 100px; color: var(--text-muted); overflow: hidden; text-overflow: ellipsis;" title={entry.adjustmentNote || entry.artistPayoutNote || ''}>
                    {entry.adjustmentNote || entry.artistPayoutNote || '-'}
                  </td>
                </tr>
              )})}
            </tbody>
          </table>
          {ledgerEntries.length > 100 && (
            <p style="padding: 1rem; text-align: center; color: var(--text-muted);">
              Showing 100 of {ledgerEntries.length} entries
            </p>
          )}
        </div>
      )}
    </div>
  </div>
</AdminLayout>

<style>
  /* Ledger summary row */
  .ledger-summary {
    padding: 0.5rem 0;
  }
  .ledger-row {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
    align-items: center;
  }
  .ledger-item {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    background: var(--bg-darker, rgba(0,0,0,0.2));
  }
  .ledger-label {
    font-size: 0.7rem;
    text-transform: uppercase;
    color: var(--text-muted);
    font-weight: 600;
  }
  .ledger-value {
    font-size: 1.25rem;
    font-weight: 700;
  }
  .ledger-value.muted {
    color: var(--text-muted);
  }
  .ledger-item.highlight-green {
    background: rgba(34, 197, 94, 0.15);
    border: 1px solid rgba(34, 197, 94, 0.3);
  }
  .ledger-item.highlight-green .ledger-value {
    color: #22c55e;
  }
  .ledger-item.highlight-yellow {
    background: rgba(234, 179, 8, 0.15);
    border: 1px solid rgba(234, 179, 8, 0.3);
  }
  .ledger-item.highlight-yellow .ledger-value {
    color: #eab308;
  }
  .ledger-item.highlight-red {
    background: rgba(239, 68, 68, 0.15);
    border: 1px solid rgba(239, 68, 68, 0.3);
  }
  .ledger-item.highlight-red .ledger-value {
    color: #ef4444;
  }

  /* Compact stat cards */
  .stat-card.compact {
    padding: 0.75rem 1rem;
  }
  .stat-card.compact .stat-value {
    font-size: 1.25rem;
  }

  .badge {
    display: inline-block;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
  }
  .badge-info {
    background: rgba(59, 130, 246, 0.2);
    color: #3b82f6;
  }
  .badge-warning {
    background: rgba(234, 179, 8, 0.2);
    color: #eab308;
  }
  .badge-success {
    background: rgba(34, 197, 94, 0.2);
    color: #22c55e;
  }
  .badge-default {
    background: rgba(107, 114, 128, 0.2);
    color: #6b7280;
  }
  .link {
    color: var(--accent-red);
    text-decoration: none;
  }
  .link:hover {
    text-decoration: underline;
  }
  .adjusted-row {
    background: rgba(234, 179, 8, 0.1);
  }
  .adjusted-row td {
    border-top: 1px solid rgba(234, 179, 8, 0.3);
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('migrateBtn') as HTMLButtonElement;
    if (!btn) return;

    btn.addEventListener('click', async () => {
      if (!confirm('This will migrate all existing orders to the sales ledger. Continue?')) {
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Migrating...';

      try {
        // First do a dry run
        const dryRunRes = await fetch('/api/admin/migrate-orders-to-ledger?confirm=yes&dryRun=yes');
        const dryRun = await dryRunRes.json();

        if (!confirm(`Dry run complete:\n- Would migrate: ${dryRun.results?.migrated || 0} orders\n- Skipped (already in ledger): ${dryRun.results?.skipped || 0}\n- Cancelled orders: ${dryRun.results?.cancelled || 0}\n\nProceed with actual migration?`)) {
          btn.disabled = false;
          btn.textContent = 'Migrate Orders';
          return;
        }

        // Run actual migration
        const res = await fetch('/api/admin/migrate-orders-to-ledger?confirm=yes');
        const data = await res.json();

        if (data.success) {
          alert(`Migration complete!\n- Migrated: ${data.results?.migrated || 0}\n- Skipped: ${data.results?.skipped || 0}\n- Errors: ${data.results?.errors || 0}`);
          window.location.reload();
        } else {
          alert('Migration failed: ' + (data.error || 'Unknown error'));
        }
      } catch (err) {
        alert('Migration error: ' + (err instanceof Error ? err.message : 'Unknown'));
      } finally {
        btn.disabled = false;
        btn.textContent = 'Migrate Orders';
      }
    });
  });
</script>

<script is:inline define:vars={{ adminUids }}>
  window.ADMIN_UIDS = adminUids;
</script>
<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
  import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
  import { getFirestore, doc, getDoc } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';

  const firebaseConfig = {
    apiKey: "AIzaSyBK-zLzlm62uk3GqYJrPkLhXVoRj6GqT4U",
    authDomain: "freshwax-store.firebaseapp.com",
    projectId: "freshwax-store",
    storageBucket: "freshwax-store.appspot.com",
    messagingSenderId: "684466492498",
    appId: "1:684466492498:web:ca97f5e56c1534b6cc30fb"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  async function checkIsAdmin(uid) {
    if (window.ADMIN_UIDS?.includes(uid)) return true;
    try {
      const userDoc = await getDoc(doc(db, 'users', uid));
      if (userDoc.exists()) {
        const data = userDoc.data();
        return data.roles?.includes('admin') || data.isAdmin === true;
      }
    } catch (e) {
      console.error('Error checking admin:', e);
    }
    return false;
  }

  // Wait for Firebase auth to fully initialize before checking state
  // This prevents redirect loops when navigating between admin pages
  let authInitialized = false;
  let redirectTimeout: number | null = null;

  onAuthStateChanged(auth, async (user) => {
    // Clear any pending redirect
    if (redirectTimeout) {
      clearTimeout(redirectTimeout);
      redirectTimeout = null;
    }

    if (!user) {
      if (!authInitialized) {
        // First check - auth might still be loading cached state
        // Check if there's evidence of a logged-in user (Firebase persistence)
        const hasAuthPersistence = Object.keys(localStorage).some(key =>
          key.startsWith('firebase:authUser:')
        );

        if (hasAuthPersistence) {
          // User was logged in - wait for auth to fully load
          authInitialized = true;
          redirectTimeout = window.setTimeout(() => {
            if (!auth.currentUser) {
              window.location.href = '/login?redirect=/admin/ledger';
            }
          }, 2000);
          return;
        }
      }
      // No persistence or subsequent null - redirect to login
      window.location.href = '/login?redirect=/admin/ledger';
      return;
    }

    authInitialized = true;
    const isAdmin = await checkIsAdmin(user.uid);
    if (!isAdmin) {
      alert('Access denied. Admin privileges required.');
      window.location.href = '/account/dashboard';
    }
  });
</script>
