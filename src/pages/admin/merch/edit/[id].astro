---
// src/pages/admin/merch/edit/[id].astro
// Merch item edit page - based on releases edit layout

import AdminLayout from '../../../../layouts/AdminLayout.astro';
import { getDocument, initFirebaseEnv, clearCache } from '../../../../lib/firebase-rest';
import { saUpdateDocument } from '../../../../lib/firebase-service-account';
import '../../../../styles/admin/merch/edit.css';

export const prerender = false;

// Get admin key from Cloudflare runtime env (production) or import.meta.env (dev)
const runtimeEnv = (Astro.locals as any)?.runtime?.env;
const adminKey = runtimeEnv?.ADMIN_KEY || import.meta.env.ADMIN_KEY || '';

// Firebase API key fallback (same as in firebase-rest.ts)
const FIREBASE_API_KEY_FALLBACK = 'AIzaSyBiZGsWdvA9ESm3OsUpZ-VQpwqMjMpBY6g';

// Initialize Firebase env for Cloudflare runtime
initFirebaseEnv({
  FIREBASE_PROJECT_ID: runtimeEnv?.FIREBASE_PROJECT_ID || import.meta.env.FIREBASE_PROJECT_ID || 'freshwax-store',
  FIREBASE_API_KEY: runtimeEnv?.FIREBASE_API_KEY || import.meta.env.FIREBASE_API_KEY || FIREBASE_API_KEY_FALLBACK,
});

const { id } = Astro.params;

// Fetch product from Firebase
let product = null;
let errorMessage = '';
let successMessage = '';

// Handle form submission
if (Astro.request.method === 'POST') {
  try {
    const formData = await Astro.request.formData();

    const updateData: Record<string, any> = {
      name: formData.get('name') || '',
      sku: formData.get('sku') || '',
      description: formData.get('description') || '',
      category: formData.get('category') || 'general',
      productType: formData.get('productType') || 'other',
      price: parseFloat(formData.get('price') as string) || 0,
      costPrice: parseFloat(formData.get('costPrice') as string) || null,
      salePrice: parseFloat(formData.get('salePrice') as string) || null,
      onSale: formData.get('onSale') === 'on',
      stock: parseInt(formData.get('stock') as string) || 0,
      supplier: formData.get('supplier') || 'Fresh Wax',
      supplierCut: parseFloat(formData.get('supplierCut') as string) || null,
      featured: formData.get('featured') === 'on',
      published: formData.get('published') === 'on',
      updatedAt: new Date().toISOString(),
    };

    // Remove null values
    Object.keys(updateData).forEach(key => {
      if (updateData[key] === null) delete updateData[key];
    });

    // Use service account for authorized write
    const projectId = runtimeEnv?.FIREBASE_PROJECT_ID || import.meta.env.FIREBASE_PROJECT_ID || 'freshwax-store';

    let serviceAccountKey = runtimeEnv?.FIREBASE_SERVICE_ACCOUNT || runtimeEnv?.FIREBASE_SERVICE_ACCOUNT_KEY || import.meta.env.FIREBASE_SERVICE_ACCOUNT || import.meta.env.FIREBASE_SERVICE_ACCOUNT_KEY;

    if (!serviceAccountKey) {
      const clientEmail = runtimeEnv?.FIREBASE_CLIENT_EMAIL || import.meta.env.FIREBASE_CLIENT_EMAIL;
      const privateKey = runtimeEnv?.FIREBASE_PRIVATE_KEY || import.meta.env.FIREBASE_PRIVATE_KEY;

      if (clientEmail && privateKey) {
        serviceAccountKey = JSON.stringify({
          type: 'service_account',
          project_id: projectId,
          private_key_id: 'auto',
          private_key: privateKey.replace(/\\n/g, '\n'),
          client_email: clientEmail,
          client_id: '',
          auth_uri: 'https://accounts.google.com/o/oauth2/auth',
          token_uri: 'https://oauth2.googleapis.com/token'
        });
      }
    }

    if (!serviceAccountKey) {
      throw new Error('Firebase service account not configured');
    }

    await saUpdateDocument(serviceAccountKey, projectId, 'merch', id as string, updateData);
    // Clear cache so we fetch fresh data
    clearCache();
    successMessage = 'Product updated successfully!';

  } catch (error) {
    console.error('[MERCH EDIT] Error updating:', error);
    errorMessage = error instanceof Error ? error.message : 'Failed to update product';
  }
}

// Fetch product data
try {
  const productDoc = await getDocument('merch', id as string);

  if (productDoc) {
    product = { id, ...productDoc };
  } else {
    errorMessage = 'Product not found';
  }
} catch (error) {
  console.error('[MERCH EDIT] Error loading product:', error);
  errorMessage = error instanceof Error ? error.message : 'Unknown error';
}

if (!product && !errorMessage) {
  return Astro.redirect('/admin/merch/manage');
}

// Calculate actual totalStock from variantStock (in case stored value is corrupted)
let calculatedTotalStock = 0;
if (product?.variantStock && typeof product.variantStock === 'object') {
  Object.values(product.variantStock).forEach((v: any) => {
    if (typeof v === 'number') {
      calculatedTotalStock += v;
    } else if (v && typeof v === 'object' && typeof v.stock === 'number') {
      calculatedTotalStock += v.stock;
    }
  });
}
// Use calculated value, falling back to stored value only if it's a valid number
const displayTotalStock = calculatedTotalStock > 0 ? calculatedTotalStock :
  (typeof product?.totalStock === 'number' ? product.totalStock : 0);

// Format currency
const formatCurrency = (amount) => {
  return new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(amount || 0);
};

// Get stock badge class
const getStockBadgeClass = (stock) => {
  if (stock === 0) return 'danger';
  if (stock <= 5) return 'warning';
  return 'success';
};
---

<AdminLayout title={product ? `Edit: ${product.name}` : 'Edit Product'} activeNav="merch">
  <Fragment slot="actions">
    <a href="/admin/merch/manage" class="btn btn-secondary">‚Üê Back to Products</a>
    <a href={`/merch/${id}`} class="btn btn-ghost" target="_blank">View on Store</a>
  </Fragment>

  {errorMessage && (
    <div class="alert alert-danger" style="margin-bottom: 1.5rem;">
      <strong>Error:</strong> {errorMessage}
    </div>
  )}

  {successMessage && (
    <div class="alert alert-success" style="margin-bottom: 1.5rem;">
      <strong>Success:</strong> {successMessage}
    </div>
  )}

  {product && (
    <form method="POST" class="edit-form">
      <div class="edit-grid">
        <!-- Left Column: Main Info -->
        <div class="edit-main">
          <!-- Basic Info -->
          <div class="card">
            <div class="card-header">
              <h2>Product Details</h2>
            </div>
            <div class="card-body">
              <div class="form-row">
                <div class="form-group">
                  <label class="form-label">Product Name</label>
                  <input type="text" name="name" class="form-input" value={product.name || ''} required />
                </div>
                <div class="form-group">
                  <label class="form-label">SKU</label>
                  <input type="text" name="sku" class="form-input" value={product.sku || ''} />
                </div>
              </div>
              
              <div class="form-row">
                <div class="form-group">
                  <label class="form-label">Category</label>
                  <select name="category" class="form-select">
                    <option value="clothing" selected={product.category === 'clothing'}>Clothing</option>
                    <option value="accessories" selected={product.category === 'accessories'}>Accessories</option>
                    <option value="vinyl" selected={product.category === 'vinyl'}>Vinyl</option>
                    <option value="prints" selected={product.category === 'prints'}>Prints</option>
                    <option value="general" selected={product.category === 'general'}>General</option>
                  </select>
                </div>
                <div class="form-group">
                  <label class="form-label">Product Type</label>
                  <select name="productType" class="form-select">
                    <option value="tshirt" selected={product.productType === 'tshirt' || product.productType === 't-shirt'}>T-Shirt</option>
                    <option value="hoodie" selected={product.productType === 'hoodie'}>Hoodie</option>
                    <option value="cap" selected={product.productType === 'cap'}>Cap</option>
                    <option value="hat" selected={product.productType === 'hat'}>Hat</option>
                    <option value="poster" selected={product.productType === 'poster'}>Poster</option>
                    <option value="sticker" selected={product.productType === 'sticker'}>Sticker</option>
                    <option value="other" selected={product.productType === 'other'}>Other</option>
                  </select>
                </div>
              </div>
              
              <div class="form-group">
                <label class="form-label">Description</label>
                <textarea name="description" class="form-textarea" rows="4">{product.description || ''}</textarea>
              </div>
            </div>
          </div>

          <!-- Product Images -->
          <div class="card">
            <div class="card-header">
              <h2>Product Images</h2>
              <span class="image-count" id="imageCount">
                {(product.images?.length || (product.imageUrl ? 1 : 0))} / 5
              </span>
            </div>
            <div class="card-body">
              <div class="images-grid" id="imagesGrid">
                <!-- Images rendered by JavaScript -->

                <!-- Upload slot inside grid -->
                <div class="image-upload-slot" id="uploadSlot" style={(product.images?.length || (product.imageUrl ? 1 : 0)) >= 5 ? 'display: none;' : ''}>
                  <input type="file" id="imageUpload" accept="image/jpeg,image/png,image/webp,image/gif" multiple hidden />
                  <label for="imageUpload" class="upload-label">
                    <span class="upload-icon">üì∑</span>
                    <span class="upload-text">Add Image</span>
                  </label>
                </div>
              </div>
              
              <p class="form-hint" style="margin-top: 1rem;">
                Drag to reorder. First image is primary. Max 10 images, 10MB each. 
                <strong>Images auto-converted to 800√ó800 WebP.</strong>
              </p>
              
              <!-- Upload progress -->
              <div id="uploadProgress" class="upload-progress" style="display: none;">
                <div class="progress-bar">
                  <div class="progress-fill" id="progressFill"></div>
                </div>
                <span class="progress-text" id="progressText">Uploading...</span>
              </div>
            </div>
          </div>

          <!-- Pricing -->
          <div class="card">
            <div class="card-header">
              <h2>Pricing</h2>
            </div>
            <div class="card-body">
              <div class="form-row-3">
                <div class="form-group">
                  <label class="form-label">Cost Price (¬£)</label>
                  <input type="number" name="costPrice" class="form-input" step="0.01" min="0" value={product.costPrice ? product.costPrice.toFixed(2) : ''} placeholder="10.00" />
                  <span class="form-hint">Your cost per unit</span>
                </div>
                <div class="form-group">
                  <label class="form-label">Retail Price (¬£)</label>
                  <input type="number" name="price" class="form-input" step="0.01" min="0" value={product.price ? product.price.toFixed(2) : ''} placeholder="25.00" required />
                </div>
                <div class="form-group">
                  <label class="form-label">Sale Price (¬£)</label>
                  <input type="number" name="salePrice" class="form-input" step="0.01" min="0" value={product.salePrice ? product.salePrice.toFixed(2) : ''} placeholder="20.00" />
                </div>
              </div>
              
              <div class="form-group">
                <label class="checkbox-label">
                  <input type="checkbox" name="onSale" checked={product.onSale} />
                  <span>On Sale</span>
                </label>
              </div>
            </div>
          </div>

          <!-- Stock & Inventory -->
          <div class="card">
            <div class="card-header">
              <h2>Stock & Inventory</h2>
            </div>
            <div class="card-body">
              <div class="form-row">
                <div class="form-group">
                  <label class="form-label">Total Stock</label>
                  <input type="number" name="stock" class="form-input" min="0" value={displayTotalStock} readonly />
                  <span class="form-hint">Calculated from variant stock below</span>
                </div>
                <div class="form-group">
                  <label class="form-label">Supplier</label>
                  <input type="text" name="supplier" class="form-input" value={product.supplier || 'Fresh Wax'} />
                </div>
              </div>
              
              <div class="form-group">
                <label class="form-label">Supplier Cut (%)</label>
                <input type="number" name="supplierCut" class="form-input" step="0.1" min="0" max="100" value={product.supplierCut || ''} style="max-width: 150px;" />
                <span class="form-hint">Percentage of sale that goes to supplier</span>
              </div>
            </div>
          </div>

          <!-- Colours & Sizes -->
          <div class="card">
            <div class="card-header">
              <h2>Colours & Sizes</h2>
            </div>
            <div class="card-body">
              <!-- Colours -->
              <div class="form-group">
                <label class="form-label">Colours</label>
                <div class="colors-list" id="colorsList">
                  {product.colors?.map((color, idx) => (
                    <div class="color-tag" data-index={idx} data-name={color.name} data-hex={color.hex}>
                      <span class="color-swatch-small" style={`background: ${color.hex};`}></span>
                      <span class="color-name">{color.name}</span>
                      <button type="button" class="color-remove" onclick={`removeColor(${idx})`}>&times;</button>
                    </div>
                  ))}
                </div>
                <div class="preset-colors" style="margin-top: 0.75rem;">
                  <span class="form-hint" style="display: block; margin-bottom: 0.5rem;">Quick add:</span>
                  <div class="preset-colors-grid" id="presetColors" style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                    <button type="button" class="preset-color-btn" data-name="White" data-hex="#FFFFFF" title="White" style="width: 32px; height: 32px; background: #FFFFFF; border: 2px solid #ccc; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Black" data-hex="#000000" title="Black" style="width: 32px; height: 32px; background: #000000; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Grey" data-hex="#6B7280" title="Grey" style="width: 32px; height: 32px; background: #6B7280; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Navy" data-hex="#1E3A5F" title="Navy" style="width: 32px; height: 32px; background: #1E3A5F; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Red" data-hex="#DC2626" title="Red" style="width: 32px; height: 32px; background: #DC2626; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Blue" data-hex="#2563EB" title="Blue" style="width: 32px; height: 32px; background: #2563EB; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Green" data-hex="#16A34A" title="Green" style="width: 32px; height: 32px; background: #16A34A; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Yellow" data-hex="#EAB308" title="Yellow" style="width: 32px; height: 32px; background: #EAB308; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Orange" data-hex="#EA580C" title="Orange" style="width: 32px; height: 32px; background: #EA580C; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Pink" data-hex="#EC4899" title="Pink" style="width: 32px; height: 32px; background: #EC4899; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Purple" data-hex="#9333EA" title="Purple" style="width: 32px; height: 32px; background: #9333EA; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                    <button type="button" class="preset-color-btn" data-name="Brown" data-hex="#78350F" title="Brown" style="width: 32px; height: 32px; background: #78350F; border: 2px solid #000; border-radius: 4px; cursor: pointer;"></button>
                  </div>
                </div>
                <div class="add-color-row" style="margin-top: 0.75rem;">
                  <span class="form-hint" style="margin-right: 0.5rem;">Custom:</span>
                  <input type="text" id="newColorName" class="form-input" placeholder="Colour name" style="width: 120px;" />
                  <input type="color" id="newColorHex" class="form-input" value="#000000" style="width: 50px; padding: 2px;" />
                  <button type="button" class="btn btn-secondary btn-sm" onclick="addColor()">+ Add</button>
                </div>
              </div>

              <!-- Sizes -->
              <div class="form-group" style="margin-top: 1rem;">
                <label class="form-label">Sizes</label>
                <div class="sizes-grid" id="sizesGrid">
                  {['XS', 'S', 'M', 'L', 'XL', 'XXL', '3XL'].map(size => (
                    <label class="size-checkbox">
                      <input type="checkbox" value={size} checked={product.sizes?.includes(size)} onchange="updateSizes()" />
                      <span>{size}</span>
                    </label>
                  ))}
                </div>
              </div>

              <!-- Variant Stock grid rendered by JavaScript for dynamic updates -->
              <div class="form-group" id="variantStockSection" style="margin-top: 1.5rem; display: none;">
                <label class="form-label">Stock by Variant</label>
                <div class="apply-all-row">
                  <label>Set All:</label>
                  <input type="number" id="applyAllStock" class="form-input" placeholder="0" min="0" />
                  <button type="button" class="btn btn-primary btn-sm" onclick="applyStockToAll()">Apply to All</button>
                </div>
                <div class="variant-stock-grid" id="variantStockGrid">
                  <!-- Rendered by JavaScript -->
                </div>
                <span class="form-hint">Enter stock quantity for each colour/size combination</span>
              </div>
            </div>
          </div>

          <!-- Status -->
          <div class="card">
            <div class="card-header">
              <h2>Status</h2>
            </div>
            <div class="card-body">
              <div class="form-row">
                <div class="form-group">
                  <label class="checkbox-label">
                    <input type="checkbox" name="published" checked={product.published !== false} />
                    <span>Published (visible in store)</span>
                  </label>
                </div>
                <div class="form-group">
                  <label class="checkbox-label">
                    <input type="checkbox" name="featured" checked={product.featured} />
                    <span>Featured Product</span>
                  </label>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Right Column: Preview & Actions -->
        <div class="edit-sidebar">
          <!-- Preview Card -->
          <div class="card preview-card">
            <div class="preview-image">
              {(product.images?.[0]?.url || product.images?.[0] || product.imageUrl) ? (
                <img src={typeof product.images?.[0] === 'string' ? product.images[0] : (product.images?.[0]?.url || product.imageUrl)} alt={product.name} />
              ) : (
                <div class="placeholder">üëï</div>
              )}
            </div>
            <div class="card-body">
              <h3 class="preview-title">{product.name}</h3>
              <p class="preview-sku">{product.sku || product.id}</p>
              <div class="preview-price">
                {product.onSale && product.salePrice ? (
                  <span class="sale-price">{formatCurrency(product.salePrice)}</span>
                ) : null}
                <span class={product.onSale ? 'original-price strikethrough' : 'current-price'}>
                  {formatCurrency(product.price)}
                </span>
              </div>
              <div class="preview-stock">
                <span class={`badge badge-${getStockBadgeClass(displayTotalStock)}`}>
                  {displayTotalStock} in stock
                </span>
              </div>
            </div>
          </div>

          <!-- Actions -->
          <div class="card">
            <div class="card-body">
              <button type="submit" class="btn btn-primary btn-block">
                üíæ Save Changes
              </button>
              <a href="/admin/merch/manage" class="btn btn-secondary btn-block" style="margin-top: 0.5rem;">
                Cancel
              </a>
            </div>
          </div>

          <!-- Danger Zone -->
          <div class="card" style="border-color: #dc2626;">
            <div class="card-header" style="background: #dc2626;">
              <h2>Danger Zone</h2>
            </div>
            <div class="card-body">
              <button type="button" class="btn btn-danger btn-block" onclick="deleteProduct()">
                üóëÔ∏è Delete Product
              </button>
            </div>
          </div>
        </div>
      </div>
    </form>
  )}
</AdminLayout>

<!-- Image Editor Modal -->
<div class="image-editor-overlay hidden" id="imageEditorOverlay">
  <div class="image-editor-modal">
    <div class="image-editor-header">
      <h3>Resize & Position Image</h3>
      <button type="button" class="image-editor-close" onclick="closeImageEditor()">&times;</button>
    </div>
    <div class="image-editor-body">
      <div class="crop-container" id="cropContainer">
        <img id="cropImage" src="" alt="Crop preview" />
        <div class="crop-grid"></div>
      </div>
      <div class="editor-controls">
        <div class="editor-control-row">
          <label>Zoom</label>
          <input type="range" id="zoomSlider" min="10" max="300" value="100" />
          <span class="value" id="zoomValue">100%</span>
        </div>
      </div>
      <p class="editor-hint">Drag the image to position it within the square frame</p>
      <div class="editor-actions">
        <button type="button" class="btn btn-secondary" onclick="closeImageEditor()">Cancel</button>
        <button type="button" class="btn btn-secondary" onclick="useOriginalImage()">Use Original</button>
        <button type="button" class="btn btn-primary" onclick="saveImageCrop()">Save Cropped</button>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ id, product, adminKey }}>
  console.log('EDIT PAGE SCRIPT LOADED - v4');
  console.log('product.stock:', product.stock, typeof product.stock);
  console.log('product.totalStock:', product.totalStock, typeof product.totalStock);
  const ADMIN_KEY = adminKey;

  // Get initial images array
  let images = [];
  if (product.images && product.images.length > 0) {
    images = product.images.map((img, idx) => ({
      url: typeof img === 'string' ? img : img.url,
      key: typeof img === 'string' ? null : img.key,
      index: idx,
      color: typeof img === 'string' ? null : (img.color || null),
      colorHex: typeof img === 'string' ? null : (img.colorHex || null)
    }));
  } else if (product.imageUrl) {
    images = [{ url: product.imageUrl, key: null, index: 0, color: null, colorHex: null }];
  }

  // Colors and sizes state - ensure proper data types
  let colors = Array.isArray(product.colors) ? product.colors.filter(c => c && typeof c === 'object') : [];
  let sizes = Array.isArray(product.sizes) ? product.sizes.filter(s => typeof s === 'string') : [];

  // Load variantStock - handle mixed old (number) and new (object) formats
  console.log('Raw product.variantStock from server:', product.variantStock);
  let variantStock = {};
  if (product.variantStock && typeof product.variantStock === 'object' && !Array.isArray(product.variantStock)) {
    // Process each entry individually - data might have mixed formats
    Object.entries(product.variantStock).forEach(([key, value]) => {
      if (value && typeof value === 'object' && 'stock' in value) {
        // New format - keep as-is
        variantStock[key] = value;
      } else if (typeof value === 'number') {
        // Old format (e.g., "Cherry Red-XS": 0) - skip these legacy entries
        // They'll be recreated when user sets stock in the grid
        console.log('Skipping old format entry:', key, value);
      }
    });
  }

  console.log('Loaded colors:', colors);
  console.log('Loaded sizes:', sizes);
  console.log('Loaded variantStock:', variantStock);

  // Clean up orphaned variantStock entries that don't match current sizes/colors
  let orphansRemoved = false;
  const validSizesLower = sizes.map(s => s.toLowerCase());
  const validColorsLower = colors.map(c => (typeof c === 'string' ? c : c.name).toLowerCase().replace(/\s/g, '-'));

  Object.keys(variantStock).forEach(key => {
    // Key format: size_color
    const parts = key.split('_');
    if (parts.length >= 2) {
      const keySize = parts[0];
      const keyColor = parts.slice(1).join('_'); // In case color has underscores

      const sizeValid = validSizesLower.includes(keySize) || keySize === 'onesize';
      const colorValid = validColorsLower.includes(keyColor) || keyColor === 'default';

      if (!sizeValid || !colorValid) {
        console.log('Removing orphaned variant stock:', key, '(size valid:', sizeValid, ', color valid:', colorValid, ')');
        delete variantStock[key];
        orphansRemoved = true;
      }
    }
  });

  // Fix corrupted totalStock if needed - recalculate from variantStock
  let calculatedTotalStock = 0;
  Object.values(variantStock).forEach(v => {
    if (typeof v === 'number') {
      calculatedTotalStock += v;
    } else if (v && typeof v === 'object' && typeof v.stock === 'number') {
      calculatedTotalStock += v.stock;
    }
  });

  // Check if totalStock needs fixing (corrupted, doesn't match, or orphans were removed)
  const storedTotal = typeof product.totalStock === 'number' ? product.totalStock : 0;
  const needsFix = orphansRemoved ||
                   typeof product.totalStock !== 'number' ||
                   typeof product.stock !== 'number' ||
                   storedTotal !== calculatedTotalStock;

  if (needsFix) {
    console.log('Syncing stock data...', {
      originalTotalStock: product.totalStock,
      originalStock: product.stock,
      calculatedTotalStock,
      orphansRemoved
    });
    // Auto-save the fix - include cleaned variantStock if orphans were removed
    const updateData = {
      productId: id,
      totalStock: calculatedTotalStock
    };
    if (orphansRemoved) {
      updateData.variantStock = variantStock;
    }
    fetch('/api/update-merch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Admin-Key': ADMIN_KEY },
      body: JSON.stringify(updateData)
    }).then(r => r.json()).then(result => {
      if (result.success) {
        console.log('Synced totalStock to:', calculatedTotalStock, orphansRemoved ? '(orphans cleaned)' : '');
        // Update the display
        const stockInput = document.querySelector('input[name="stock"]');
        if (stockInput) stockInput.value = calculatedTotalStock;
      } else {
        console.error('Failed to sync stock data:', result.error);
      }
    }).catch(err => console.error('Error syncing stock:', err));
  }

  // Color management
  window.addColor = function() {
    const nameInput = document.getElementById('newColorName');
    const hexInput = document.getElementById('newColorHex');
    const name = nameInput.value.trim();
    const hex = hexInput.value;

    if (!name) {
      alert('Please enter a colour name');
      return;
    }

    // Check for duplicate
    if (colors.find(c => c.name.toLowerCase() === name.toLowerCase())) {
      alert('This colour already exists');
      return;
    }

    colors.push({ name, hex });
    renderColors();
    saveColorsAndSizes();

    // Clear inputs
    nameInput.value = '';
    hexInput.value = '#000000';
  };

  // Add preset color
  window.addPresetColor = function(name, hex) {
    // Check for duplicate
    if (colors.find(c => c.name.toLowerCase() === name.toLowerCase())) {
      return; // Already exists
    }

    colors.push({ name, hex });
    renderColors();
    saveColorsAndSizes();
  };

  // Initialize preset color buttons
  document.querySelectorAll('.preset-color-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const name = btn.dataset.name;
      const hex = btn.dataset.hex;
      addPresetColor(name, hex);
    });
  });

  // Update preset button states based on current colors
  function updatePresetButtons() {
    document.querySelectorAll('.preset-color-btn').forEach(btn => {
      const name = btn.dataset.name;
      const isAdded = colors.some(c => c.name.toLowerCase() === name.toLowerCase());
      btn.classList.toggle('added', isAdded);
    });
  }

  window.removeColor = function(index) {
    const color = colors[index];
    if (!confirm(`Remove ${color.name}? This will also remove any stock data for this colour.`)) return;

    // Remove variant stock for this color (new format uses size_color)
    const colorLower = color.name.toLowerCase().replace(/\s/g, '-');
    Object.keys(variantStock).forEach(key => {
      if (key.endsWith('_' + colorLower)) {
        delete variantStock[key];
      }
    });

    colors.splice(index, 1);
    renderColors();
    saveColorsAndSizes();
  };

  function renderColors() {
    const list = document.getElementById('colorsList');
    list.innerHTML = colors.map((color, idx) => `
      <div class="color-tag" data-index="${idx}">
        <span class="color-swatch-small" style="background: ${color.hex};"></span>
        <span class="color-name">${color.name}</span>
        <button type="button" class="color-remove" onclick="removeColor(${idx})">&times;</button>
      </div>
    `).join('');

    // Update preset button states
    updatePresetButtons();

    // Re-render variant grid if needed
    renderVariantGrid();
  }

  // Size management
  window.updateSizes = function() {
    const checkboxes = document.querySelectorAll('#sizesGrid input[type="checkbox"]');
    const newSizes = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);

    // Find removed sizes and clean up their variantStock entries
    const removedSizes = sizes.filter(s => !newSizes.includes(s));
    removedSizes.forEach(removedSize => {
      const sizeLower = removedSize.toLowerCase();
      // Remove all variantStock entries for this size
      Object.keys(variantStock).forEach(key => {
        if (key.startsWith(sizeLower + '_')) {
          console.log('Removing orphaned variant stock:', key);
          delete variantStock[key];
        }
      });
    });

    sizes = newSizes;
    renderVariantGrid();
    saveColorsAndSizes();
  };

  // Variant stock management
  window.updateVariantStock = function(input) {
    const color = input.dataset.color;
    const colorHex = input.dataset.colorhex;
    const size = input.dataset.size;
    // Key format: size_color (matches upload API format)
    const key = ((size || 'onesize') + '_' + (color || 'default')).toLowerCase().replace(/\s/g, '-');
    const newStock = parseInt(input.value) || 0;

    // Preserve existing variant data or create new object
    if (!variantStock[key] || typeof variantStock[key] !== 'object') {
      variantStock[key] = {
        size: size || null,
        color: color || null,
        colorHex: colorHex || null,
        stock: newStock,
        reserved: 0,
        sold: 0
      };
    } else {
      variantStock[key].stock = newStock;
    }

    saveColorsAndSizes();
  };

  // Apply stock to all variants
  window.applyStockToAll = function() {
    const applyInput = document.getElementById('applyAllStock');
    const qty = parseInt(applyInput.value);

    if (isNaN(qty) || qty < 0) {
      alert('Please enter a valid quantity');
      return;
    }

    // Update all variant stock values with proper object format
    colors.forEach(color => {
      const colorName = typeof color === 'string' ? color : color.name;
      const colorHex = typeof color === 'string' ? null : color.hex;

      sizes.forEach(size => {
        // Key format: size_color (matches upload API format)
        const key = (size + '_' + colorName).toLowerCase().replace(/\s/g, '-');

        if (!variantStock[key] || typeof variantStock[key] !== 'object') {
          variantStock[key] = {
            size: size,
            color: colorName,
            colorHex: colorHex,
            stock: qty,
            reserved: 0,
            sold: 0
          };
        } else {
          variantStock[key].stock = qty;
        }
      });
    });

    // Re-render and save
    renderVariantGrid();
    saveColorsAndSizes();

    // Clear input
    applyInput.value = '';
  };

  function renderVariantGrid() {
    const container = document.getElementById('variantStockGrid');
    const section = document.getElementById('variantStockSection');
    if (!container || !section) return;

    if (colors.length === 0 || sizes.length === 0) {
      section.style.display = 'none';
      return;
    }

    section.style.display = 'block';

    // Debug: log variantStock to help diagnose display issues
    console.log('renderVariantGrid - variantStock:', JSON.stringify(variantStock, null, 2));
    console.log('renderVariantGrid - colors:', colors);
    console.log('renderVariantGrid - sizes:', sizes);

    let html = `<table class="variant-table">
      <thead>
        <tr>
          <th></th>
          ${sizes.map(s => `<th>${s}</th>`).join('')}
        </tr>
      </thead>
      <tbody>`;

    colors.forEach(color => {
      const colorName = typeof color === 'string' ? color : (color.name || '');
      const colorHex = typeof color === 'string' ? '#000' : (color.hex || '#000');

      html += `<tr>
        <td>
          <span class="color-swatch-small" style="background: ${colorHex};"></span>
          ${colorName}
        </td>`;
      sizes.forEach(size => {
        // Key format: size_color (matches upload API format)
        const key = (size + '_' + colorName).toLowerCase().replace(/\s/g, '-');
        const variantData = variantStock[key];
        // Handle both old (number) and new (object) formats - ensure stock is always a number
        let stock = 0;
        if (typeof variantData === 'number') {
          stock = variantData;
        } else if (variantData && typeof variantData === 'object' && typeof variantData.stock === 'number') {
          stock = variantData.stock;
        }
        // Ensure stock is a valid number for the input
        stock = Number.isFinite(stock) ? stock : 0;
        html += `<td>
          <input type="number" class="variant-stock-input"
            data-color="${colorName}" data-colorhex="${colorHex}" data-size="${size}"
            value="${stock}" min="0"
            onchange="updateVariantStock(this)" />
        </td>`;
      });
      html += '</tr>';
    });

    html += '</tbody></table>';
    container.innerHTML = html;
  }

  // Save colors, sizes, and variant stock to Firebase
  async function saveColorsAndSizes() {
    // Calculate total stock from variants (handle both old number and new object formats)
    let totalStock = 0;
    Object.values(variantStock).forEach(v => {
      if (typeof v === 'number') {
        totalStock += v;
      } else if (v && typeof v === 'object') {
        totalStock += v.stock || 0;
      }
    });

    try {
      const response = await fetch('/api/update-merch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-Admin-Key': ADMIN_KEY },
        body: JSON.stringify({
          productId: id,
          colors: colors,
          sizes: sizes,
          variantStock: variantStock,
          totalStock: totalStock,
          hasColors: colors.length > 0,
          hasSizes: sizes.length > 0
        })
      });

      const result = await response.json();
      if (!result.success) {
        console.error('Failed to save colors/sizes:', result.error);
      }
    } catch (error) {
      console.error('Error saving colors/sizes:', error);
    }
  }

  // Update image color association
  window.updateImageColor = async function(imageIndex, colorName) {
    images[imageIndex].color = colorName || null;

    // Find the hex for this color
    const colorObj = colors.find(c => c.name === colorName);
    images[imageIndex].colorHex = colorObj ? colorObj.hex : null;

    // Save to Firebase
    await saveImages();
  };

  // Initialize variant grid and images on page load
  document.addEventListener('DOMContentLoaded', () => {
    updatePresetButtons();
    renderVariantGrid();
    renderImages();
  });
  
  const MAX_IMAGES = 10;
  const imagesGrid = document.getElementById('imagesGrid');
  const uploadSlot = document.getElementById('uploadSlot');
  const imageUpload = document.getElementById('imageUpload');
  const imageCountEl = document.getElementById('imageCount');
  const uploadProgress = document.getElementById('uploadProgress');
  const progressFill = document.getElementById('progressFill');
  const progressText = document.getElementById('progressText');

  // Image editor state
  let editorState = {
    active: false,
    imageIndex: -1,
    originalDataUrl: null,
    zoom: 100,
    panX: 0,
    panY: 0,
    isDragging: false,
    dragStartX: 0,
    dragStartY: 0,
    imgNaturalWidth: 0,
    imgNaturalHeight: 0,
    originalFile: null,
    pendingFiles: []
  };

  function openImageEditor(imageUrl, imageIndex = -1, file = null) {
    editorState.active = true;
    editorState.imageIndex = imageIndex;
    editorState.originalDataUrl = imageUrl;
    editorState.originalFile = file;
    editorState.zoom = 100;
    editorState.panX = 0;
    editorState.panY = 0;

    const overlay = document.getElementById('imageEditorOverlay');
    const cropImage = document.getElementById('cropImage');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');

    overlay.classList.remove('hidden');
    zoomSlider.value = 100;
    zoomValue.textContent = '100%';

    function handleImageLoad() {
      editorState.imgNaturalWidth = cropImage.naturalWidth;
      editorState.imgNaturalHeight = cropImage.naturalHeight;

      // Calculate initial zoom to fit entire image within container
      const container = document.getElementById('cropContainer');
      const containerSize = container.offsetWidth;
      const maxDim = Math.max(editorState.imgNaturalWidth, editorState.imgNaturalHeight);
      const initialZoom = Math.floor((containerSize / maxDim) * 100 * 0.70); // 70% to show full image with margin
      console.log('Edit page - Container:', containerSize, 'MaxDim:', maxDim, 'Zoom:', initialZoom);
      editorState.zoom = Math.max(10, Math.min(300, initialZoom));
      zoomSlider.value = editorState.zoom;
      zoomValue.textContent = editorState.zoom + '%';

      updateCropPreview();
    }

    cropImage.onload = handleImageLoad;
    cropImage.src = imageUrl;

    // If image is already cached/complete, trigger manually
    if (cropImage.complete && cropImage.naturalWidth > 0) {
      handleImageLoad();
    }

    setupEditorListeners();
  }

  function setupEditorListeners() {
    const container = document.getElementById('cropContainer');
    const cropImage = document.getElementById('cropImage');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');

    zoomSlider.oninput = function() {
      editorState.zoom = parseInt(this.value);
      zoomValue.textContent = editorState.zoom + '%';
      updateCropPreview();
    };

    container.onmousedown = function(e) {
      if (e.target === cropImage || e.target === container) {
        editorState.isDragging = true;
        editorState.dragStartX = e.clientX - editorState.panX;
        editorState.dragStartY = e.clientY - editorState.panY;
        e.preventDefault();
      }
    };

    document.onmousemove = function(e) {
      if (editorState.isDragging && editorState.active) {
        editorState.panX = e.clientX - editorState.dragStartX;
        editorState.panY = e.clientY - editorState.dragStartY;
        updateCropPreview();
      }
    };

    document.onmouseup = function() {
      editorState.isDragging = false;
    };

    container.ontouchstart = function(e) {
      if (e.touches.length === 1) {
        editorState.isDragging = true;
        editorState.dragStartX = e.touches[0].clientX - editorState.panX;
        editorState.dragStartY = e.touches[0].clientY - editorState.panY;
        e.preventDefault();
      }
    };

    container.ontouchmove = function(e) {
      if (editorState.isDragging && e.touches.length === 1) {
        editorState.panX = e.touches[0].clientX - editorState.dragStartX;
        editorState.panY = e.touches[0].clientY - editorState.dragStartY;
        updateCropPreview();
        e.preventDefault();
      }
    };

    container.ontouchend = function() {
      editorState.isDragging = false;
    };
  }

  function updateCropPreview() {
    const container = document.getElementById('cropContainer');
    const cropImage = document.getElementById('cropImage');
    const containerSize = container.offsetWidth;

    const scale = editorState.zoom / 100;
    const actualWidth = editorState.imgNaturalWidth * scale;
    const actualHeight = editorState.imgNaturalHeight * scale;

    const left = (containerSize - actualWidth) / 2 + editorState.panX;
    const top = (containerSize - actualHeight) / 2 + editorState.panY;

    console.log('updateCropPreview:', {
      containerSize,
      naturalW: editorState.imgNaturalWidth,
      naturalH: editorState.imgNaturalHeight,
      zoom: editorState.zoom,
      scale,
      actualWidth,
      actualHeight,
      left,
      top,
      panX: editorState.panX,
      panY: editorState.panY
    });

    cropImage.style.width = actualWidth + 'px';
    cropImage.style.height = actualHeight + 'px';
    cropImage.style.left = left + 'px';
    cropImage.style.top = top + 'px';
  }

  window.closeImageEditor = function() {
    document.getElementById('imageEditorOverlay').classList.add('hidden');
    editorState.active = false;
    editorState.isDragging = false;

    if (editorState.pendingFiles.length > 0) {
      setTimeout(processNextPendingFile, 100);
    }
  };

  window.saveImageCrop = function() {
    const container = document.getElementById('cropContainer');
    const cropImage = document.getElementById('cropImage');
    const containerSize = container.offsetWidth;

    const outputSize = 800;
    const canvas = document.createElement('canvas');
    canvas.width = outputSize;
    canvas.height = outputSize;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, outputSize, outputSize);

    const scale = editorState.zoom / 100;
    const displayWidth = editorState.imgNaturalWidth * scale;
    const displayHeight = editorState.imgNaturalHeight * scale;
    const centerX = (containerSize - displayWidth) / 2 + editorState.panX;
    const centerY = (containerSize - displayHeight) / 2 + editorState.panY;

    const outputScale = outputSize / containerSize;

    // Draw the full source image at the calculated position/size
    // Use 9-argument form: drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh)
    ctx.drawImage(
      cropImage,
      0, 0, editorState.imgNaturalWidth, editorState.imgNaturalHeight,  // source: full image
      centerX * outputScale, centerY * outputScale,  // destination position
      displayWidth * outputScale, displayHeight * outputScale  // destination size
    );

    canvas.toBlob(async blob => {
      progressText.textContent = 'Uploading cropped image...';
      uploadProgress.style.display = 'block';
      progressFill.style.width = '50%';

      try {
        const formData = new FormData();
        formData.append('file', blob, 'cropped.jpg');
        formData.append('folder', `merch/${id}`);
        formData.append('filename', `${Date.now()}_cropped.webp`);

        const response = await fetch('/api/upload-merch-image', {
          method: 'POST',
          headers: { 'X-Admin-Key': ADMIN_KEY },
          body: formData
        });

        const result = await response.json();
        console.log('Crop upload result:', result);

        if (result.success) {
          if (editorState.imageIndex >= 0) {
            // Editing existing image - replace
            images[editorState.imageIndex].url = result.url;
            images[editorState.imageIndex].key = result.key;
          } else {
            // New image - add to list
            images.push({
              url: result.url,
              key: result.key,
              index: images.length
            });
          }
          renderImages();
          await saveImages();
          console.log('Image saved successfully');
        } else {
          alert('Failed to upload: ' + (result.error || result.details || 'Unknown error'));
        }
      } catch (error) {
        console.error('Upload error:', error);
        alert('Failed to upload cropped image: ' + error.message);
      }

      uploadProgress.style.display = 'none';
      closeImageEditor();
    }, 'image/jpeg', 0.9);
  };

  window.useOriginalImage = async function() {
    // Use the original image without any cropping
    console.log('useOriginalImage called', { imageIndex: editorState.imageIndex, hasFile: !!editorState.originalFile });

    if (editorState.imageIndex >= 0) {
      // Editing existing image - nothing to change, just close
      alert('Cannot use original for existing images - they are already uploaded');
      closeImageEditor();
      return;
    }

    if (!editorState.originalFile) {
      alert('Error: No original file available');
      closeImageEditor();
      return;
    }

    // New image upload - upload the original file without cropping
    if (editorState.originalFile) {
      // New image upload - upload the original file without cropping
      uploadProgress.style.display = 'block';
      progressFill.style.width = '50%';
      progressText.textContent = 'Uploading original image...';

      try {
        const formData = new FormData();
        formData.append('file', editorState.originalFile);
        formData.append('folder', `merch/${id}`);
        formData.append('filename', `${Date.now()}_original.webp`);
        formData.append('keepOriginal', 'true'); // Skip cropping, keep original dimensions

        const response = await fetch('/api/upload-merch-image', {
          method: 'POST',
          headers: { 'X-Admin-Key': ADMIN_KEY },
          body: formData
        });

        const result = await response.json();
        console.log('Upload result:', result);

        if (result.success) {
          images.push({
            url: result.url,
            key: result.key,
            index: images.length
          });
          console.log('Image added, total:', images.length);
          renderImages();
          await saveImages();
          console.log('Images saved to Firebase');
        } else {
          console.error('Upload failed:', result);
          alert('Failed to upload: ' + (result.error || result.details || 'Unknown error'));
        }
      } catch (error) {
        console.error('Upload error:', error);
        alert('Failed to upload original image: ' + error.message);
      }

      uploadProgress.style.display = 'none';
      closeImageEditor();
    }
  };

  window.editImage = function(idx) {
    openImageEditor(images[idx].url, idx, null);
  };

  function processNextPendingFile() {
    if (editorState.pendingFiles.length === 0) return;
    const { dataUrl, file } = editorState.pendingFiles.shift();
    openImageEditor(dataUrl, -1, file);
  }
  
  function updateImageCount() {
    imageCountEl.textContent = `${images.length} / ${MAX_IMAGES}`;
    uploadSlot.style.display = images.length >= MAX_IMAGES ? 'none' : 'flex';
  }
  
  function renderImages() {
    // Remove all existing image items (but keep upload slot)
    const existingItems = imagesGrid.querySelectorAll('.image-item');
    existingItems.forEach(item => item.remove());

    // Build color options HTML
    const colorOptions = colors.map(c =>
      `<option value="${c.name}" data-hex="${c.hex}">${c.name}</option>`
    ).join('');

    // Re-render images
    images.forEach((img, idx) => {
      const div = document.createElement('div');
      div.className = 'image-item';
      div.draggable = true;
      div.dataset.index = idx;
      div.dataset.url = img.url;

      const selectedColor = img.color || '';

      div.innerHTML = `
        <img src="${img.url}" alt="Product image ${idx + 1}" />
        <div class="image-overlay">
          <button type="button" class="image-btn image-btn-edit" title="Edit image" data-action="edit">‚úèÔ∏è</button>
          <button type="button" class="image-btn image-btn-primary" title="Set as primary" data-action="primary">‚≠ê</button>
          <button type="button" class="image-btn image-btn-delete" title="Delete image" data-action="delete">üóëÔ∏è</button>
        </div>
        ${idx === 0 ? '<span class="primary-badge">Primary</span>' : ''}
        <div class="image-color-select">
          <select class="image-color-dropdown" data-index="${idx}" onchange="updateImageColor(${idx}, this.value)">
            <option value="">No colour</option>
            ${colorOptions}
          </select>
        </div>
      `;

      // Set the selected color
      const select = div.querySelector('.image-color-dropdown');
      if (select && selectedColor) {
        select.value = selectedColor;
      }

      // Insert before upload slot
      imagesGrid.insertBefore(div, uploadSlot);

      // Add event listeners
      setupImageItemEvents(div, idx);
    });

    updateImageCount();
    updatePreviewImage();
  }
  
  function setupImageItemEvents(item, idx) {
    // Delete button
    item.querySelector('[data-action="delete"]').addEventListener('click', () => deleteImage(idx));

    // Edit button
    const editBtn = item.querySelector('[data-action="edit"]');
    if (editBtn) {
      editBtn.addEventListener('click', () => editImage(idx));
    }

    // Primary button
    const primaryBtn = item.querySelector('[data-action="primary"]');
    if (primaryBtn) {
      primaryBtn.addEventListener('click', () => setPrimaryImage(idx));
    }
    
    // Drag events
    item.addEventListener('dragstart', handleDragStart);
    item.addEventListener('dragend', handleDragEnd);
    item.addEventListener('dragover', handleDragOver);
    item.addEventListener('drop', handleDrop);
    item.addEventListener('dragleave', handleDragLeave);
  }
  
  // Drag and Drop
  let draggedIndex = null;
  
  function handleDragStart(e) {
    draggedIndex = parseInt(this.dataset.index);
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  }
  
  function handleDragEnd(e) {
    this.classList.remove('dragging');
    document.querySelectorAll('.image-item').forEach(item => {
      item.classList.remove('drag-over');
    });
  }
  
  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    this.classList.add('drag-over');
  }
  
  function handleDragLeave(e) {
    this.classList.remove('drag-over');
  }
  
  function handleDrop(e) {
    e.preventDefault();
    this.classList.remove('drag-over');
    
    const dropIndex = parseInt(this.dataset.index);
    if (draggedIndex === null || draggedIndex === dropIndex) return;
    
    // Reorder array
    const [removed] = images.splice(draggedIndex, 1);
    images.splice(dropIndex, 0, removed);
    
    // Re-render and save
    renderImages();
    saveImages();
  }
  
  // Delete image
  async function deleteImage(idx) {
    if (!confirm('Delete this image?')) return;
    
    const img = images[idx];
    
    // Remove from array
    images.splice(idx, 1);
    renderImages();
    
    // Save to Firebase
    await saveImages();
  }
  
  // Set primary image (move to first position)
  async function setPrimaryImage(idx) {
    if (idx === 0) return;
    
    const [removed] = images.splice(idx, 1);
    images.unshift(removed);
    
    renderImages();
    await saveImages();
  }
  
  // Update preview image in sidebar
  function updatePreviewImage() {
    const previewContainer = document.querySelector('.preview-image');
    if (!previewContainer) return;
    
    let previewImg = previewContainer.querySelector('img');
    const previewPlaceholder = previewContainer.querySelector('.placeholder');
    
    if (images.length > 0) {
      const imageUrl = images[0].url;
      
      if (previewImg) {
        previewImg.src = imageUrl;
      } else {
        // Create img element if it doesn't exist
        previewImg = document.createElement('img');
        previewImg.src = imageUrl;
        previewImg.alt = 'Product preview';
        
        if (previewPlaceholder) {
          previewPlaceholder.replaceWith(previewImg);
        } else {
          previewContainer.innerHTML = '';
          previewContainer.appendChild(previewImg);
        }
      }
    } else {
      // No images - show placeholder
      if (previewImg) {
        previewImg.remove();
      }
      if (!previewPlaceholder) {
        previewContainer.innerHTML = '<div class="placeholder">üëï</div>';
      }
    }
  }
  
  // Upload new images - now goes through editor to give choice of crop or original
  imageUpload.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files);
    if (files.length === 0) return;

    // Check limit
    const remaining = MAX_IMAGES - images.length;
    if (remaining <= 0) {
      alert('Maximum 10 images allowed');
      return;
    }

    const filesToUpload = files.slice(0, remaining);

    // Reset input so same file can be selected again
    imageUpload.value = '';

    // Queue files for editor
    for (const file of filesToUpload) {
      // Validate
      if (!['image/jpeg', 'image/png', 'image/webp', 'image/gif'].includes(file.type)) {
        alert(`Invalid file type: ${file.name}`);
        continue;
      }

      if (file.size > 10 * 1024 * 1024) {
        alert(`File too large: ${file.name} (max 10MB)`);
        continue;
      }

      // Read file and queue for editor
      const reader = new FileReader();
      reader.onload = (ev) => {
        editorState.pendingFiles.push({ dataUrl: ev.target.result, file: file });
        // Start processing if not already active
        if (!editorState.active && editorState.pendingFiles.length === 1) {
          processNextPendingFile();
        }
      };
      reader.readAsDataURL(file);
    }
  });

  // Legacy direct upload function (kept for reference but not used)
  async function directUploadImage(file, index, total) {
    uploadProgress.style.display = 'block';
    progressFill.style.width = '0%';
    progressText.textContent = `Processing ${index + 1} / ${total}...`;

    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('folder', `merch/${id}`);
      formData.append('filename', `${Date.now()}_${index}.webp`);

      const response = await fetch('/api/upload-merch-image', {
        method: 'POST',
        headers: { 'X-Admin-Key': ADMIN_KEY },
        body: formData
      });

      const result = await response.json();

      if (result.success) {
        images.push({
          url: result.url,
          key: result.key,
          index: images.length
        });
        renderImages();
        await saveImages();
      } else {
        alert(`Failed to upload ${file.name}: ${result.error}`);
      }
    } catch (error) {
      console.error('Upload error:', error);
      alert(`Failed to upload ${file.name}`);
    }

    uploadProgress.style.display = 'none';
  }
  
  // Save images to Firebase
  async function saveImages() {
    try {
      const response = await fetch('/api/update-merch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-Admin-Key': ADMIN_KEY },
        body: JSON.stringify({
          productId: id,
          images: images.map((img, idx) => ({
            url: img.url,
            key: img.key,
            index: idx,
            isPrimary: idx === 0,
            color: img.color || null,
            colorHex: img.colorHex || null
          })),
          primaryImage: images[0]?.url || null
        })
      });
      
      const result = await response.json();

      if (!result.success) {
        console.error('Failed to save images:', result.error, result.details);
        alert('Failed to save images: ' + (result.details || result.error));
      }
    } catch (error) {
      console.error('Save error:', error);
      alert('Save error: ' + error);
    }
  }
  
  // Delete product
  function deleteProduct() {
    if (!confirm('Are you sure you want to delete this product? This action cannot be undone.')) {
      return;
    }

    fetch('/api/delete-merch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Admin-Key': ADMIN_KEY },
      body: JSON.stringify({ productId: id })
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        window.location.href = '/admin/merch/manage';
      } else {
        alert('Error: ' + (data.error || 'Failed to delete'));
      }
    })
    .catch(err => {
      alert('Error: ' + err.message);
    });
  }
  
  window.deleteProduct = deleteProduct;
  
  // Initialize drag events for existing items
  document.querySelectorAll('.image-item').forEach((item, idx) => {
    setupImageItemEvents(item, idx);
  });
  
  updateImageCount();
  
  // Update preview immediately to ensure correct image is shown
  updatePreviewImage();
</script>
